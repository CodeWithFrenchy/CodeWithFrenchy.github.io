---
title: .NET 10 - Nouveaut√©s, Performances et Support Prolong√©
date: 2025-10-06 19:00:00 -0400
categories: []
tags: [dotnet]
---
En **novembre 2025**, Microsoft lancera .NET 10, probablement lors de .NET Conf (du 11 au 13 novembre). Cette version s‚Äôannonce riche en am√©liorations de performance et nouvelles fonctionnalit√©s, tout en apportant des changements de support importants. √Ä l‚Äôheure o√π j‚Äô√©cris cet article en fin septembre 2025, [.NET 10 est en RC1](https://devblogs.microsoft.com/dotnet/dotnet-10-rc-1/) (depuis le 9 septembre), et la version finale sera une **LTS** (Long Term Support) prise en charge **jusqu‚Äôen novembre 2028**. Notons d‚Äôailleurs un ajustement de strat√©gie : les versions **STS** (Standard Term Support, impaires comme .NET 9) [b√©n√©ficient d√©sormais de **24 mois** de support](https://devblogs.microsoft.com/dotnet/dotnet-sts-releases-supported-for-24-months/) au lieu de 18 auparavant. En clair, .NET 9 (sorti en 2024) aura sa fin de support repouss√©e √† novembre 2026, soit le m√™me jour que .NET 8 LTS.

.NET 10 √©tant une version majeure, il est illusoire de vouloir lister **tous** les changements dans un seul article. Nous allons donc nous concentrer sur les faits marquants. Pr√©parez-vous √† d√©couvrir des gains de performance notables, des nouveaut√©s du c√¥t√© du framework et du langage C#14, ainsi que quelques conseils sur la migration.

## Des performances encore am√©lior√©es

Chaque nouvelle version de .NET apporte son lot d‚Äôoptimisations, et .NET 10 ne fait pas exception. L‚Äôing√©nieur Stephen Toub a publi√© [son traditionnel _pav√©_ de plus de 200 pages d√©taillant](https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-10/) _"des centaines de petites am√©liorations qui, mises bout √† bout, rendent .NET 10 plus rapide"_. Inutile de chercher une r√©volution unique : les gains viennent d‚Äôune multitude de micro-optimisations dans le JIT, le GC, les collections, etc., qui _grattent_ des nanosecondes par-ci, quelques octets par-l√†, sur des op√©rations ex√©cut√©es des milliards de fois. Par exemple, le runtime est d√©sormais plus intelligent pour allouer certains objets sur le _stack_ plut√¥t que dans le _heap_ (gr√¢ce √† l‚Äô_escape analysis_), √©vitant des allocations m√©moire. Les boucles _foreach_ sur des collections sont un poil plus efficaces, tout comme de nombreuses m√©thodes LINQ courantes qui ont √©t√© retravaill√©es.

En somme, **.NET 10 est encore plus performant**. Vos applications web, services et outils gagneront en rapidit√© sans changer une ligne de code, gr√¢ce aux am√©liorations du JIT, des algorithmes de tri, du _threading_ et bien d‚Äôautres. De quoi faire plaisir aux d√©veloppeurs en qu√™te de performance‚Ä¶ et aux utilisateurs finaux qui appr√©cieront la r√©activit√©.

## Nouvelles fonctionnalit√©s c√¥t√© framework et runtime

### JSON Patch int√©gr√© √† System.Text.Json

Enfin une **bonne nouvelle pour les API REST** : .NET 10 introduit une **impl√©mentation native de JSON Patch** (RFC 6902) bas√©e sur `System.Text.Json`. Jusqu‚Äô√† pr√©sent, appliquer un patch JSON dans ASP.NET Core n√©cessitait la biblioth√®que externe `Newtonsoft.Json`. D√©sormais, plus besoin de cet extra, [on peut manipuler des JsonPatchDocument directement via `System.Text.Json`](https://www.linkedin.com/posts/davidcallan_new-jsonpatch-implementation-with-systemtextjson-activity-7325901947905978368-qqFv/?utm_source=share&utm_medium=member_desktop&rcm=ACoAADcW9iUBeV3L19UkltmrPLHuir3wSexbkJQ), avec de bien meilleures performances et une empreinte m√©moire r√©duite. Concr√®tement, un package `Microsoft.AspNetCore.JsonPatch.SystemTextJson` fait son apparition pour activer cette fonctionnalit√© dans vos contr√¥leurs Web API.

> üí° _Note :_ cette nouvelle impl√©mentation ne g√®re pas les types dynamic et n‚Äôest pas totalement compatible √† 100% avec l‚Äôancienne (quelques cas limites diff√®rent). Mais pour l‚Äô√©crasante majorit√© des usages, on peut enfin se passer de [Newtonsoft](https://www.newtonsoft.com/json) et appliquer proprement des op√©rations de patch (`add`, `remove`, `replace`, etc.) sur nos mod√®les JSON.

### Observabilit√© renforc√©e : m√©triques ASP.NET Core

Les √©quipes .NET ont beaucoup travaill√© sur l‚Äô**observabilit√©**. .NET 10 enrichit ASP.NET Core de [_nouvelles m√©triques int√©gr√©es_](https://x.com/JamesNK/status/1958332018892394614) pour mieux monitorer vos applications. Par exemple, le framework expose d√©sormais des compteurs (_counters_, _histograms_‚Ä¶) pour suivre les **√©v√©nements d‚Äôauthentification et d‚Äôautorisation** : nombre de nouvelles cr√©ations d‚Äôutilisateurs, changements de mot de passe, tentatives de connexion, etc. Des m√©triques sp√©cifiques √† **ASP.NET Core Identity** ont √©t√© ajout√©es pour mesurer la dur√©e de certaines op√©rations (exemple : `aspnetcore.identity.user.create.duration` pour la cr√©ation d‚Äôun utilisateur).

De m√™me, le gestionnaire de m√©moire interne d‚ÄôASP.NET (pools de m√©moire) expose maintenant des compteurs de _¬´memory eviction¬ª_, utiles pour voir si votre application √©vacue souvent des donn√©es du cache en m√©moire. M√™me **Blazor** a droit √† des m√©triques de cycle de vie de composant et du tra√ßage plus pouss√©, ce qui facilitera le diagnostic de vos applications WebAssembly c√¥t√© client.

Toutes ces m√©triques sont accessibles via le syst√®me de m√©triques .NET (bas√© sur EventCounters/OpenTelemetry Metrics). En clair, vous pouvez brancher vos tableaux de bord de monitoring ([Prometheus](https://prometheus.io/docs/introduction/overview/), [Grafana](https://grafana.com/), [Application Insights](https://learn.microsoft.com/fr-fr/azure/azure-monitor/app/app-insights-overview)‚Ä¶) et obtenir une **observabilit√© fine sans √©crire de code maison**. Un vrai plus pour d√©tecter les goulots d‚Äô√©tranglement et surveiller la sant√© de vos applications en production.

### S√©curit√© et identit√© : support des Passkeys

La r√©volution _passwordless_ arrive dans .NET 10 ! ASP.NET Core Identity prend d√©sormais en charge les [Passkeys](https://andrewlock.net/exploring-dotnet-10-preview-features-6-passkey-support-for-aspnetcore-identity/) (cl√©s d‚Äôauthentification FIDO2/WebAuthn). Concr√®tement, le template d‚Äôapplication Blazor (avec identit√© individuelle) a √©volu√© : l‚Äôespace ¬´ Passkeys ¬ª permet aux utilisateurs d‚Äôenregistrer une cl√© biom√©trique ou un appareil de s√©curit√© pour se connecter.

Les **passkeys** fournissent une m√©thode d‚Äôauthentification sans mot de passe, utilisant des dispositifs biom√©triques ou des cl√©s s√©curis√©es li√©es √† l‚Äôappareil de l‚Äôutilisateur. Avec .NET 10, on peut donc offrir aux utilisateurs la possibilit√© de **se connecter avec Windows Hello, Touch ID, cl√©s USB de s√©curit√©**, etc., plut√¥t qu‚Äôavec le traditionnel couple login/mot de passe. C‚Äôest √† la fois plus **s√©curis√©** (immunis√© contre le [phishing](https://www.microsoft.com/en-us/security/business/security-101/what-is-phishing?msockid=01a323d7c627619a2ad03099c71c6058)) et plus pratique une fois configur√©.

Petite dose de r√©alisme toutefois : dans l‚Äô√©tat actuel (Preview 6), le gabarit impose encore de cr√©er un mot de passe lors de l‚Äôinscription initiale, le _passkey_ venant en option ensuite. Cela a fait tiquer certains (apr√®s tout, le but des _passkeys_ est d‚Äô√©liminer totalement les mots de passe‚Ä¶). Gageons que de futures it√©rations permettront une inscription 100% sans mot de passe. Quoi qu‚Äôil en soit, **int√©grer WebAuthn nativement dans le framework** est un grand pas en avant. Si la s√©curit√© de vos applications web vous tient √† c≈ìur, vous pourrez tirer parti de cette fonctionnalit√© pour proposer le _login_ le plus s√ªr √† vos utilisateurs.

### Mode script en C#

Avec .NET 10, Microsoft continue de faciliter la vie des d√©veloppeurs en mati√®re de **d√©ploiement** et de **prototypage**. Le [**Mode script C# (`dotnet run <fichier>.cs`)**](https://www.youtube.com/watch?v=1Yv6rihgTM0) est l‚Äôune des nouveaut√©s les plus cool pour les d√©veloppeurs : .NET 10 permet d‚Äôex√©cuter directement un **fichier .cs** sans projet ni solution. En tapant simplement `dotnet run monScript.cs`, le SDK compile et lance le code C# imm√©diatement. Id√©al pour tester un bout de code, √©crire un petit utilitaire jetable, ou apprendre C# sans passer par la case `.csproj`. Plus besoin de cr√©er un projet complet pour un programme de 5 lignes ! Cette **exp√©rience ¬´ script ¬ª** rapproche C# de langages comme Python ou JavaScript pour les scenarios rapides. _(Ne jetez pas encore Visual Studio, pour des applications s√©rieuses, le projet reste pertinent, mais pour un script d‚Äôadministrateur, c‚Äôest la vie.)_

.NET 10 am√©liore la **productivit√©** sur tout le cycle de vie : du prototype au d√©ploiement final.

## √âvolutions du langage C# 14

Qui dit nouvelle version .NET dit souvent nouvelle version du langage C#. `.NET 10` s‚Äôaccompagne de **C# 14**, qui apporte [quelques raffinements tr√®s appr√©ciables](https://www.youtube.com/watch?v=RTFdUBKQres) pour les d√©veloppeurs, sans bouleverser la syntaxe existante.

### Extension Members : la fonctionnalit√© "_extension everything_"

C# 14 r√©alise un fantasme de longue date : permettre des [_members_ d‚Äôextension](https://www.youtube.com/watch?v=NKGXp7akpis), pas juste des m√©thodes. Depuis C# 3.0 (en 2007), on peut √©crire des **m√©thodes d‚Äôextension** (_extension methods_) pour ajouter des m√©thodes "virtuelles" √† des types existants. Mais on ne pouvait pas cr√©er de propri√©t√©s d‚Äôextension, ni √©tendre les m√©thodes _statiques_. Plusieurs tentatives avaient √©chou√© dans le pass√©, surnomm√©es "extension everything". Cette fois c‚Äôest la bonne : **les _extension members_ d√©barquent en C# 14**.

Concr√®tement, une nouvelle syntaxe permet de d√©clarer dans une classe statique un bloc `extension` ciblant un type (par exemple `IEnumerable<T>`) et d‚Äôy d√©finir :

- des **propri√©t√©s d‚Äôextension** (comme un `IsEmpty` accessible sur n‚Äôimporte quel `IEnumerable<T>`),
- des **m√©thodes d‚Äôextension statiques** (s‚Äôapparentant √† des m√©thodes de classe du type √©tendu),
- m√™me des **op√©rateurs d‚Äôextension** (surcharge de `operator+` par exemple) qui agissent comme si le type les proposait nativement.

Cette syntaxe est un peu verbeuse au premier abord, mais elle organise mieux le code.

Par exemple, on peut maintenant √©crire :

```csharp
public static class Enumerable 
{
    extension<T>(IEnumerable<T> source)
    {
        public bool IsEmpty => !source.Any();               // propri√©t√© d‚Äôextension
        public IEnumerable<T> Where(Func<T,bool> p) { ‚Ä¶ }   // m√©thode d‚Äôextension (instance)
    }

    extension<T>(IEnumerable<T>)
    {
        public static IEnumerable<T> Combine(IEnumerable<T> first, IEnumerable<T> second) { ... }  // m√©thode statique d‚Äôextension
        public static IEnumerable<T> operator+ (IEnumerable<T> left, IEnumerable<T> right) => left.Concat(right); // op√©rateur d‚Äôextension
    }
}
```

D√®s lors, je peux appeler `maListe.IsEmpty` comme s‚Äôil s‚Äôagissait d‚Äôune propri√©t√© native du type `List`, ou encore `IEnumerable<int>.Combine(seq1, seq2)` comme une m√©thode statique de `IEnumerable` √áa rend le code plus lisible et _discoverable_ (surtout dans IntelliSense) qu‚Äôune m√©thode d‚Äôextension classique perdue dans une classe utilitaire. Bref, une fonctionnalit√© favorite de beaucoup (dont moi-m√™me üòä), qui va permettre de mieux organiser nos extensions.

_(Et pour les puristes : pas de panique, vos m√©thodes d‚Äôextension actuelles continuent de fonctionner comme avant, cette nouvelle syntaxe est_ _optionnelle_ _et r√©trocompatible.)_

### Mot-cl√© field : propri√©t√©s auto-g√©r√©es

Autre petit sucre syntaxique bienvenu : le mot-cl√© [**field**](https://www.linkedin.com/posts/nikola-knez_will-the-%F0%9D%97%B3%F0%9D%97%B6%F0%9D%97%B2%F0%9D%97%B9%F0%9D%97%B1-%F0%9D%97%B8%F0%9D%97%B2%F0%9D%98%86%F0%9D%98%84%F0%9D%97%BC%F0%9D%97%BF%F0%9D%97%B1-finally-activity-7301911673441804289-zIos/?utm_source=share&utm_medium=member_desktop&rcm=ACoAADcW9iUBeV3L19UkltmrPLHuir3wSexbkJQ), qui simplifie la gestion des champs priv√©s dans les propri√©t√©s. Si vous avez d√©j√† impl√©ment√© manuellement le _backing field_ d‚Äôune propri√©t√© pour, par exemple, contr√¥ler la valeur lors du set (`value ?? throw‚Ä¶`), vous savez que c‚Äôest un peu verbeux. C# 14 permet maintenant d‚Äô√©crire directement la logique dans l‚Äôaccesseur `set`, en utilisant `field` pour repr√©senter le champ sous-jacent.

**Exemple :** au lieu de :

```csharp
private string _msg;
public string Message 
{
    get => _msg;
    set => _msg = value ?? throw new ArgumentNullException(nameof(value));
}
```

On peut √©crire simplement :

```csharp
public string Message 
{
    get;
    set => field = value ?? throw new ArgumentNullException(nameof(value));
}
```

Le compilateur se charge de g√©n√©rer le champ priv√© cach√©. Le code est plus concis et clair. Bien s√ªr, `field` n‚Äôest valable _que_ dans le contexte d‚Äôun accesseur de propri√©t√©, il repr√©sente le stockage interne. Attention si vous avez d√©j√† une variable nomm√©e `field` dans votre classe, cela peut ambigu√Øser, il est conseill√© de la renommer ou d‚Äôutiliser `@field` pour lever l‚Äôambigu√Øt√©.

### Numeric String Comparer : le tri "humain" d√©barque

Un petit irritant qui nous donnait la vie dure : le tri de cha√Ænes "avec des nombres" rend souvent des r√©sultats surprenants. Par exemple, quand on trie des versions ou des √©tiquettes comme `["v1", "v2", "v10"]`, un tri [lexicographique](https://fr.wikipedia.org/wiki/Lexicographie) donnera quelque chose comme `["v1", "v10", "v2"]`, ce qui est contre-intuitif. üòÖ

Avec .NET 10, le [numeric string comparer](https://x.com/Dave_DotNet/status/1916923470492930461) corrige cela. Il permet de comparer les cha√Ænes en traitant les morceaux num√©riques √† l‚Äôint√©rieur comme des nombres, ce qui donne un tri "logique" :

```csharp
var list = ["Windows 10", "Windows 7"];

// tri par d√©faut

list.Sort(StringComparer.Orginal);
Console.WriteLine(string.Join(", "), list)); // "Windows 10", "Windows 7"

list.Sort(StringComparer.NumericOrdering);
Console.WriteLine(string.Join(", "), list)); // "Windows 7", "Windows 10"
```

Pourquoi c‚Äôest utile :

- Pour trier des **versions** ou des **tags** dans les interfaces utilisateurs, logs, ou listes de fichiers, o√π le r√©sultat ‚Äúhumain‚Äù est pr√©f√©rable.
- Pour le frontend ou les API qui renvoient des listes de fichiers ou de r√©visions, afin d‚Äô√©viter de devoir post-traiter ou √©crire une logique ‚Äúmaison‚Äù.
- Pour les d√©veloppeurs de NuGet ou outils CLI qui manipulent des noms de versions, identifiants, etc.

### `nameof` plus puissant et autres bricoles

Le mot-cl√© `nameof(...)` √©volue aussi l√©g√®rement : il **supporte √† pr√©sent les types g√©n√©riques non construits** (_unbound generic types_). En clair, vous pouvez obtenir le nom d‚Äôun type g√©n√©rique sans sp√©cifier ses param√®tres. Par exemple, [`nameof(Dictionary<T>)`](https://www.linkedin.com/posts/djokic-stefan_another-news-from-c-14-here-is-the-change-activity-7301134071139606528-96bo/?utm_source=share&utm_medium=member_desktop&rcm=ACoAADcW9iUBeV3L19UkltmrPLHuir3wSexbkJQ) renverra "Dictionary" (ou une forme qui indique les param√®tres g√©n√©riques). Auparavant, ce n‚Äô√©tait pas possible directement, ce qui obligeait √† des contournements. Ce changement, bien que mineur, facilite la r√©flexion ou la g√©n√©ration de code source en √©vitant des exceptions ou manipulations de cha√Ænes peu √©l√©gantes.

Parmi les autres nouveaut√©s de C# 14, plus ponctuelles, citons : les **op√©rateurs d‚Äôaffectation compos√©s personnalis√©s** (on peut surcharger `operator +=` par exemple, si le type supporte d√©j√† `+`), les **constructeurs partiels** (utile pour les g√©n√©rateurs de code source), la possibilit√© d‚Äôajouter des modificateurs `ref`, `out` ou `params` aux param√®tres des lambdas, ou encore l‚Äô**affectation null-conditionnelle** (`x?.Prop = value` qui √©vite de devoir faire un `if null` avant d‚Äôassigner). Ces raffinements visent √† rendre le langage plus coh√©rent et expressif, sans bouleverser vos habitudes.

## Am√©liorations ASP.NET Core et √©cosyst√®me

### Minimal APIs : support de ProblemDetails et autres

Le mod√®le des **Minimal API** (introduit en .NET 6) continue de combler ses manques. En .NET 10, la gestion des [erreurs de validation de mod√®le](https://www.youtube.com/watch?v=96lKoqQXbf4) s‚Äôam√©liore : les minimal APIs int√®grent d√©sormais nativement le support de [**IProblemDetailsService**](https://www.linkedin.com/posts/davidcallan_minimal-api-validation-will-fully-support-activity-7333893017826697218-r0KW/?utm_source=share&utm_medium=member_desktop&rcm=ACoAADcW9iUBeV3L19UkltmrPLHuir3wSexbkJQ) pour formater les r√©ponses d‚Äôerreurs. En d‚Äôautres termes, si vous avez des _Endpoints_ en _minimal API_ qui valident l‚Äôentr√©e et retournent une 400 en cas d‚Äôerreur, vous pourrez profiter d‚Äôune r√©ponse JSON standardis√©e _ProblemDetails_ sans effort suppl√©mentaire. Fini les tours de magie pour aligner le format d‚Äôerreur sur celui du reste de votre application : le framework fournit une sortie coh√©rente, et vous pouvez m√™me la personnaliser en enregistrant votre impl√©mentation de `ProblemDetailsService` (par exemple, pour ajouter un code erreur personnalis√©, un lien de documentation, etc.).

Au niveau des APIs, ASP.NET Core 14 supporte aussi pleinement les [**Server-Sent Events (SSE)**](https://www.youtube.com/watch?v=x0725PDUho8) en sortie des contr√¥leurs ou minimal APIs, via une m√©thode utilitaire `TypedResults.ServerSentEvents(...)`. Cela facilite l‚Äôenvoi de flux temps-r√©el du serveur vers le client sans WebSockets (utile pour du monitoring, des notifications live, etc.). C‚Äô√©tait faisable √† la main avant, mais l√† encore le framework le prend en charge nativement.

### Ouverture et standards : OpenAPI 3.1 et gRPC

Le support d‚Äô[**OpenAPI 3.1**](https://x.com/Dave_DotNet/status/1879961044778643877) est d√©sormais int√©gr√© dans .NET 10. Si vous g√©n√©rez la documentation Swagger de vos APIs, elle sera produite par d√©faut au format OpenAPI 3.1 (au lieu de 3.0 pr√©c√©demment). Cette version 3.1 apporte notamment une meilleure prise en charge de [**JSON Schema 2020-12**](https://json-schema.org/draft/2020-12/release-notes) (ceux qui ont sacr√© avec les sch√©mas de nullabilit√© en OpenAPI 3.0 appr√©cieront : plus besoin du champ `nullable: true`, on utilise directement un type `null` dans le sch√©ma). Concr√®tement, vos `int` et `long` nullable appara√Ætront correctement comme `type: ["integer","null"]` dans le JSON de la sp√©cification. Quelques changements breaking sont √† noter dans la librairie OpenAPI.NET interne (passage en v2.0 de `Microsoft.OpenApi`), surtout si vous avez √©crit des _document filters_ ou _operation filters_ custom : les types ont un peu chang√© (les sch√©mas utilisent une interface `IOpenApiSchema` au lieu d‚Äôune classe concr√®te, etc.). En r√©sum√©, .NET suit l‚Äô√©volution du standard OpenApi, pour que vos APIs restent au go√ªt du jour.

Pendant qu‚Äôon parle de services web : du c√¥t√© de **gRPC**, notons une am√©lioration sympathique : la gestion du **streaming c√¥t√© client** (_Client Streaming_) devient plus ergonomique. .NET 10 apporte la prise en charge des _message handlers_ HTTP dans les appels gRPC client, permettant des sc√©narios de retry ou de logging plus int√©gr√©s. _(D‚Äôaccord, c‚Äôest un peu pointu, mais si vous faites du gRPC, jetez un ≈ìil aux release notes pour d√©couvrir ces ajustements.)_

### EF Core 10 : filtres globaux nomm√©s et Left Join

Entity Framework Core 10 accompagne la sortie de .NET 10, et apporte lui aussi son lot de nouveaut√©s. Le plus notable est sans doute l‚Äôarriv√©e des **filtres de requ√™te nomm√©s** ([_named query filters_](https://www.youtube.com/watch?v=SSV7yaH4n9g)). EF Core propose depuis longtemps les filtres globaux (`HasQueryFilter`) pour, par exemple, impl√©menter le _soft delete_ (exclure les entit√©s dont `IsDeleted = true`) ou la multi-tenance (filtrer par `TenantId`). Cependant, jusqu‚Äô√† pr√©sent on ne pouvait d√©finir **qu‚Äôun seul filtre global par entit√©**, pas tr√®s pratique si l‚Äôon voulait combiner, puis en d√©sactiver un s√©lectivement. EF 14 l√®ve cette limitation : on peut maintenant attacher **plusieurs filtres globaux** sur un m√™me mod√®le en leur donnant un nom unique.

Exemple :

```csharp
modelBuilder.Entity<Blog>()
    .HasQueryFilter("SoftDeletionFilter", b => !b.IsDeleted)
    .HasQueryFilter("TenantFilter", b => b.TenantId == tenantId);
```

Puis, dans une requ√™te LINQ, d√©cider d‚Äôignorer l‚Äôun des deux filtres :

```csharp
// R√©cup√©rer tous les blogs en incluant ceux supprim√©s, 
// mais en gardant le filtre de Tenant
var allBlogs = context.Blogs
    .IgnoreQueryFilters("SoftDeletionFilter")
    .ToList();
```

Cette granularit√© √©tait tr√®s attendue pour les applications complexes : on peut enfin combiner proprement des **filtres globaux multiples** (et √©viter les contorsions du style _Enable/Disable Filter_ sur tout le contexte).

Parmi les autres am√©liorations d‚ÄôEF Core 14, on notera le support direct des jointures [**Left Join**](https://hts-learning.com/blog/2025-02-12/net-10-the-new-leftjoin-and-rightjoin-operators-in-linq) et **Right Join** en LINQ. Auparavant, √©crire une requ√™te LINQ √©quivalente √† un LEFT JOIN SQL demandait une syntaxe peu intuitive avec `GroupJoin` + `DefaultIfEmpty`. 

D√©sormais, on dispose d‚Äôune m√©thode d‚Äôextension `.LeftJoin(...)` (et `.RightJoin(...)`), rendant le code plus lisible.

Par exemple :

```csharp
var query = context.Students
    .LeftJoin(
       context.Departments,
       student => student.DepartmentID,
       dept => dept.ID,
       (student, dept) => new { student.Name, Department = dept.Name ?? "[NONE]" }
    );
```

EF Core sait traduire √ßa en SQL (`LEFT JOIN` ou `RIGHT JOIN`). Cela ne change rien en termes de performance par rapport √† avant, mais niveau **lisibilit√© du code**, c‚Äôest le jour et la nuit.

Enfin, EF 14 ajoute plein de petits plus : la recherche **Full-Text** sur Azure Cosmos DB, des traductions SQL suppl√©mentaires (exemple, la m√©thode `DateOnly.ToDateTime()` d√©sormais convertie nativement en SQL), des am√©liorations de performance sur les _split queries_ (pour √©viter des incoh√©rences de tri dans les requ√™tes fractionn√©es), etc. De quoi rendre vos acc√®s aux donn√©es plus _flexibles_ et efficaces.

## En route vers .NET 10 : faut-il migrer ?

La grande question pour les √©quipes : **devez-vous passer √† .NET 10 rapidement ?** La r√©ponse d√©pend de votre situation, mais voici quelques √©l√©ments de r√©flexion :

- .NET 10 est une version **LTS (support long)**, ce qui en fait un candidat solide pour vos applications en production. Elle sera support√©e **3 ans** (jusqu‚Äô√† la fin de 2028), ce qui donne une vision claire √† long terme. Si vous √™tes encore sur .NET 8 LTS, rien ne presse (le support de .NET 8 court jusqu‚Äôen nov. 2026, mais .NET 10 repr√©sente la prochaine cible LTS "naturelle").
- Si vous √™tes sur .NET 9 (STS), notez que le nouvel alignement du support fait que .NET 9 **expirera en m√™me temps que .NET 8** en 2026. Autrement dit, .NET 9 ne prolonge pas votre horizon par rapport √† .NET 8. Dans ce cas, migrer vers .NET 10 (LTS) d√®s que possible vous remet sur un cycle plus confortable.
- Les gains de performance et les nouvelles fonctionnalit√©s peuvent justifier la migration, _surtout_ si vous avez besoin de l‚Äôune des nouveaut√©s (par exemple, le JSON Patch natif ou les passkeys pour vos utilisateurs). `.NET 10` apporte aussi de nombreuses **corrections de bugs** et am√©liorations de stabilit√© accumul√©es depuis `.NET 8` et `.NET 9`.
- **Breaking changes :** √©videmment, qui dit nouvelle version dit potentiels changements incompatibles. Microsoft a publi√© la [liste des _breaking changes_](https://learn.microsoft.com/en-us/dotnet/core/compatibility/10.0) de .NET. Au moment de la RC1, cette liste n‚Äô√©tait pas totalement finalis√©e, mais on sait d√©j√† qu‚Äôil y aura quelques ajustements de comportements (par exxemple, le `nameof` sur types g√©n√©riques mentionn√© plus haut, ou des API retir√©es apr√®s obsolescence). **Avant de migrer**, examinez attentivement ces notes de compatibilit√© pour √©valuer l‚Äôimpact sur votre code. La plupart du temps, l‚Äôupgrade se passera sans encombre pour du code standard, mais mieux vaut pr√©venir que gu√©rir !

En pratique, **.NET 10** s‚Äôannonce comme une version mature et aboutie, avec un bel √©quilibre entre **performance**, **productivit√©** et **modernisation** du stack. Si vos tests de validation passent et que vos d√©pendances (NuGet, frameworks) supportent .NET 10, il n‚Äôy a pas de raison d‚Äôattendre trop longtemps. Microsoft elle-m√™me encourage la mise √† niveau : _"Si vous pr√©voyez de passer de .NET 9 √† 10 bient√¥t, continuez dans cette voie, .NET 10 apporte plein de nouvelles capacit√©s et de meilleures performances"_.

## Pour finir : outillage et √©cosyst√®me

Un dernier mot pour les d√©veloppeurs curieux : en parall√®le de .NET 10, Microsoft commence √† d√©voiler la **prochaine version de Visual Studio**. Eh oui, [Visual Studio 2026 (Insiders)](https://devblogs.microsoft.com/visualstudio/visual-studio-2026-insiders-is-here/) est d√©j√† disponible en aper√ßu. Au menu : am√©liorations de l‚Äô√©diteur, support de C# 14 bien s√ªr, et d'une int√©gration toujours plus pouss√©e de GitHub Copilot et de l‚ÄôIA. Vous pouvez installer Visual Studio 2026 Insiders en parall√®le de votre installation existante sans risque, la grande majorit√© des extensions de Visual Studio 2022 sont compatibles, et d√®s cette version la couverture de code est incluse par d√©faut dans toutes les √©ditions, inutile d√©sormais d‚Äôavoir la version _Entreprise_ pour en profiter.

Enfin, l‚Äô√©cosyst√®me .NET suit le mouvement : attendez-vous √† voir arriver Entity Framework 14, ASP.NET Core 14, Blazor, MAUI 14, etc., align√©s sur cette nouvelle mouture. Les outils de build, CI/CD, containers Docker et autres seront mis √† jour √©galement. La documentation Microsoft Learn est enrichie progressivement (il existe d√©j√† des pages _"What‚Äôs new"_ pour [.NET 10](https://learn.microsoft.com/en-us/dotnet/core/whats-new/dotnet-10/overview), [EF 14](https://learn.microsoft.com/en-us/ef/core/what-is-new/ef-core-10.0/whatsnew), [C# 14](https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-14)‚Ä¶ tr√®s utiles pour approfondir chaque nouveaut√©).

**En r√©sum√©**, .NET 10 marque une √©tape importante en 2025 pour les d√©veloppeurs `.NET`. Support √©tendu, optimisation de tous les recoins du runtime, nouvelles fonctionnalit√©s qui suppriment des irritants (adieu certaines biblioth√®ques tierces obligatoires), langage C# toujours plus expressif‚Ä¶ Le tout sans r√©volution brutale : la mont√©e en version devrait √™tre relativement fluide. Que vous soyez un d√©veloppeur back-end curieux des moindres gains de performances, ou un lead dev prudent qui ne jure que par les LTS stables, `.NET 10` a de quoi vous s√©duire.

Alors, allez-vous migrer ? Si vous cherchez la **s√©curit√©** et la **durabilit√©**, .NET 10 LTS est l√† pour vous jusqu‚Äôen 2028. Si vous aimez les **nouveaut√©s**, foncez, vous aurez de quoi vous amuser. Dans tous les cas, commencez √† √©valuer cette version, √† faire tourner vos tests unitaires dessus, et pr√©parez sereinement l‚Äôavenir de vos applications.

Bonne exploration de `.NET 10`, et _happy coding_ !
