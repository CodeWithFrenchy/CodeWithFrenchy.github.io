<!DOCTYPE html><html lang="fr-FR" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="theme-color" media="(prefers-color-scheme: light)" content="#f7f7f7"><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1e"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="viewport" content="width=device-width, user-scalable=no initial-scale=1, shrink-to-fit=no, viewport-fit=cover" ><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="Faut-il vraiment adopter une architecture microservices" /><meta property="og:locale" content="fr_FR" /><meta name="description" content="Préambule" /><meta property="og:description" content="Préambule" /><link rel="canonical" href="https://codewithfrenchy.github.io//posts/quand-utiliser-architecture-microservices/" /><meta property="og:url" content="https://codewithfrenchy.github.io//posts/quand-utiliser-architecture-microservices/" /><meta property="og:site_name" content="CodeWithFrenchy" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2025-09-08T20:00:00-04:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Faut-il vraiment adopter une architecture microservices" /><meta name="twitter:site" content="@alexis35115" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2025-09-08T20:00:00-04:00","datePublished":"2025-09-08T20:00:00-04:00","description":"Préambule","headline":"Faut-il vraiment adopter une architecture microservices","mainEntityOfPage":{"@type":"WebPage","@id":"https://codewithfrenchy.github.io//posts/quand-utiliser-architecture-microservices/"},"url":"https://codewithfrenchy.github.io//posts/quand-utiliser-architecture-microservices/"}</script><title>Faut-il vraiment adopter une architecture microservices | CodeWithFrenchy</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="CodeWithFrenchy"><meta name="application-name" content="CodeWithFrenchy"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tocbot@4.20.1/dist/tocbot.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener('change', () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.notify(); } /* flipMode() */ } /* ModeToggle */ const modeToggle = new ModeToggle(); </script><body data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" class="mx-auto"> <img src="https://avatars.githubusercontent.com/u/53872142?s=400&u=53187283fe05254234a3890e2b44134f96e3a833&v=4" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title"> <a href="/">CodeWithFrenchy</a></div><div class="site-subtitle font-italic">Architecte logiciel, audacieux et fermier</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>ACCUEIL</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATÉGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>À PROPOS DE</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/alexis35115" aria-label="github" target="_blank" rel="noopener noreferrer"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/alexis35115" aria-label="twitter" target="_blank" rel="noopener noreferrer"> <i class="fab fa-twitter"></i> </a> <a href="https://www.linkedin.com/in/alexis-garon-michaud-a59643219/" aria-label="linkedin" target="_blank" rel="noopener noreferrer"> <i class="fab fa-linkedin"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <span id="breadcrumb"> <span> <a href="/"> Accueil </a> </span> <span>Faut-il vraiment adopter une architecture microservices</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Recherche..."> </span> <span id="search-cancel" >Annuler</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>Faut-il vraiment adopter une architecture microservices</h1><div class="post-meta text-muted"> <span> Posté <em class="" data-ts="1757376000" data-df="DD/MM/YYYY" data-toggle="tooltip" data-placement="bottom"> 08/09/2025 </em> </span><div class="d-flex justify-content-between"> <span> Par <em> <a href="https://twitter.com/alexis35115">Alexis Garon-Michaud</a> </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="4877 mots"> <em>27 min</em> à lire</span></div></div></div><div class="post-content"><h2 id="préambule"><span class="mr-2">Préambule</span><a href="#préambule" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><blockquote><p><em>“On part en microservices ou on reste monolithique ?”</em></p></blockquote><p>C’est une des questions les plus posées et les moins bien tranchées du monde logiciel. Une question qui revient <strong>à chaque projet un peu d’envergure</strong>, et qui déclenche systématiquement les mêmes débats passionnés entre collègues, souvent avec des effets secondaires comme la hausse du débit de voix et des soupirs lourds de sens.</p><p>Certains brandissent l’argument de la scalabilité, d’autres invoquent le Graal du déploiement indépendant. Puis quelqu’un évoque Netflix ou Amazon, et ça y est, tout le monde commence à vouloir des centaines de services, un orchestrateur et une armée de pipelines CI/CD.</p><p>Mais en même temps… on a tous vu (ou vécu) des projets où l’adoption des microservices a amené plus de douleurs que de solutions. Complexité opérationnelle, effet spaghetti distribué, équipe dépassée par les appels réseau qui se perdent dans la brume. Bref, <strong>la promesse des microservices peut vite se transformer en cauchemar… si on s’est trompé de combat</strong>.</p><p>Alors voilà : aujourd’hui, on prend le temps de <strong>vraiment répondre</strong> à cette question. Sans dogme. Sans <em>buzzword</em>. En regardant froidement (mais gentiment 😄) ce que ça implique <strong>de faire — ou pas — du microservice</strong> dans un projet .NET Core. L’objectif ? Te donner une <strong>méthodologie claire</strong>, des <strong>exemples concrets</strong>, et surtout de quoi <strong>prendre une vraie bonne décision</strong> pour ton prochain projet.</p><p>Allez, on déballe tout ça !</p><h2 id="monolithe-vs-microservices-le-duel-en-bref"><span class="mr-2">Monolithe vs microservices : le duel en bref</span><a href="#monolithe-vs-microservices-le-duel-en-bref" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Dans le coin gauche, l’<strong>application monolithique</strong> : un seul bloc déployable, rassemblant toutes les fonctionnalités (base de données, logique métier, UI) dans une même application. C’est l’architecture « tout-en-un » classique. À droite, l’<strong>architecture microservices</strong> : une constellation de petits services autonomes, chacun focalisé sur une fonctionnalité métier spécifique, qui communiquent entre eux via des APIs réseau. En somme, <strong>monolithe = une application unique</strong>, <strong>microservices = plein d’applications collaborant ensemble</strong>.</p><p><em>🧱 Architecture monolithique – toutes les fonctionnalités (paiement, panier, inventaire, etc.) cohabitent dans une seule application déployée.</em></p><p><em>🧩 Architecture microservices – chaque fonctionnalité métier est un service indépendant (paiement, panier, inventaire…), communiquant via des appels réseau. Un API Gateway (ou une interface unifiée) sert d’entrée pour le client.</em></p><p>Concrètement, dans un monolithe, un module peut appeler directement une fonction d’un autre module <strong>en mémoire</strong>, comme on passe d’une pièce à l’autre dans la même maison. C’est simple et rapide (une bonne vieille fonction appelée directement). En microservices, ces appels deviennent des <strong>requêtes réseau</strong> (HTTP, gRPC, etc.), un peu comme passer des coups de fil entre maisons distinctes : c’est plus lourd et ça peut échouer pour tout un tas de raisons indépendantes du code métier.</p><p><strong>Exemple :</strong> imaginons un module de paiement qui doit vérifier une carte de crédit. En monolithe, un simple appel de méthode suffit :</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copié!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="c1">// Appel interne en monolithe</span>
<span class="kt">bool</span> <span class="n">estPaiementValide</span> <span class="p">=</span> <span class="n">_servicePaiement</span><span class="p">.</span><span class="nf">ValiderCarte</span><span class="p">(</span><span class="n">numeroCarte</span><span class="p">);</span>

<span class="k">if</span> <span class="p">(!</span><span class="n">estPaiementValide</span><span class="p">)</span>
<span class="p">{</span>
   <span class="k">return</span> <span class="s">"Paiement refusé"</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>En microservices, le module paiement serait un service séparé ; il faut alors faire un appel HTTP (ou autre) :</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copié!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="c1">// Appel distant en microservices</span>
<span class="kt">var</span> <span class="n">reponse</span> <span class="p">=</span> <span class="k">await</span> <span class="n">_httpClient</span><span class="p">.</span><span class="nf">GetAsync</span><span class="p">(</span><span class="s">$"http://service-paiement/api/verifierCarte/</span><span class="p">{</span><span class="n">numeroCarte</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>

<span class="c1">// gestion d'erreur...</span>

<span class="kt">bool</span> <span class="n">estPaiementValide</span> <span class="p">=</span> <span class="k">await</span> <span class="n">reponse</span><span class="p">.</span><span class="n">Content</span><span class="p">.</span><span class="n">ReadFromJsonAsync</span><span class="p">&lt;</span><span class="kt">bool</span><span class="p">&gt;();</span>
</pre></table></code></div></div><p>👆 Vous voyez la différence : on échange la <strong>simplicité</strong> d’un appel direct contre la <strong>complexité</strong> (gestion des erreurs réseau, sérialisation JSON, etc.) d’un appel distant. Cet exemple illustre bien le <strong>surcoût</strong> inhérent aux microservices : ce qui était un détail trivial en monolithe (appeler une fonction) devient une mini-aventure technique quand on découpe tout en services indépendants.</p><p>Cela ne veut pas dire que monolithes = bien et microservices = mal (ou vice-versa). Chacun a ses avantages et inconvénients. Un monolithe, c’est <em>simple à développer et à débugger</em> (tout est au même endroit) et <em>déployer</em> se résume à lancer une “seule application”. En revanche, un monolithe peut devenir <strong>lourd à faire évoluer</strong> quand il grossit trop : la moindre modification nécessite de redéployer l’ensemble, et on ne peut pas passer à l’échelle un composant spécifique indépendamment des autres. À l’opposé, les microservices apportent de la <strong>flexibilité</strong> : chaque service est plus petit, modulaire, déployable indépendamment, potentiellement <em>scalable</em> séparément. Mais ils introduisent une tonne de <strong>complexité distribuée</strong> : appels réseau, gestion de la cohérence des données entre services, multiplication des projets, monitoring plus ardu… bref, ce n’est pas la panacée universelle non plus.</p><p>Maintenant que le décor est planté, entrons dans le vif du sujet : <strong>dans quels cas concrets les microservices sont-ils pertinents, et quand risquent-ils de vous causer plus de soucis qu’autre chose ?</strong> Pour le savoir, suivez le guide en <strong>6 étapes</strong>.</p><h2 id="méthodologie-faut-il-partir-sur-une-architecture-microservices"><span class="mr-2">Méthodologie : Faut-il partir sur une architecture microservices ?</span><a href="#méthodologie-faut-il-partir-sur-une-architecture-microservices" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Avant de “découper à la scie mécanique” votre application en microservices, passez en revue les étapes suivantes. Elles forment une <em>checklist</em> pour évaluer si le jeu en vaut la chandelle dans <strong>votre contexte</strong> spécifique.</p><h3 id="étape1-évaluer-la-taille-et-complexité-du-projet"><span class="mr-2">Étape 1 : Évaluer la <strong>taille et complexité</strong> du projet</span><a href="#étape1-évaluer-la-taille-et-complexité-du-projet" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Premier réflexe : prenez du recul et regardez l’ampleur du projet. <strong>Quelle est la taille de votre application et la richesse de son domaine métier ?</strong> S’agit-il d’un petit site web ou d’un outil interne avec trois formulaires, ou bien d’une plateforme tentaculaire à la Netflix/Amazon avec des dizaines de fonctionnalités métiers distinctes ?</p><ul><li><p>Si votre projet est <strong>modeste ou en phase de démarrage</strong>, partir d’emblée sur des microservices serait comme vouloir <em>désosser un mulot avec un scalpel de chirurgien</em>. 🐭⚡ En clair, <strong>c’est overkill</strong>. Il est souvent recommandé de débuter par un monolithe bien structuré, quitte à le faire évoluer plus tard si nécessaire. Martin Fowler note d’ailleurs que <em>presque toutes les success stories de microservices ont commencé par un monolithe qui a grossi avant d’être découpé</em>, tandis que les rares projets démarrés directement en microservices ont souvent accumulé les ennuis. Le monolithe initial permet de valider rapidement que l’application répond à un besoin, sans s’alourdir d’une complexité prématurée (principe YAGNI : <em>You Ain’t Gonna Need It</em>). Il vaut mieux un petit système qui marche qu’une usine à gaz microservicielle pour un produit incertain.</p><li><p>En revanche, si vous anticipez que votre application va devenir <strong>très large, très complexe</strong>, avec de multiples sous-domaines métier clairement identifiables, là un découpage pourra se justifier à terme. Par exemple, une plateforme de commerce électronique internationale a des sous-domaines évidents (catalogue produits, gestion des commandes, facturation, recherche, recommandations, etc.) qui pourraient devenir chacun un service. Mais attention : même dans ce cas, rien ne presse de tout micro-découper dès le jour 1. Il est souvent plus sage de commencer monolithique, <em>puis</em> de refactorer en microservices une fois que les frontières naturelles entre composants se sont clarifiées dans le temps. Un mauvais découpage précoce peut faire plus de mal que de bien.</p></ul><p>En résumé, <strong>taille modeste = monolithe favorisé</strong>, <strong>grande échelle potentielle = microservices envisagés</strong>, mais idéalement <em>après</em> avoir atteint les limites du monolithe. Comme le dit de dicton : <em>“n’optimisez pas prématurément”</em>. Visez la simplicité d’abord, la sophistication ensuite, seulement si nécessaire.</p><h3 id="étape2-considérer-la-taille-de-léquipe-et-lorganisation"><span class="mr-2">Étape 2 : Considérer la <strong>taille de l’équipe</strong> et l’organisation</span><a href="#étape2-considérer-la-taille-de-léquipe-et-lorganisation" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Deuxième facteur clé : <strong>qui va développer et maintenir tout ça ?</strong> La taille et la structure de votre équipe influencent énormément le choix d’architecture :</p><ul><li><p>Si vous êtes <strong>une toute petite équipe (ou un développeur solo)</strong>, lancer 10 microservices serait un peu comme un agriculteur qui court après 10 vaches échappées dans des champs différents. ⚠️ <em>Spoiler</em> : y’en a toujours une qui finit chez le voisin 😅. Vous risquez de vous épuiser rapidement … Un monolithe est bien plus adapté aux petites équipes : tout le monde travaille sur le même code, c’est plus facile à suivre et à tester. N’oublions pas que chaque microservice additionnel, c’est du <em>fardeau opérationnel en plus</em> (pipelines CI/CD multiples, déploiements multiples, versions multiples…). Quand on n’a que 2-3 développeurs, mieux vaut les concentrer sur une base de code unique que de les disperser.</p><li><p>À l’inverse, si vous disposez de <strong>plusieurs équipes dédiées</strong>, avec chacune son périmètre fonctionnel, les microservices peuvent aider à découpler le travail. C’est là qu’intervient la fameuse règle d’Amazon des <em>“two-pizza teams”</em>. Jeff Bezos a instauré que chaque équipe doit être suffisamment petite pour être nourrie avec deux pizzas. En pratique, <strong>chaque équipe chez Amazon est propriétaire d’un service</strong> et peut le faire évoluer à son rythme. Cette organisation en microservices a permis à Amazon de scaler tant au niveau technique qu’humain : des équipes autonomes, livrant indépendamment, sans se marcher sur les pieds. On retrouve une idée similaire chez Uber : quand l’entreprise est passée de quelques dizaines à des centaines de développeurs, le monolithe d’origine est devenu un goulot d’étranglement, car toutes les équipes étaient <em>couplées</em> par ce code unique. Le passage à une multitude de services a permis à chaque groupe d’avancer plus librement, sans attendre que <em>“le monolithe veuille bien déployer”</em>.</p><li><p>En gros, <strong>conformez l’architecture à votre organisation</strong> (c’est la fameuse <a href="https://en.wikipedia.org/wiki/Conway%27s_law">Conway’s Law</a>). Si vous avez déjà des équipes ou des domaines bien séparés, les microservices peuvent refléter ce découpage naturel. Si votre équipe est un bloc unique, imposer des microservices crée artificiellement des frontières… et potentiellement des silos injustifiés.</p></ul><p>Un autre aspect humain : les compétences. Une petite équipe full-stack “classique” sera plus à l’aise à travailler sur un seul projet monolithique. Tandis que dans une grande organisation, on peut avoir des équipes spécialisées (ex: une team pour chaque microservice, avec éventuellement des technos différentes). <strong>Pas d’équipe dédiée = pas de microservice dédié</strong>, c’est un bon réflexe à avoir.</p><p><em>Petite anecdote :</em> Amazon n’est pas dogmatique non plus. Récemment, leur division Prime Video a opéré un mouvement surprise en <strong>abandonnant une architecture microservices/serverless au profit d’un bon gros monolithe</strong>… Résultat : des coûts réduits et de bien meilleures performances pour leur workload! Preuve que même avec des centaines de développeurs, la solution “plein de microservices” n’est pas toujours la plus efficiente – cela dépend du contexte et du problème à résoudre.</p><h3 id="étape3-identifier-les-besoins-de-scalabilité-et-de-performance"><span class="mr-2">Étape 3 : Identifier les <strong>besoins de scalabilité</strong> et de performance</span><a href="#étape3-identifier-les-besoins-de-scalabilité-et-de-performance" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Passons au côté technique : <strong>quelle charge votre application doit-elle encaisser et comment veut-on la faire monter en charge (scaling) ?</strong> Les microservices sont souvent vendus comme <em>LE</em> remède anti-surcharge, mais la réalité est nuancée.</p><ul><li><p>Si votre application doit gérer des <strong>volumes massifs</strong> de trafic ou de données, et surtout <strong>de façon inégale selon les fonctionnalités</strong>, alors une architecture microservices est pertinente. Elle permet de <strong>scaler indépendamment</strong> chaque service selon la demande. Par exemple, imaginons un jeu en ligne où le module “classement des points” est ultra-sollicité, bien plus que le module “profil utilisateur”. En microservices, on pourrait déployer 10 instances du service <code class="language-plaintext highlighter-rouge">Classement</code> pour chaque instance du service <code class="language-plaintext highlighter-rouge">Profil</code>, afin d’absorber la charge là où c’est nécessaire. De grandes entreprises ont adopté ce principe : <strong>Netflix</strong> a scindé sa plateforme en plus de 700 microservices pour gérer chaque partie du système de manière autonome, après avoir souffert des limites d’un monolithe. En 2008, un incident célèbre a vu la base de données centrale de Netflix corrompue, plongeant tout le service dans le noir pendant trois jours. Cette panne a mis en lumière le <em>point faible</em> du monolithe : un seul composant qui flanche peut tout faire tomber. Netflix a alors migré vers AWS et une architecture microservices, éliminant les points uniques de défaillance et permettant de faire évoluer séparément chaque brique (lecture de vidéos, recommandations, facturation, etc.). Depuis, l’infrastructure Netflix repose sur une multitude de petits services robustes, capables de servir des millions d’utilisateurs et de déployer des changements en continu – parfois des milliers de déploiements par jour !</p><li><p>De même, <strong>Amazon</strong> (encore eux) a besoin que certains pans de son site puissent encaisser des pics énormes (pensez au <em>Black Friday</em> sur le panier d’achat ou les paiements). Leur architecture microservices permet de renforcer <em>uniquement</em> les services critiques en pic de charge, sans toucher aux autres. C’est comme pouvoir ajouter des voies sur l’autoroute là où il y a des embouteillages, sans avoir à refaire toutes les routes du pays.</p><li><p><strong>En revanche</strong>, si votre application n’a pas le besoin d’une scalabilité granulaire, un monolithe bien conçu peut suffire largement. Beaucoup d’applications métier “classiques” tournent très bien avec un déploiement monolithique dupliqué sur quelques serveurs en load-balancing pour gérer la charge. Même un gros monolithe peut scaler horizontalement en déployant plusieurs instances identiques derrière un répartiteur de charge. <strong>On sous-estime parfois jusqu’où un monolithe peut aller</strong> : vous pouvez déjà bâtir un commerce qui tourne rondement avec une seule base de données et une appclication web bien optimisée sur un serveur aux ressources généreuses. Si une partie de votre application commence à saturer les ressources, il est tout à fait possible de l’optimiser ou de monter en vertical (plus de CPU, de RAM) avant d’envisager un découpage.</p><li><p>Par ailleurs, <strong>microservices n’égale pas automatiquement meilleures performances</strong>. En fait, <em>chaque appel distant ajoute de la latence</em> et de la charge (sérialisation/désérialisation, routage réseau…). Donc, pour de <em>fortes exigences de performance en temps réel</em>, trop de microservices peuvent nuire. Il faut un certain <strong>seuil de complexité/échelle</strong> pour que les bénéfices surpassent les coûts. L’anecdote d’Amazon Prime Video l’illustre bien : ils avaient découpé un workflow en fonctions serverless (microservices), pensant gagner en scaling, mais ont atteint des limites à seulement 5% de charge prévue. Leur solution a été de <strong>re-fusionner</strong> les composants critiques en un seul service optimisé et bingo, ça a bien mieux tenu la charge. Morale : si vos besoins de scalabilité peuvent être satisfaits par un bon vieux monolithe <strong>optimisé</strong>, inutile d’ajouter de la complexité sans justification concrèt.</p></ul><p>En résumé, posez-vous les questions suivantes : <em>Est-ce que certaines parties du système ont des profils de charge très différents des autres ? Dois-je pouvoir scaler un module sans toucher aux autres ? Ai-je des contraintes de disponibilité très fines qui nécessitent d’isoler les pannes potentielles ?</em> Si oui, orientez-vous vers une segmentation en services. Sinon, un monolithe peut très bien faire le boulot, <strong>plus simplement</strong>.</p><h3 id="étape4-examiner-la-fréquence-de-déploiement-et-lindépendance-des-fonctionnalités"><span class="mr-2">Étape 4 : Examiner la <strong>fréquence de déploiement</strong> et l’indépendance des fonctionnalités</span><a href="#étape4-examiner-la-fréquence-de-déploiement-et-lindépendance-des-fonctionnalités" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Un avantage souvent mis en avant des microservices, c’est de permettre des <strong>déploiements indépendants et fréquents</strong> de chaque composant. Voyons si c’est pertinent pour vous :</p><ul><li><p><strong>Votre équipe déploie-t-elle très souvent de nouvelles fonctionnalités, de manière découplée ?</strong> Par exemple, si le module “Facturation” doit être mis en production 3 fois par semaine, alors que le reste du système bouge peu, l’architecture microservices vous permettrait de déployer le service Facturation seul, sans interrompre ni revalider toute l’application. Idem, s’il y a une équipe dédiée qui ne travaille <em>que</em> sur le moteur de recherche du site, elle pourrait livrer ses évolutions indépendamment des autres. Ce scénario plaide en faveur de microservices, pour gagner en <strong>vitesse de livraison</strong>. Les géants du web en profitent : <strong>Amazon</strong> a des déploiements en continu de microservices tout au long de la journée, sans quoi il leur serait impossible de faire évoluer leur plateforme tentaculaire sans tout casser. Chaque équipe publie son service quand elle est prête, point. Cela a considérablement accéléré l’innovation et le <em>time-to-market</em>.</p><li><p><strong>Dépendances modulaires</strong> : Si vos fonctionnalités sont relativement indépendantes les unes des autres sur le plan métier, les microservices évitent que déployer A implique de retester B, C et D qui n’ont rien à voir. C’est un atout pour la qualité et l’<strong>agilité</strong>. Par exemple, chez Netflix, les équipes peuvent modifier le service de recommandation de films et le déployer, sans devoir geler le service de lecture vidéo ou le service d’abonnement. Dans un monolithe, une petite modification dans le code de recommandations nécessiterait de reconstruire et redéployer <em>tout</em> le monolithe, avec les risques que cela comporte.</p><li><p><strong>À l’inverse</strong>, si vous déployez plutôt <strong>rarement</strong> et que vos releases englobent de toute façon <em>toutes</em> les parties de l’application en même temps (train de livraison coordonné), le bénéfice de microservices diminue. Beaucoup de systèmes internes d’entreprise suivent des cycles de mise en production globales (par ex. une release mensuelle de l’application entière). Le fait d’être en microservices ne changerait pas grand-chose, puisque vous attendriez quand même d’avoir tout packagé pour déployer. Voire pire : cela pourrait <em>compliquer</em> la synchronisation (s’assurer que les 10 services sont tous alignés pour la release, avec les bonnes versions d’API, etc.). Dans ce genre de contexte, un monolithe peut simplifier la livraison.</p><li><p>Posez-vous la question de la <strong>coordination des versions</strong> : si chaque microservice évolue indépendamment, il faut gérer la compatibilité entre eux. C’est jouable (contrats d’API stables, versions rétrocompatibles…), mais c’est du travail de plus. Si votre équipe a déjà du mal à coordonner du versioning au sein d’un monolithe, la multiplication des services ne va pas arranger les choses par magie, au contraire.</p></ul><p>En somme, les microservices prennent tout leur sens si vous visez un modèle <strong>DevOps/CI-CD très poussé</strong>, avec des livraisons continues par composant. Vous pourrez publier plus vite, en isolant les risques. Si ce niveau de fréquence n’est ni nécessaire ni réaliste pour vous, <strong>ne vous infligez pas la complexité</strong> d’une architecture distribuée. Parfois, déployer calmement un bon gros monolithe une fois toutes les deux semaines, ça suffit amplement pour rendre les utilisateurs heureux.</p><h3 id="étape5-vérifier-les-capacités-techniques-devops-monitoring-etc"><span class="mr-2">Étape 5 : Vérifier les <strong>capacités techniques</strong> (DevOps, monitoring, etc.)</span><a href="#étape5-vérifier-les-capacités-techniques-devops-monitoring-etc" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>C’est un aspect souvent sous-estimé : avez-vous l’<strong>infrastructure et les outils</strong> pour supporter une galaxie de microservices ? Et l’expertise qui va avec ?</p><p>Mettre en place des microservices, ce n’est pas juste découper du code en petits morceaux. Il faut aussi tout un écosystème technique pour les faire tourner correctement :</p><ul><li><p><strong>Conteneurs, orchestrateurs</strong> : En général, qui dit microservices dit Docker, Kubernetes, ou autre plateforme orchestrée. Déployer manuellement 20 services sur des VM, c’est ingérable, vous aurez besoin d’automatisation. Votre équipe est-elle familière avec ces technologies ? A-t-elle quelqu’un qui <em>maîtrise Kubernetes</em> (AKS, EKS, peu importe) pour opérer l’infrastructure ? Si ce n’est pas le cas, prévoyez une <em>solide courbe d’apprentissage</em> et du temps en “Recherche et Développement”, sinon vous allez vous retrouver à héberger vos microservices “à la main”, ce qui est aventureux 😅.</p><li><p><strong>Monitoring &amp; logging</strong> : Un monolithe a souvent une seule source de logs, facile à parcourir. Avec 10 microservices, bonjour la chasse aux logs dans 10 endroits différents. Il vous faudra mettre en place une solution de logs centralisés (ELK, Application Insights, etc.) et du <strong>monitoring</strong> distribué. Idem pour le <strong>tracing</strong> des requêtes entre services (systèmes de traçage distribué de type OpenTelemetry). Sans ces outils, vous serez <em>aveugle</em> lorsque quelque chose plantera à 3h du matin dans un enchaînement de 5 services. Il faut donc investir du temps à instrumenter chaque service, à se doter de dashboards, d’alertes… Est-ce que votre équipe a les compétences pour ça ? Et le temps ? Si non, c’est un signal fort que le passage aux microservices pourrait être prématuré.</p><li><p><strong>Robustesse et tolérance aux pannes</strong> : Dans un système distribué, <strong>tout</strong> peut arriver : un service peut tomber, un appel réseau peut échouer ou expirer, etc. Vos développeurs doivent adopter des pratiques de code résilient (patterns de retry, circuit-breaker – avec Polly en .NET par exemple). Ils doivent penser <em>“et si le service en face ne répond pas ?”</em> en permanence. C’est un état d’esprit et une expertise différente de la programmation monolithique où <em>un NullReferenceException est souvent le pire scénario</em>. Ici on parle de gérer des <em>time out</em>, des files d’attente, des messages perdus… <strong>Si l’équipe n’a jamais fait ça, il y aura des ratés.</strong> Ce n’est pas insurmontable, mais c’est un coût de formation et d’expérience à anticiper. Netflix, par exemple, a dû inventer l’outil <a href="https://fr.wikipedia.org/wiki/Chaos_Monkey">Chaos Monkey</a> qui éteint aléatoirement des services en production pour s’assurer que le système global survit aux pannes individuelles – c’est dire le niveau de maturité à atteindre pour dompter un tel écosystème !</p><li><p><strong>Complexité de debug</strong> : Préparez-vous à ce que votre débogage “F5 dans Visual Studio” se transforme en parties de cache-cache dans une ferme de services. Un développeur racontait, un brin désabusé, comment ses microservices passaient leur temps à <em>“échanger entre eux sur le réseau”</em>, et que dès qu’un service “faisait un caprice”, bonne chance pour identifier la source du problème. Ce qui était un simple appel de fonction devient une succession de requêtes asynchrones à travers le réseau, avec des <strong>erreurs possiblement silencieuses</strong> en chemin. Debugger ça sans outillage, c’est comme chercher une aiguille dans un champ de foin… la nuit… avec une lampe frontale déchargée. 🔦😅 Autrement dit, <em>assurez-vous d’avoir les outils et les compétences de débogage distribué</em>, sinon vos nuits pourraient devenir très courtes.</p></ul><p>En résumé, une architecture microservices n’est viable que si <strong>votre stack technique et votre équipe sont prêtes</strong> à en assumer les à-côtés. Posez-vous sincèrement la question : <em>Mon équipe est-elle suffisamment DevOps ? Avons-nous les ressources pour mettre en place : CI/CD, conteneurs, monitoring, tests end-to-end sur un système distribué ?</em> Si la réponse est “nahhhhhh”, il vaut peut-être mieux consolider vos pratiques sur un monolithe d’abord. Rien n’empêche d’adopter certaines bonnes pratiques devops (intégration continue, conteneurisation) sur le monolithe en prévision, mais ne pas se jeter dans le grand bain “multi-services” avant de savoir nager.</p><h3 id="étape6-peser-les-coûts-et-la-valeur-ajoutée"><span class="mr-2">Étape 6 : Peser les <strong>coûts</strong> et la valeur ajoutée</span><a href="#étape6-peser-les-coûts-et-la-valeur-ajoutée" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Dernier point, et non des moindres : <strong>le coût et le retour sur investissement</strong>. Les microservices ont un coût <strong>technique</strong> <em>et</em> <strong>organisationnel</strong>. Il faut s’assurer que les bénéfices espérés valent cette dépense.</p><ul><li><p><strong>Coût de développement</strong> : Diviser une application en 10 services, c’est potentiellement <em>10 dépôts git, 10 pipelines de build, 10 projets à tester et maintenir</em>. La productivité peut en prendre un coup. Un architecte rapportait que dans son entreprise, développer une fonctionnalité équivalente prenait <em>8 fois plus de temps avec une architecture microservices qu’avec un monolithe</em>, et nécessitait deux fois plus de développeurs! Pourquoi ? Parce qu’il faut définir des contrats d’API, gérer les versions, écrire du code de communication, synchroniser les déploiements… tout cela, un monolithe nous l’épargne en grande partie. Alors oui, <em>8x</em> c’est un cas extrême, mais ne soyez pas surpris si au début vos livraisons ralentissent en passant aux microservices. C’est un <strong>investissement long terme</strong> : on accepte de ralentir maintenant en espérant aller plus vite plus tard, quand l’application sera très grosse et que les équipes paralléliseront vraiment le travail. Pour un petit projet, cet investissement ne sera <strong>jamais rentabilisé</strong>.</p><li><p><strong>Coût opérationnel</strong> : Plus de services = plus de ressources serveurs (mémoire, CPU, instances multiples). Si chaque microservice a sa base de données séparée (idéalement oui), ça fait autant de serveurs de BD à gérer/payer/licencier. Sur le cloud, multiplier les conteneurs ou fonctions serverless peut faire grimper la facture à la fin du mois. Là où un monolithe tournait sur 2 VM à 80% CPU, vos 10 microservices tournent peut-être sur 20 conteneurs globalement sous-utilisés… mais facturés quand même. <strong>Avez-vous le budget</strong> pour ce overhead ? Parfois, le jeu en vaut la chandelle (si vos microservices attirent 100× plus d’utilisateurs, le coût supplémentaire est justifié). Parfois non : on a vu des startups flamber leur budget infonuagique en orchestrant une flotte de microservices qui auraient pu tenir dans un seul petit serveur.</p><li><p><strong>Complexité = risques</strong> : La complexité additionnelle peut engendrer plus de <strong>pannes</strong> ou de bugs subtils. Chaque service ajouté est un point potentiel de défaillance en plus (une panne réseau, un plantage de service, ou un échec de synchronisation des données…). Et quand ça plante, le temps passé à résoudre (MTTR) risque d’être plus long qu’avec un monolithe. Ce coût-là est dur à chiffrer, mais bien réel (heures supplémentaires, interruptions de service, image de marque, etc.). Pour le minimiser, il faut investir dans la fiabilité (tests, monitoring, redondance) ce qui renchérit encore le coût technique initial.</p><li><p><strong>ROI métier</strong> : demandez-vous <em>quels problèmes concrets les microservices vont résoudre pour votre business</em>. Si la réponse est du genre <em>“c’est à la mode”</em> ou <em>“on le fait pour faire propre”</em>, ce n’est pas un vrai ROI 😅. En revanche, si vous identifiez clairement que <em>“ça nous permettra de déployer plus vite des features pour nos clients”</em> ou <em>“ça éliminera les indisponibilités totales en cas de bug”</em> ou <em>“on pourra tenir la charge pendant les soldes sans planter”</em>, là on parle. <strong>Quantifiez</strong> autant que possible : par exemple, <em>passer de 1 déploiement par mois à 10 déploiements par jour</em> grâce aux microservices a une valeur énorme si votre marché exige cette réactivité. Mais si votre application interne n’a pas besoin d’évoluer si fréquemment, ce gain est inutile.</p></ul><p>En somme, faites le <strong>bilan coût/bénéfice</strong> le plus objectivement possible. Les microservices apportent des bénéfices indéniables (échelle, résilience, agilité) mais au prix d’une complexité qui, dans bien des cas, n’est tout simplement pas justifiée. Il n’y a pas de honte à rester sur un bon monolithe efficace si c’est la solution la plus rentable pour vous ! D’ailleurs, on voit un certain <em>retour de balancier</em> dans l’industrie : après l’engouement débridé pour “tout microserviciser”, certaines entreprises reviennent à des architectures plus simples pour réduire les coûts et la complexité, quitte à sacrifier un peu de <em>hype</em>. Le tout, c’est d’y gagner au final.</p><h2 id="conclusion-trouver-le-juste-milieu-et-dormir-sur-ses-deux-oreilles"><span class="mr-2">Conclusion : Trouver le juste milieu (et dormir sur ses deux oreilles)</span><a href="#conclusion-trouver-le-juste-milieu-et-dormir-sur-ses-deux-oreilles" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>La grande leçon à retenir ? <strong>“Microservice” n’est pas synonyme de “mieux” par défaut.</strong> C’est un outil architectural parmi d’autres, avec ses cas d’usage idéaux et ses pièges. De même, le <strong>monolithe</strong> n’est pas un dinosaure ringard bon pour le musée : il demeure tout à fait pertinent dans bon nombre de situations.</p><p>Pour récapituler avec un petit guide <strong>quand ou ne pas utiliser une architecture microservices</strong> :</p><ul><li><p>✅ <strong>Oui aux microservices</strong> dans des contextes tels que :</p><ul><li>Une application très complexe, couvrant plusieurs domaines fonctionnels clairement séparables, et/ou une <strong>grande organisation</strong> avec des équipes dédiées par domaine. Ex: Un site web de type Amazon avec panier, paiement, recommandations, chacun évoluant séparément par des équipes différentes.<li>Des <strong>besoins de scalabilité fine</strong> : certaines parties du système doivent pouvoir monter en charge indépendamment (ex: moteur de recherche à scaler sans scaler toute l’application).<li>Une nécessité de <strong>déploiements fréquents et indépendants</strong> de certaines fonctionnalités, pour livrer plus vite aux utilisateurs.<li>Une exigence de <strong>haute résilience</strong> : on veut qu’une panne d’un composant n’impacte pas tout le reste (architecture tolérante aux pannes).<li>Un environnement technique mature en DevOps, avec <strong>outils en place</strong> (CI/CD, container orchestration, monitoring distribué) et une équipe à l’aise avec ces concepts.<li>En somme, quand le <strong>gain attendu (autonomie, vitesse, robustesse, échelle)</strong> dépasse le <strong>coût en complexité</strong>.</ul><li><p>🚫 <strong>Non (ou pas encore) aux microservices</strong> dans les cas suivants :</p><ul><li><strong>Projet trop petit ou jeune</strong> : si vous pouvez développer l’ensemble de votre application en quelques mois avec 2-3 devs, un microservice ne va que ralentir la livraison. Partez monolithique, vous verrez plus tard si ça devient trop gros.<li><strong>Équipe réduite/inexpérimentée en devops</strong> : pas d’expertise conteneurs/Cloud, pas d’équipe dédiée à l’infrastructure… Mieux vaut ne pas se compliquer la vie tout de suite. Comme on dit, <em>“il ne faut pas plusieurs chefs pour faire bouillir la marmite”</em> – une petite brigade de développeurs fonctionne mieux autour d’un seul chaudron (le monolithe).<li><strong>Domaines très interconnectés</strong> : si vos fonctionnalités sont toutes fortement liées, les séparer en services entraînera beaucoup d’appels réseau entre eux (le syndrome du <a href="https://medium.com/@dmosyan/doing-microservices-completely-wrong-distributed-monoliths-cede5c44d8a7">distributed monolith</a>). Vous n’y gagnerez rien, si ce n’est d’échanger un couplage interne contre un couplage réseau tout aussi contraignant.<li><strong>Contraintes de performance temps réel strictes</strong> : une application <em>low-latency</em> (ex : transactions boursières automatisées ultra-rapides, calcul scientifique synchronisé) peut difficilement tolérer la latence ajoutée des microservices. Un monolithe optimisé en C# (ou en Rust natif 😉) sera plus efficace.<li><strong>Budget serré</strong> : si chaque dollar compte, sachez que la complexité microservices peut impliquer plus de dépenses (machines, temps de développeur, consultants spécialisés…). Assurez-vous que votre responsable budgétaire soit d’accord avant de multiplier les déploiements comme des lapins.<li>En bref, si <strong>les bénéfices ne sont pas clairs et immédiats</strong>, ou si votre contexte n’est pas prêt, il est parfaitement raisonnable de <strong>rester sur un monolithe</strong> ou d’adopter une approche intermédiaire (par ex. un monolithe modulaire, bien découpé en couches ou en <em>modules internes</em> – parfois appelé “modulithe” ou “monolithique modulable”). On peut très bien concevoir son code <em>comme</em> des microservices (avec de bonnes séparations logiques), tout en déployant une seule application. C’est souvent un excellent compromis pour démarrer.</ul></ul><p>En guise de clôture, rappelons-nous que <strong>l’architecture sert les objectifs du logiciel, pas l’inverse</strong>. Ne choisissez pas microservices ou monolithe pour suivre la mode, mais en fonction de ce qui apporte le plus de valeur à <em>votre</em> produit et <em>vos</em> utilisateurs. La prochaine fois qu’on vous dira <em>“Il faut absolument des microservices, c’est plus <strong>scalable</strong> et <strong>hype</strong>“</em>, vous pourrez rétorquer : <em>“Peut-être, mais encore faut-il que ce soit justifié – parlons concret ! “</em>.</p><p>Au fond, monolithes et microservices cohabitent dans la grande boîte à outils de l’architecte. Le vrai talent est de sortir le bon outil au bon moment. Ce n’est pas parce qu’on a vu des fermes industrielles avec des robots à traire qu’il faut transformer sa petite étable en usine à microservices. Et à l’inverse, pour bâtir une cathédrale logicielle fréquentée par des millions de personnes, un seul bloc monolithique pourrait devenir un carcan rigide – un échafaudage microservices offre alors plus de souplesse.</p><p><strong>En définitive, soyez pragmatique</strong> : commencez simple, ayez conscience des <em>trade-offs</em>, et évoluez l’architecture quand les <strong>signaux</strong> le demandent (goulots d’étranglement, blocage organisationnel, etc.). Si vous suivez les étapes et conseils ci-dessus, vous devriez éviter aussi bien le <em>“microservice washing”</em> inconsidéré que le <em>“monolith forever par inertie”</em>.</p><p>Et surtout, n’oubliez pas de savourer le voyage : que vous construisiez un majestueux monolithe ou une myriade de microservices, l’essentiel est d’<strong>apprendre en s’amusant</strong>. Après tout, on écrit du code pour résoudre des problèmes <em>et</em> pour le plaisir intellectuel. Alors faites les bons choix au bon moment, et laissez l’architecture servir votre projet, pas l’inverse.</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/architecture/'>architecture</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> Cet article est sous licence <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> par l'auteur.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Partager</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Faut-il%20vraiment%20adopter%20une%20architecture%20microservices%20-%20CodeWithFrenchy&url=https%3A%2F%2Fcodewithfrenchy.github.io%2F%2Fposts%2Fquand-utiliser-architecture-microservices%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.linkedin.com/sharing/share-offsite/?url=https%3A%2F%2Fcodewithfrenchy.github.io%2F%2Fposts%2Fquand-utiliser-architecture-microservices%2F" data-toggle="tooltip" data-placement="top" title="Linkedin" target="_blank" rel="noopener" aria-label="Linkedin"> <i class="fa-fw fab fa-linkedin"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Faut-il%20vraiment%20adopter%20une%20architecture%20microservices%20-%20CodeWithFrenchy&u=https%3A%2F%2Fcodewithfrenchy.github.io%2F%2Fposts%2Fquand-utiliser-architecture-microservices%2F" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copier le lien" data-title-succeed="Lien copié avec succès!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Récemment mis à jour</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/performances-jsonserializeroptions-singleton/">Amélioration des performances en utilisant JsonSerializerOptions en singleton</a><li><a href="/posts/source-generator-dotnet/">Les Générateurs de source</a><li><a href="/posts/guid-versus-id/">GUID vs ID auto-incrémenté - dilemme et solutions en environnement .NET distribué</a><li><a href="/posts/introduction-k6/">Introduction à K6</a><li><a href="/posts/redis-change-licence/">Redis change de licence ! Quelles répercussions pour les développeurs et les entreprises ?</a></ul></div><div id="access-tags"><div class="panel-heading">Tags tendance</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/dotnet/">dotnet</a> <a class="post-tag" href="/tags/conference/">conference</a> <a class="post-tag" href="/tags/essais/">essais</a> <a class="post-tag" href="/tags/source-generator/">source-generator</a> <a class="post-tag" href="/tags/aspnet-core/">aspnet-core</a> <a class="post-tag" href="/tags/fluentassertions/">fluentassertions</a> <a class="post-tag" href="/tags/fluentvalidation/">fluentvalidation</a> <a class="post-tag" href="/tags/k6/">k6</a> <a class="post-tag" href="/tags/mapperly/">mapperly</a> <a class="post-tag" href="/tags/testcontainers/">testcontainers</a></div></div></div><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">Contenu</div><nav id="toc"></nav></div><script src="https://cdn.jsdelivr.net/npm/tocbot@4.20.1/dist/tocbot.min.js"></script></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4 mt-5"><div id="related-posts" class="mb-2 mb-sm-4"><h3 class="pt-2 mb-4 ml-1" data-toc-skip>Autres lectures</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/vertical-slice-architecture/"><div class="card-body"> <em class="small" data-ts="1751241600" data-df="DD/MM/YYYY" > 29/06/2025 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Architecture Vertical Slice dans l’écosystème .NET</h3><div class="text-muted small"><p> L’architecture Vertical Slice (ou architecture en tranches verticales) est une approche de conception logicielle qui consiste à organiser le code par fonctionnalités verticales plutôt que par couch...</p></div></div></a></div><div class="card"> <a href="/posts/utilisation-design-patterns/"><div class="card-body"> <em class="small" data-ts="1758549600" data-df="DD/MM/YYYY" > 22/09/2025 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Les design patterns - les bons Legos pour vos applications .NET</h3><div class="text-muted small"><p> Introduction : Ne réinventez pas la roue, assemblez les Legos En conception logicielle, un design pattern (ou patron de conception) est une solution éprouvée à un problème de conception récurrent....</p></div></div></a></div><div class="card"> <a href="/posts/concevoir-maintenir-application-performante-dotnet/"><div class="card-body"> <em class="small" data-ts="1761001200" data-df="DD/MM/YYYY" > 20/10/2025 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Concevoir et maintenir des applications microservices performantes en .NET</h3><div class="text-muted small"><p> La performance logicielle ne doit pas être une réflexion après coup : elle se conçoit dès le départ et se cultive tout au long de la vie du système. Dans cet article, nous explorons comment s’outil...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/vertical-slice-architecture/" class="btn btn-outline-primary" prompt="Plus ancien"><p>Architecture Vertical Slice dans l’écosystème .NET</p></a> <a href="/posts/utilisation-design-patterns/" class="btn btn-outline-primary" prompt="Plus récent"><p>Les design patterns - les bons Legos pour vos applications .NET</p></a></div></div></div></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Tags tendance</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/dotnet/">dotnet</a> <a class="post-tag" href="/tags/conference/">conference</a> <a class="post-tag" href="/tags/essais/">essais</a> <a class="post-tag" href="/tags/source-generator/">source-generator</a> <a class="post-tag" href="/tags/aspnet-core/">aspnet-core</a> <a class="post-tag" href="/tags/fluentassertions/">fluentassertions</a> <a class="post-tag" href="/tags/fluentvalidation/">fluentvalidation</a> <a class="post-tag" href="/tags/k6/">k6</a> <a class="post-tag" href="/tags/mapperly/">mapperly</a> <a class="post-tag" href="/tags/testcontainers/">testcontainers</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><footer><div class="container pl-lg-4 pr-lg-4"><div class="d-flex justify-content-between align-items-center text-muted ml-md-3 mr-md-3"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://twitter.com/alexis35115">Alexis Garon-Michaud</a>. <span data-toggle="tooltip" data-placement="top" title="Sauf mention contraire, les articles de ce site sont publiés sous licence sous la licence Creative Commons Attribution 4.0 International (CC BY 4.0) par l'auteur.">Certains droits réservés.</span></p></div><div class="footer-right"><p class="mb-0">Propulsé par <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> avec le thème <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a></p></div></div></div></footer><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oups! Aucun résultat trouvé.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lazysizes@5.3.2/lazysizes.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/fr.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/unregister.js"></script>
