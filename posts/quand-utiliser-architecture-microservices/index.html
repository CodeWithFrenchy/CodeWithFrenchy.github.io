<!DOCTYPE html><html lang="fr-FR" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="theme-color" media="(prefers-color-scheme: light)" content="#f7f7f7"><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1e"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="viewport" content="width=device-width, user-scalable=no initial-scale=1, shrink-to-fit=no, viewport-fit=cover" ><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="Faut-il vraiment adopter une architecture microservices" /><meta property="og:locale" content="fr_FR" /><meta name="description" content="PrÃ©ambule" /><meta property="og:description" content="PrÃ©ambule" /><link rel="canonical" href="https://codewithfrenchy.github.io//posts/quand-utiliser-architecture-microservices/" /><meta property="og:url" content="https://codewithfrenchy.github.io//posts/quand-utiliser-architecture-microservices/" /><meta property="og:site_name" content="CodeWithFrenchy" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2025-09-08T20:00:00-04:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Faut-il vraiment adopter une architecture microservices" /><meta name="twitter:site" content="@alexis35115" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2025-09-08T20:00:00-04:00","datePublished":"2025-09-08T20:00:00-04:00","description":"PrÃ©ambule","headline":"Faut-il vraiment adopter une architecture microservices","mainEntityOfPage":{"@type":"WebPage","@id":"https://codewithfrenchy.github.io//posts/quand-utiliser-architecture-microservices/"},"url":"https://codewithfrenchy.github.io//posts/quand-utiliser-architecture-microservices/"}</script><title>Faut-il vraiment adopter une architecture microservices | CodeWithFrenchy</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="CodeWithFrenchy"><meta name="application-name" content="CodeWithFrenchy"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tocbot@4.20.1/dist/tocbot.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener('change', () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.notify(); } /* flipMode() */ } /* ModeToggle */ const modeToggle = new ModeToggle(); </script><body data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" class="mx-auto"> <img src="https://avatars.githubusercontent.com/u/53872142?s=400&u=53187283fe05254234a3890e2b44134f96e3a833&v=4" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title"> <a href="/">CodeWithFrenchy</a></div><div class="site-subtitle font-italic">Architecte logiciel, audacieux et fermier</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>ACCUEIL</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATÃ‰GORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>Ã€ PROPOS DE</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/alexis35115" aria-label="github" target="_blank" rel="noopener noreferrer"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/alexis35115" aria-label="twitter" target="_blank" rel="noopener noreferrer"> <i class="fab fa-twitter"></i> </a> <a href="https://www.linkedin.com/in/alexis-garon-michaud-a59643219/" aria-label="linkedin" target="_blank" rel="noopener noreferrer"> <i class="fab fa-linkedin"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <span id="breadcrumb"> <span> <a href="/"> Accueil </a> </span> <span>Faut-il vraiment adopter une architecture microservices</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Recherche..."> </span> <span id="search-cancel" >Annuler</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>Faut-il vraiment adopter une architecture microservices</h1><div class="post-meta text-muted"> <span> PostÃ© <em class="" data-ts="1757376000" data-df="DD/MM/YYYY" data-toggle="tooltip" data-placement="bottom"> 08/09/2025 </em> </span><div class="d-flex justify-content-between"> <span> Par <em> <a href="https://twitter.com/alexis35115">Alexis Garon-Michaud</a> </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="4877 mots"> <em>27 min</em> Ã  lire</span></div></div></div><div class="post-content"><h2 id="prÃ©ambule"><span class="mr-2">PrÃ©ambule</span><a href="#prÃ©ambule" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><blockquote><p><em>â€œOn part en microservices ou on reste monolithique ?â€</em></p></blockquote><p>Câ€™est une des questions les plus posÃ©es et les moins bien tranchÃ©es du monde logiciel. Une question qui revient <strong>Ã  chaque projet un peu dâ€™envergure</strong>, et qui dÃ©clenche systÃ©matiquement les mÃªmes dÃ©bats passionnÃ©s entre collÃ¨gues, souvent avec des effets secondaires comme la hausse du dÃ©bit de voix et des soupirs lourds de sens.</p><p>Certains brandissent lâ€™argument de la scalabilitÃ©, dâ€™autres invoquent le Graal du dÃ©ploiement indÃ©pendant. Puis quelquâ€™un Ã©voque Netflix ou Amazon, et Ã§a y est, tout le monde commence Ã  vouloir des centaines de services, un orchestrateur et une armÃ©e de pipelines CI/CD.</p><p>Mais en mÃªme tempsâ€¦ on a tous vu (ou vÃ©cu) des projets oÃ¹ lâ€™adoption des microservices a amenÃ© plus de douleurs que de solutions. ComplexitÃ© opÃ©rationnelle, effet spaghetti distribuÃ©, Ã©quipe dÃ©passÃ©e par les appels rÃ©seau qui se perdent dans la brume. Bref, <strong>la promesse des microservices peut vite se transformer en cauchemarâ€¦ si on sâ€™est trompÃ© de combat</strong>.</p><p>Alors voilÃ  : aujourdâ€™hui, on prend le temps de <strong>vraiment rÃ©pondre</strong> Ã  cette question. Sans dogme. Sans <em>buzzword</em>. En regardant froidement (mais gentiment ğŸ˜„) ce que Ã§a implique <strong>de faire â€” ou pas â€” du microservice</strong> dans un projet .NET Core. Lâ€™objectif ? Te donner une <strong>mÃ©thodologie claire</strong>, des <strong>exemples concrets</strong>, et surtout de quoi <strong>prendre une vraie bonne dÃ©cision</strong> pour ton prochain projet.</p><p>Allez, on dÃ©balle tout Ã§a !</p><h2 id="monolithe-vs-microservices-le-duel-en-bref"><span class="mr-2">Monolithe vs microservicesÂ : le duel en bref</span><a href="#monolithe-vs-microservices-le-duel-en-bref" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Dans le coin gauche, lâ€™<strong>application monolithique</strong> : un seul bloc dÃ©ployable, rassemblant toutes les fonctionnalitÃ©s (base de donnÃ©es, logique mÃ©tier, UI) dans une mÃªme application. Câ€™est lâ€™architecture Â«Â tout-en-unÂ Â» classique. Ã€ droite, lâ€™<strong>architecture microservices</strong>Â : une constellation de petits services autonomes, chacun focalisÃ© sur une fonctionnalitÃ© mÃ©tier spÃ©cifique, qui communiquent entre eux via des APIs rÃ©seau. En somme, <strong>monolithe = une application unique</strong>, <strong>microservices = plein dâ€™applications collaborant ensemble</strong>.</p><p><em>ğŸ§± Architecture monolithique â€“ toutes les fonctionnalitÃ©s (paiement, panier, inventaire, etc.) cohabitent dans une seule application dÃ©ployÃ©e.</em></p><p><em>ğŸ§© Architecture microservices â€“ chaque fonctionnalitÃ© mÃ©tier est un service indÃ©pendant (paiement, panier, inventaireâ€¦), communiquant via des appels rÃ©seau. Un API Gateway (ou une interface unifiÃ©e) sert dâ€™entrÃ©e pour le client.</em></p><p>ConcrÃ¨tement, dans un monolithe, un module peut appeler directement une fonction dâ€™un autre module <strong>en mÃ©moire</strong>, comme on passe dâ€™une piÃ¨ce Ã  lâ€™autre dans la mÃªme maison. Câ€™est simple et rapide (une bonne vieille fonction appelÃ©e directement). En microservices, ces appels deviennent des <strong>requÃªtes rÃ©seau</strong> (HTTP, gRPC, etc.), un peu comme passer des coups de fil entre maisons distinctesÂ : câ€™est plus lourd et Ã§a peut Ã©chouer pour tout un tas de raisons indÃ©pendantes du code mÃ©tier.</p><p><strong>ExempleÂ :</strong> imaginons un module de paiement qui doit vÃ©rifier une carte de crÃ©dit. En monolithe, un simple appel de mÃ©thode suffitÂ :</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="CopiÃ©!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="c1">// Appel interne en monolithe</span>
<span class="kt">bool</span> <span class="n">estPaiementValide</span> <span class="p">=</span> <span class="n">_servicePaiement</span><span class="p">.</span><span class="nf">ValiderCarte</span><span class="p">(</span><span class="n">numeroCarte</span><span class="p">);</span>

<span class="k">if</span> <span class="p">(!</span><span class="n">estPaiementValide</span><span class="p">)</span>
<span class="p">{</span>
   <span class="k">return</span> <span class="s">"Paiement refusÃ©"</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>En microservices, le module paiement serait un service sÃ©parÃ©Â ; il faut alors faire un appel HTTP (ou autre)Â :</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="CopiÃ©!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="c1">// Appel distant en microservices</span>
<span class="kt">var</span> <span class="n">reponse</span> <span class="p">=</span> <span class="k">await</span> <span class="n">_httpClient</span><span class="p">.</span><span class="nf">GetAsync</span><span class="p">(</span><span class="s">$"http://service-paiement/api/verifierCarte/</span><span class="p">{</span><span class="n">numeroCarte</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>

<span class="c1">// gestion d'erreur...</span>

<span class="kt">bool</span> <span class="n">estPaiementValide</span> <span class="p">=</span> <span class="k">await</span> <span class="n">reponse</span><span class="p">.</span><span class="n">Content</span><span class="p">.</span><span class="n">ReadFromJsonAsync</span><span class="p">&lt;</span><span class="kt">bool</span><span class="p">&gt;();</span>
</pre></table></code></div></div><p>ğŸ‘† Vous voyez la diffÃ©renceÂ : on Ã©change la <strong>simplicitÃ©</strong> dâ€™un appel direct contre la <strong>complexitÃ©</strong> (gestion des erreurs rÃ©seau, sÃ©rialisation JSON, etc.) dâ€™un appel distant. Cet exemple illustre bien le <strong>surcoÃ»t</strong> inhÃ©rent aux microservices : ce qui Ã©tait un dÃ©tail trivial en monolithe (appeler une fonction) devient une mini-aventure technique quand on dÃ©coupe tout en services indÃ©pendants.</p><p>Cela ne veut pas dire que monolithes = bien et microservices = mal (ou vice-versa). Chacun a ses avantages et inconvÃ©nients. Un monolithe, câ€™est <em>simple Ã  dÃ©velopper et Ã  dÃ©bugger</em> (tout est au mÃªme endroit) et <em>dÃ©ployer</em> se rÃ©sume Ã  lancer une â€œseule applicationâ€. En revanche, un monolithe peut devenir <strong>lourd Ã  faire Ã©voluer</strong> quand il grossit tropÂ : la moindre modification nÃ©cessite de redÃ©ployer lâ€™ensemble, et on ne peut pas passer Ã  lâ€™Ã©chelle un composant spÃ©cifique indÃ©pendamment des autres. Ã€ lâ€™opposÃ©, les microservices apportent de la <strong>flexibilitÃ©</strong>Â : chaque service est plus petit, modulaire, dÃ©ployable indÃ©pendamment, potentiellement <em>scalable</em> sÃ©parÃ©ment. Mais ils introduisent une tonne de <strong>complexitÃ© distribuÃ©e</strong> : appels rÃ©seau, gestion de la cohÃ©rence des donnÃ©es entre services, multiplication des projets, monitoring plus arduâ€¦ bref, ce nâ€™est pas la panacÃ©e universelle non plus.</p><p>Maintenant que le dÃ©cor est plantÃ©, entrons dans le vif du sujetÂ : <strong>dans quels cas concrets les microservices sont-ils pertinents, et quand risquent-ils de vous causer plus de soucis quâ€™autre choseÂ ?</strong> Pour le savoir, suivez le guide en <strong>6 Ã©tapes</strong>.</p><h2 id="mÃ©thodologie-faut-il-partir-sur-une-architecture-microservices"><span class="mr-2">MÃ©thodologieÂ : Faut-il partir sur une architecture microservicesÂ ?</span><a href="#mÃ©thodologie-faut-il-partir-sur-une-architecture-microservices" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Avant de â€œdÃ©couper Ã  la scie mÃ©caniqueâ€ votre application en microservices, passez en revue les Ã©tapes suivantes. Elles forment une <em>checklist</em> pour Ã©valuer si le jeu en vaut la chandelle dans <strong>votre contexte</strong> spÃ©cifique.</p><h3 id="Ã©tape1-Ã©valuer-la-taille-et-complexitÃ©-du-projet"><span class="mr-2">Ã‰tapeÂ 1Â : Ã‰valuer la <strong>taille et complexitÃ©</strong> du projet</span><a href="#Ã©tape1-Ã©valuer-la-taille-et-complexitÃ©-du-projet" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Premier rÃ©flexe : prenez du recul et regardez lâ€™ampleur du projet. <strong>Quelle est la taille de votre application et la richesse de son domaine mÃ©tierÂ ?</strong> Sâ€™agit-il dâ€™un petit site web ou dâ€™un outil interne avec trois formulaires, ou bien dâ€™une plateforme tentaculaire Ã  la Netflix/Amazon avec des dizaines de fonctionnalitÃ©s mÃ©tiers distinctesÂ ?</p><ul><li><p>Si votre projet est <strong>modeste ou en phase de dÃ©marrage</strong>, partir dâ€™emblÃ©e sur des microservices serait comme vouloir <em>dÃ©sosser un mulot avec un scalpel de chirurgien</em>. ğŸ­âš¡ En clair, <strong>câ€™est overkill</strong>. Il est souvent recommandÃ© de dÃ©buter par un monolithe bien structurÃ©, quitte Ã  le faire Ã©voluer plus tard si nÃ©cessaire. Martin Fowler note dâ€™ailleurs que <em>presque toutes les success stories de microservices ont commencÃ© par un monolithe qui a grossi avant dâ€™Ãªtre dÃ©coupÃ©</em>, tandis que les rares projets dÃ©marrÃ©s directement en microservices ont souvent accumulÃ© les ennuis. Le monolithe initial permet de valider rapidement que lâ€™application rÃ©pond Ã  un besoin, sans sâ€™alourdir dâ€™une complexitÃ© prÃ©maturÃ©e (principe YAGNI : <em>You Ainâ€™t Gonna Need It</em>). Il vaut mieux un petit systÃ¨me qui marche quâ€™une usine Ã  gaz microservicielle pour un produit incertain.</p><li><p>En revanche, si vous anticipez que votre application va devenir <strong>trÃ¨s large, trÃ¨s complexe</strong>, avec de multiples sous-domaines mÃ©tier clairement identifiables, lÃ  un dÃ©coupage pourra se justifier Ã  terme. Par exemple, une plateforme de commerce Ã©lectronique internationale a des sous-domaines Ã©vidents (catalogue produits, gestion des commandes, facturation, recherche, recommandations, etc.) qui pourraient devenir chacun un service. Mais attention : mÃªme dans ce cas, rien ne presse de tout micro-dÃ©couper dÃ¨s le jour 1. Il est souvent plus sage de commencer monolithique, <em>puis</em> de refactorer en microservices une fois que les frontiÃ¨res naturelles entre composants se sont clarifiÃ©es dans le temps. Un mauvais dÃ©coupage prÃ©coce peut faire plus de mal que de bien.</p></ul><p>En rÃ©sumÃ©, <strong>taille modeste = monolithe favorisÃ©</strong>, <strong>grande Ã©chelle potentielle = microservices envisagÃ©s</strong>, mais idÃ©alement <em>aprÃ¨s</em> avoir atteint les limites du monolithe. Comme le dit de dicton : <em>â€œnâ€™optimisez pas prÃ©maturÃ©mentâ€</em>. Visez la simplicitÃ© dâ€™abord, la sophistication ensuite, seulement si nÃ©cessaire.</p><h3 id="Ã©tape2-considÃ©rer-la-taille-de-lÃ©quipe-et-lorganisation"><span class="mr-2">Ã‰tapeÂ 2Â : ConsidÃ©rer la <strong>taille de lâ€™Ã©quipe</strong> et lâ€™organisation</span><a href="#Ã©tape2-considÃ©rer-la-taille-de-lÃ©quipe-et-lorganisation" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>DeuxiÃ¨me facteur clÃ© : <strong>qui va dÃ©velopper et maintenir tout Ã§a ?</strong> La taille et la structure de votre Ã©quipe influencent Ã©normÃ©ment le choix dâ€™architecture :</p><ul><li><p>Si vous Ãªtes <strong>une toute petite Ã©quipe (ou un dÃ©veloppeur solo)</strong>, lancer 10 microservices serait un peu comme un agriculteur qui court aprÃ¨s 10 vaches Ã©chappÃ©es dans des champs diffÃ©rents. âš ï¸ <em>Spoiler</em> : yâ€™en a toujours une qui finit chez le voisin ğŸ˜…. Vous risquez de vous Ã©puiser rapidement â€¦ Un monolithe est bien plus adaptÃ© aux petites Ã©quipesÂ : tout le monde travaille sur le mÃªme code, câ€™est plus facile Ã  suivre et Ã  tester. Nâ€™oublions pas que chaque microservice additionnel, câ€™est du <em>fardeau opÃ©rationnel en plus</em> (pipelines CI/CD multiples, dÃ©ploiements multiples, versions multiplesâ€¦). Quand on nâ€™a que 2-3 dÃ©veloppeurs, mieux vaut les concentrer sur une base de code unique que de les disperser.</p><li><p>Ã€ lâ€™inverse, si vous disposez de <strong>plusieurs Ã©quipes dÃ©diÃ©es</strong>, avec chacune son pÃ©rimÃ¨tre fonctionnel, les microservices peuvent aider Ã  dÃ©coupler le travail. Câ€™est lÃ  quâ€™intervient la fameuse rÃ¨gle dâ€™Amazon des <em>â€œtwo-pizza teamsâ€</em>. Jeff Bezos a instaurÃ© que chaque Ã©quipe doit Ãªtre suffisamment petite pour Ãªtre nourrie avec deux pizzas. En pratique, <strong>chaque Ã©quipe chez Amazon est propriÃ©taire dâ€™un service</strong> et peut le faire Ã©voluer Ã  son rythme. Cette organisation en microservices a permis Ã  Amazon de scaler tant au niveau technique quâ€™humainÂ : des Ã©quipes autonomes, livrant indÃ©pendamment, sans se marcher sur les pieds. On retrouve une idÃ©e similaire chez Uber : quand lâ€™entreprise est passÃ©e de quelques dizaines Ã  des centaines de dÃ©veloppeurs, le monolithe dâ€™origine est devenu un goulot dâ€™Ã©tranglement, car toutes les Ã©quipes Ã©taient <em>couplÃ©es</em> par ce code unique. Le passage Ã  une multitude de services a permis Ã  chaque groupe dâ€™avancer plus librement, sans attendre que <em>â€œle monolithe veuille bien dÃ©ployerâ€</em>.</p><li><p>En gros, <strong>conformez lâ€™architecture Ã  votre organisation</strong> (câ€™est la fameuse <a href="https://en.wikipedia.org/wiki/Conway%27s_law">Conwayâ€™s Law</a>). Si vous avez dÃ©jÃ  des Ã©quipes ou des domaines bien sÃ©parÃ©s, les microservices peuvent reflÃ©ter ce dÃ©coupage naturel. Si votre Ã©quipe est un bloc unique, imposer des microservices crÃ©e artificiellement des frontiÃ¨resâ€¦ et potentiellement des silos injustifiÃ©s.</p></ul><p>Un autre aspect humain : les compÃ©tences. Une petite Ã©quipe full-stack â€œclassiqueâ€ sera plus Ã  lâ€™aise Ã  travailler sur un seul projet monolithique. Tandis que dans une grande organisation, on peut avoir des Ã©quipes spÃ©cialisÃ©es (ex: une team pour chaque microservice, avec Ã©ventuellement des technos diffÃ©rentes). <strong>Pas dâ€™Ã©quipe dÃ©diÃ©e = pas de microservice dÃ©diÃ©</strong>, câ€™est un bon rÃ©flexe Ã  avoir.</p><p><em>Petite anecdote :</em> Amazon nâ€™est pas dogmatique non plus. RÃ©cemment, leur division Prime Video a opÃ©rÃ© un mouvement surprise en <strong>abandonnant une architecture microservices/serverless au profit dâ€™un bon gros monolithe</strong>â€¦ RÃ©sultat : des coÃ»ts rÃ©duits et de bien meilleures performances pour leur workload! Preuve que mÃªme avec des centaines de dÃ©veloppeurs, la solution â€œplein de microservicesâ€ nâ€™est pas toujours la plus efficiente â€“ cela dÃ©pend du contexte et du problÃ¨me Ã  rÃ©soudre.</p><h3 id="Ã©tape3-identifier-les-besoins-de-scalabilitÃ©-et-de-performance"><span class="mr-2">Ã‰tapeÂ 3Â : Identifier les <strong>besoins de scalabilitÃ©</strong> et de performance</span><a href="#Ã©tape3-identifier-les-besoins-de-scalabilitÃ©-et-de-performance" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Passons au cÃ´tÃ© technique : <strong>quelle charge votre application doit-elle encaisser et comment veut-on la faire monter en charge (scaling)Â ?</strong> Les microservices sont souvent vendus comme <em>LE</em> remÃ¨de anti-surcharge, mais la rÃ©alitÃ© est nuancÃ©e.</p><ul><li><p>Si votre application doit gÃ©rer des <strong>volumes massifs</strong> de trafic ou de donnÃ©es, et surtout <strong>de faÃ§on inÃ©gale selon les fonctionnalitÃ©s</strong>, alors une architecture microservices est pertinente. Elle permet de <strong>scaler indÃ©pendamment</strong> chaque service selon la demande. Par exemple, imaginons un jeu en ligne oÃ¹ le module â€œclassement des pointsâ€ est ultra-sollicitÃ©, bien plus que le module â€œprofil utilisateurâ€. En microservices, on pourrait dÃ©ployer 10 instances du service <code class="language-plaintext highlighter-rouge">Classement</code> pour chaque instance du service <code class="language-plaintext highlighter-rouge">Profil</code>, afin dâ€™absorber la charge lÃ  oÃ¹ câ€™est nÃ©cessaire. De grandes entreprises ont adoptÃ© ce principe : <strong>Netflix</strong> a scindÃ© sa plateforme en plus de 700 microservices pour gÃ©rer chaque partie du systÃ¨me de maniÃ¨re autonome, aprÃ¨s avoir souffert des limites dâ€™un monolithe. En 2008, un incident cÃ©lÃ¨bre a vu la base de donnÃ©es centrale de Netflix corrompue, plongeant tout le service dans le noir pendant trois jours. Cette panne a mis en lumiÃ¨re le <em>point faible</em> du monolithe : un seul composant qui flanche peut tout faire tomber. Netflix a alors migrÃ© vers AWS et une architecture microservices, Ã©liminant les points uniques de dÃ©faillance et permettant de faire Ã©voluer sÃ©parÃ©ment chaque brique (lecture de vidÃ©os, recommandations, facturation, etc.). Depuis, lâ€™infrastructure Netflix repose sur une multitude de petits services robustes, capables de servir des millions dâ€™utilisateurs et de dÃ©ployer des changements en continu â€“ parfois des milliers de dÃ©ploiements par jour !</p><li><p>De mÃªme, <strong>Amazon</strong> (encore eux) a besoin que certains pans de son site puissent encaisser des pics Ã©normes (pensez au <em>Black Friday</em> sur le panier dâ€™achat ou les paiements). Leur architecture microservices permet de renforcer <em>uniquement</em> les services critiques en pic de charge, sans toucher aux autres. Câ€™est comme pouvoir ajouter des voies sur lâ€™autoroute lÃ  oÃ¹ il y a des embouteillages, sans avoir Ã  refaire toutes les routes du pays.</p><li><p><strong>En revanche</strong>, si votre application nâ€™a pas le besoin dâ€™une scalabilitÃ© granulaire, un monolithe bien conÃ§u peut suffire largement. Beaucoup dâ€™applications mÃ©tier â€œclassiquesâ€ tournent trÃ¨s bien avec un dÃ©ploiement monolithique dupliquÃ© sur quelques serveurs en load-balancing pour gÃ©rer la charge. MÃªme un gros monolithe peut scaler horizontalement en dÃ©ployant plusieurs instances identiques derriÃ¨re un rÃ©partiteur de charge. <strong>On sous-estime parfois jusquâ€™oÃ¹ un monolithe peut aller</strong> : vous pouvez dÃ©jÃ  bÃ¢tir un commerce qui tourne rondement avec une seule base de donnÃ©es et une appclication web bien optimisÃ©e sur un serveur aux ressources gÃ©nÃ©reuses. Si une partie de votre application commence Ã  saturer les ressources, il est tout Ã  fait possible de lâ€™optimiser ou de monter en vertical (plus de CPU, de RAM) avant dâ€™envisager un dÃ©coupage.</p><li><p>Par ailleurs, <strong>microservices nâ€™Ã©gale pas automatiquement meilleures performances</strong>. En fait, <em>chaque appel distant ajoute de la latence</em> et de la charge (sÃ©rialisation/dÃ©sÃ©rialisation, routage rÃ©seauâ€¦). Donc, pour de <em>fortes exigences de performance en temps rÃ©el</em>, trop de microservices peuvent nuire. Il faut un certain <strong>seuil de complexitÃ©/Ã©chelle</strong> pour que les bÃ©nÃ©fices surpassent les coÃ»ts. Lâ€™anecdote dâ€™Amazon Prime Video lâ€™illustre bien : ils avaient dÃ©coupÃ© un workflow en fonctions serverless (microservices), pensant gagner en scaling, mais ont atteint des limites Ã  seulement 5% de charge prÃ©vue. Leur solution a Ã©tÃ© de <strong>re-fusionner</strong> les composants critiques en un seul service optimisÃ© et bingo, Ã§a a bien mieux tenu la charge. Morale : si vos besoins de scalabilitÃ© peuvent Ãªtre satisfaits par un bon vieux monolithe <strong>optimisÃ©</strong>, inutile dâ€™ajouter de la complexitÃ© sans justification concrÃ¨t.</p></ul><p>En rÃ©sumÃ©, posez-vous les questions suivantes : <em>Est-ce que certaines parties du systÃ¨me ont des profils de charge trÃ¨s diffÃ©rents des autresÂ ? Dois-je pouvoir scaler un module sans toucher aux autresÂ ? Ai-je des contraintes de disponibilitÃ© trÃ¨s fines qui nÃ©cessitent dâ€™isoler les pannes potentiellesÂ ?</em> Si oui, orientez-vous vers une segmentation en services. Sinon, un monolithe peut trÃ¨s bien faire le boulot, <strong>plus simplement</strong>.</p><h3 id="Ã©tape4-examiner-la-frÃ©quence-de-dÃ©ploiement-et-lindÃ©pendance-des-fonctionnalitÃ©s"><span class="mr-2">Ã‰tapeÂ 4Â : Examiner la <strong>frÃ©quence de dÃ©ploiement</strong> et lâ€™indÃ©pendance des fonctionnalitÃ©s</span><a href="#Ã©tape4-examiner-la-frÃ©quence-de-dÃ©ploiement-et-lindÃ©pendance-des-fonctionnalitÃ©s" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Un avantage souvent mis en avant des microservices, câ€™est de permettre des <strong>dÃ©ploiements indÃ©pendants et frÃ©quents</strong> de chaque composant. Voyons si câ€™est pertinent pour vous :</p><ul><li><p><strong>Votre Ã©quipe dÃ©ploie-t-elle trÃ¨s souvent de nouvelles fonctionnalitÃ©s, de maniÃ¨re dÃ©couplÃ©eÂ ?</strong> Par exemple, si le module â€œFacturationâ€ doit Ãªtre mis en production 3 fois par semaine, alors que le reste du systÃ¨me bouge peu, lâ€™architecture microservices vous permettrait de dÃ©ployer le service Facturation seul, sans interrompre ni revalider toute lâ€™application. Idem, sâ€™il y a une Ã©quipe dÃ©diÃ©e qui ne travaille <em>que</em> sur le moteur de recherche du site, elle pourrait livrer ses Ã©volutions indÃ©pendamment des autres. Ce scÃ©nario plaide en faveur de microservices, pour gagner en <strong>vitesse de livraison</strong>. Les gÃ©ants du web en profitent : <strong>Amazon</strong> a des dÃ©ploiements en continu de microservices tout au long de la journÃ©e, sans quoi il leur serait impossible de faire Ã©voluer leur plateforme tentaculaire sans tout casser. Chaque Ã©quipe publie son service quand elle est prÃªte, point. Cela a considÃ©rablement accÃ©lÃ©rÃ© lâ€™innovation et le <em>time-to-market</em>.</p><li><p><strong>DÃ©pendances modulaires</strong> : Si vos fonctionnalitÃ©s sont relativement indÃ©pendantes les unes des autres sur le plan mÃ©tier, les microservices Ã©vitent que dÃ©ployer A implique de retester B, C et D qui nâ€™ont rien Ã  voir. Câ€™est un atout pour la qualitÃ© et lâ€™<strong>agilitÃ©</strong>. Par exemple, chez Netflix, les Ã©quipes peuvent modifier le service de recommandation de films et le dÃ©ployer, sans devoir geler le service de lecture vidÃ©o ou le service dâ€™abonnement. Dans un monolithe, une petite modification dans le code de recommandations nÃ©cessiterait de reconstruire et redÃ©ployer <em>tout</em> le monolithe, avec les risques que cela comporte.</p><li><p><strong>Ã€ lâ€™inverse</strong>, si vous dÃ©ployez plutÃ´t <strong>rarement</strong> et que vos releases englobent de toute faÃ§on <em>toutes</em> les parties de lâ€™application en mÃªme temps (train de livraison coordonnÃ©), le bÃ©nÃ©fice de microservices diminue. Beaucoup de systÃ¨mes internes dâ€™entreprise suivent des cycles de mise en production globales (par ex. une release mensuelle de lâ€™application entiÃ¨re). Le fait dâ€™Ãªtre en microservices ne changerait pas grand-chose, puisque vous attendriez quand mÃªme dâ€™avoir tout packagÃ© pour dÃ©ployer. Voire pire : cela pourrait <em>compliquer</em> la synchronisation (sâ€™assurer que les 10 services sont tous alignÃ©s pour la release, avec les bonnes versions dâ€™API, etc.). Dans ce genre de contexte, un monolithe peut simplifier la livraison.</p><li><p>Posez-vous la question de la <strong>coordination des versions</strong> : si chaque microservice Ã©volue indÃ©pendamment, il faut gÃ©rer la compatibilitÃ© entre eux. Câ€™est jouable (contrats dâ€™API stables, versions rÃ©trocompatiblesâ€¦), mais câ€™est du travail de plus. Si votre Ã©quipe a dÃ©jÃ  du mal Ã  coordonner du versioning au sein dâ€™un monolithe, la multiplication des services ne va pas arranger les choses par magie, au contraire.</p></ul><p>En somme, les microservices prennent tout leur sens si vous visez un modÃ¨le <strong>DevOps/CI-CD trÃ¨s poussÃ©</strong>, avec des livraisons continues par composant. Vous pourrez publier plus vite, en isolant les risques. Si ce niveau de frÃ©quence nâ€™est ni nÃ©cessaire ni rÃ©aliste pour vous, <strong>ne vous infligez pas la complexitÃ©</strong> dâ€™une architecture distribuÃ©e. Parfois, dÃ©ployer calmement un bon gros monolithe une fois toutes les deux semaines, Ã§a suffit amplement pour rendre les utilisateurs heureux.</p><h3 id="Ã©tape5-vÃ©rifier-les-capacitÃ©s-techniques-devops-monitoring-etc"><span class="mr-2">Ã‰tapeÂ 5Â : VÃ©rifier les <strong>capacitÃ©s techniques</strong> (DevOps, monitoring, etc.)</span><a href="#Ã©tape5-vÃ©rifier-les-capacitÃ©s-techniques-devops-monitoring-etc" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Câ€™est un aspect souvent sous-estimÃ© : avez-vous lâ€™<strong>infrastructure et les outils</strong> pour supporter une galaxie de microservicesÂ ? Et lâ€™expertise qui va avecÂ ?</p><p>Mettre en place des microservices, ce nâ€™est pas juste dÃ©couper du code en petits morceaux. Il faut aussi tout un Ã©cosystÃ¨me technique pour les faire tourner correctementÂ :</p><ul><li><p><strong>Conteneurs, orchestrateurs</strong> : En gÃ©nÃ©ral, qui dit microservices dit Docker, Kubernetes, ou autre plateforme orchestrÃ©e. DÃ©ployer manuellement 20 services sur des VM, câ€™est ingÃ©rable, vous aurez besoin dâ€™automatisation. Votre Ã©quipe est-elle familiÃ¨re avec ces technologiesÂ ? A-t-elle quelquâ€™un qui <em>maÃ®trise Kubernetes</em> (AKS, EKS, peu importe) pour opÃ©rer lâ€™infrastructureÂ ? Si ce nâ€™est pas le cas, prÃ©voyez une <em>solide courbe dâ€™apprentissage</em> et du temps en â€œRecherche et DÃ©veloppementâ€, sinon vous allez vous retrouver Ã  hÃ©berger vos microservices â€œÃ  la mainâ€, ce qui est aventureux ğŸ˜….</p><li><p><strong>Monitoring &amp; logging</strong> : Un monolithe a souvent une seule source de logs, facile Ã  parcourir. Avec 10 microservices, bonjour la chasse aux logs dans 10 endroits diffÃ©rents. Il vous faudra mettre en place une solution de logs centralisÃ©s (ELK, Application Insights, etc.) et du <strong>monitoring</strong> distribuÃ©. Idem pour le <strong>tracing</strong> des requÃªtes entre services (systÃ¨mes de traÃ§age distribuÃ© de type OpenTelemetry). Sans ces outils, vous serez <em>aveugle</em> lorsque quelque chose plantera Ã  3h du matin dans un enchaÃ®nement de 5 services. Il faut donc investir du temps Ã  instrumenter chaque service, Ã  se doter de dashboards, dâ€™alertesâ€¦ Est-ce que votre Ã©quipe a les compÃ©tences pour Ã§aÂ ? Et le tempsÂ ? Si non, câ€™est un signal fort que le passage aux microservices pourrait Ãªtre prÃ©maturÃ©.</p><li><p><strong>Robustesse et tolÃ©rance aux pannes</strong> : Dans un systÃ¨me distribuÃ©, <strong>tout</strong> peut arriver : un service peut tomber, un appel rÃ©seau peut Ã©chouer ou expirer, etc. Vos dÃ©veloppeurs doivent adopter des pratiques de code rÃ©silient (patterns de retry, circuit-breaker â€“ avec Polly en .NET par exemple). Ils doivent penser <em>â€œet si le service en face ne rÃ©pond pasÂ ?â€</em> en permanence. Câ€™est un Ã©tat dâ€™esprit et une expertise diffÃ©rente de la programmation monolithique oÃ¹ <em>un NullReferenceException est souvent le pire scÃ©nario</em>. Ici on parle de gÃ©rer des <em>time out</em>, des files dâ€™attente, des messages perdusâ€¦ <strong>Si lâ€™Ã©quipe nâ€™a jamais fait Ã§a, il y aura des ratÃ©s.</strong> Ce nâ€™est pas insurmontable, mais câ€™est un coÃ»t de formation et dâ€™expÃ©rience Ã  anticiper. Netflix, par exemple, a dÃ» inventer lâ€™outil <a href="https://fr.wikipedia.org/wiki/Chaos_Monkey">Chaos Monkey</a> qui Ã©teint alÃ©atoirement des services en production pour sâ€™assurer que le systÃ¨me global survit aux pannes individuelles â€“ câ€™est dire le niveau de maturitÃ© Ã  atteindre pour dompter un tel Ã©cosystÃ¨me !</p><li><p><strong>ComplexitÃ© de debug</strong> : PrÃ©parez-vous Ã  ce que votre dÃ©bogage â€œF5 dans VisualÂ Studioâ€ se transforme en parties de cache-cache dans une ferme de services. Un dÃ©veloppeur racontait, un brin dÃ©sabusÃ©, comment ses microservices passaient leur temps Ã  <em>â€œÃ©changer entre eux sur le rÃ©seauâ€</em>, et que dÃ¨s quâ€™un service â€œfaisait un capriceâ€, bonne chance pour identifier la source du problÃ¨me. Ce qui Ã©tait un simple appel de fonction devient une succession de requÃªtes asynchrones Ã  travers le rÃ©seau, avec des <strong>erreurs possiblement silencieuses</strong> en chemin. Debugger Ã§a sans outillage, câ€™est comme chercher une aiguille dans un champ de foinâ€¦ la nuitâ€¦ avec une lampe frontale dÃ©chargÃ©e. ğŸ”¦ğŸ˜… Autrement dit, <em>assurez-vous dâ€™avoir les outils et les compÃ©tences de dÃ©bogage distribuÃ©</em>, sinon vos nuits pourraient devenir trÃ¨s courtes.</p></ul><p>En rÃ©sumÃ©, une architecture microservices nâ€™est viable que si <strong>votre stack technique et votre Ã©quipe sont prÃªtes</strong> Ã  en assumer les Ã -cÃ´tÃ©s. Posez-vous sincÃ¨rement la question : <em>Mon Ã©quipe est-elle suffisamment DevOpsÂ ? Avons-nous les ressources pour mettre en place : CI/CD, conteneurs, monitoring, tests end-to-end sur un systÃ¨me distribuÃ©Â ?</em> Si la rÃ©ponse est â€œnahhhhhhâ€, il vaut peut-Ãªtre mieux consolider vos pratiques sur un monolithe dâ€™abord. Rien nâ€™empÃªche dâ€™adopter certaines bonnes pratiques devops (intÃ©gration continue, conteneurisation) sur le monolithe en prÃ©vision, mais ne pas se jeter dans le grand bain â€œmulti-servicesâ€ avant de savoir nager.</p><h3 id="Ã©tape6-peser-les-coÃ»ts-et-la-valeur-ajoutÃ©e"><span class="mr-2">Ã‰tapeÂ 6Â : Peser les <strong>coÃ»ts</strong> et la valeur ajoutÃ©e</span><a href="#Ã©tape6-peser-les-coÃ»ts-et-la-valeur-ajoutÃ©e" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Dernier point, et non des moindresÂ : <strong>le coÃ»t et le retour sur investissement</strong>. Les microservices ont un coÃ»t <strong>technique</strong> <em>et</em> <strong>organisationnel</strong>. Il faut sâ€™assurer que les bÃ©nÃ©fices espÃ©rÃ©s valent cette dÃ©pense.</p><ul><li><p><strong>CoÃ»t de dÃ©veloppement</strong> : Diviser une application en 10 services, câ€™est potentiellement <em>10 dÃ©pÃ´ts git, 10 pipelines de build, 10 projets Ã  tester et maintenir</em>. La productivitÃ© peut en prendre un coup. Un architecte rapportait que dans son entreprise, dÃ©velopper une fonctionnalitÃ© Ã©quivalente prenait <em>8 fois plus de temps avec une architecture microservices quâ€™avec un monolithe</em>, et nÃ©cessitait deux fois plus de dÃ©veloppeurs! Pourquoi ? Parce quâ€™il faut dÃ©finir des contrats dâ€™API, gÃ©rer les versions, Ã©crire du code de communication, synchroniser les dÃ©ploiementsâ€¦ tout cela, un monolithe nous lâ€™Ã©pargne en grande partie. Alors oui, <em>8x</em> câ€™est un cas extrÃªme, mais ne soyez pas surpris si au dÃ©but vos livraisons ralentissent en passant aux microservices. Câ€™est un <strong>investissement long terme</strong> : on accepte de ralentir maintenant en espÃ©rant aller plus vite plus tard, quand lâ€™application sera trÃ¨s grosse et que les Ã©quipes parallÃ©liseront vraiment le travail. Pour un petit projet, cet investissement ne sera <strong>jamais rentabilisÃ©</strong>.</p><li><p><strong>CoÃ»t opÃ©rationnel</strong> : Plus de services = plus de ressources serveurs (mÃ©moire, CPU, instances multiples). Si chaque microservice a sa base de donnÃ©es sÃ©parÃ©e (idÃ©alement oui), Ã§a fait autant de serveurs de BD Ã  gÃ©rer/payer/licencier. Sur le cloud, multiplier les conteneurs ou fonctions serverless peut faire grimper la facture Ã  la fin du mois. LÃ  oÃ¹ un monolithe tournait sur 2 VM Ã  80% CPU, vos 10 microservices tournent peut-Ãªtre sur 20 conteneurs globalement sous-utilisÃ©sâ€¦ mais facturÃ©s quand mÃªme. <strong>Avez-vous le budget</strong> pour ce overheadÂ ? Parfois, le jeu en vaut la chandelle (si vos microservices attirent 100Ã— plus dâ€™utilisateurs, le coÃ»t supplÃ©mentaire est justifiÃ©). Parfois non : on a vu des startups flamber leur budget infonuagique en orchestrant une flotte de microservices qui auraient pu tenir dans un seul petit serveur.</p><li><p><strong>ComplexitÃ© = risques</strong> : La complexitÃ© additionnelle peut engendrer plus de <strong>pannes</strong> ou de bugs subtils. Chaque service ajoutÃ© est un point potentiel de dÃ©faillance en plus (une panne rÃ©seau, un plantage de service, ou un Ã©chec de synchronisation des donnÃ©esâ€¦). Et quand Ã§a plante, le temps passÃ© Ã  rÃ©soudre (MTTR) risque dâ€™Ãªtre plus long quâ€™avec un monolithe. Ce coÃ»t-lÃ  est dur Ã  chiffrer, mais bien rÃ©el (heures supplÃ©mentaires, interruptions de service, image de marque, etc.). Pour le minimiser, il faut investir dans la fiabilitÃ© (tests, monitoring, redondance) ce qui renchÃ©rit encore le coÃ»t technique initial.</p><li><p><strong>ROI mÃ©tier</strong> : demandez-vous <em>quels problÃ¨mes concrets les microservices vont rÃ©soudre pour votre business</em>. Si la rÃ©ponse est du genre <em>â€œcâ€™est Ã  la modeâ€</em> ou <em>â€œon le fait pour faire propreâ€</em>, ce nâ€™est pas un vrai ROI ğŸ˜…. En revanche, si vous identifiez clairement que <em>â€œÃ§a nous permettra de dÃ©ployer plus vite des features pour nos clientsâ€</em> ou <em>â€œÃ§a Ã©liminera les indisponibilitÃ©s totales en cas de bugâ€</em> ou <em>â€œon pourra tenir la charge pendant les soldes sans planterâ€</em>, lÃ  on parle. <strong>Quantifiez</strong> autant que possible : par exemple, <em>passer de 1 dÃ©ploiement par mois Ã  10 dÃ©ploiements par jour</em> grÃ¢ce aux microservices a une valeur Ã©norme si votre marchÃ© exige cette rÃ©activitÃ©. Mais si votre application interne nâ€™a pas besoin dâ€™Ã©voluer si frÃ©quemment, ce gain est inutile.</p></ul><p>En somme, faites le <strong>bilan coÃ»t/bÃ©nÃ©fice</strong> le plus objectivement possible. Les microservices apportent des bÃ©nÃ©fices indÃ©niables (Ã©chelle, rÃ©silience, agilitÃ©) mais au prix dâ€™une complexitÃ© qui, dans bien des cas, nâ€™est tout simplement pas justifiÃ©e. Il nâ€™y a pas de honte Ã  rester sur un bon monolithe efficace si câ€™est la solution la plus rentable pour vous ! Dâ€™ailleurs, on voit un certain <em>retour de balancier</em> dans lâ€™industrie : aprÃ¨s lâ€™engouement dÃ©bridÃ© pour â€œtout microserviciserâ€, certaines entreprises reviennent Ã  des architectures plus simples pour rÃ©duire les coÃ»ts et la complexitÃ©, quitte Ã  sacrifier un peu de <em>hype</em>. Le tout, câ€™est dâ€™y gagner au final.</p><h2 id="conclusion-trouver-le-juste-milieu-et-dormir-sur-ses-deux-oreilles"><span class="mr-2">ConclusionÂ : Trouver le juste milieu (et dormir sur ses deux oreilles)</span><a href="#conclusion-trouver-le-juste-milieu-et-dormir-sur-ses-deux-oreilles" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>La grande leÃ§on Ã  retenirÂ ? <strong>â€œMicroserviceâ€ nâ€™est pas synonyme de â€œmieuxâ€ par dÃ©faut.</strong> Câ€™est un outil architectural parmi dâ€™autres, avec ses cas dâ€™usage idÃ©aux et ses piÃ¨ges. De mÃªme, le <strong>monolithe</strong> nâ€™est pas un dinosaure ringard bon pour le musÃ©e : il demeure tout Ã  fait pertinent dans bon nombre de situations.</p><p>Pour rÃ©capituler avec un petit guide <strong>quand ou ne pas utiliser une architecture microservices</strong>Â :</p><ul><li><p>âœ… <strong>Oui aux microservices</strong> dans des contextes tels que :</p><ul><li>Une application trÃ¨s complexe, couvrant plusieurs domaines fonctionnels clairement sÃ©parables, et/ou une <strong>grande organisation</strong> avec des Ã©quipes dÃ©diÃ©es par domaine. Ex: Un site web de type Amazon avec panier, paiement, recommandations, chacun Ã©voluant sÃ©parÃ©ment par des Ã©quipes diffÃ©rentes.<li>Des <strong>besoins de scalabilitÃ© fine</strong> : certaines parties du systÃ¨me doivent pouvoir monter en charge indÃ©pendamment (ex: moteur de recherche Ã  scaler sans scaler toute lâ€™application).<li>Une nÃ©cessitÃ© de <strong>dÃ©ploiements frÃ©quents et indÃ©pendants</strong> de certaines fonctionnalitÃ©s, pour livrer plus vite aux utilisateurs.<li>Une exigence de <strong>haute rÃ©silience</strong> : on veut quâ€™une panne dâ€™un composant nâ€™impacte pas tout le reste (architecture tolÃ©rante aux pannes).<li>Un environnement technique mature en DevOps, avec <strong>outils en place</strong> (CI/CD, container orchestration, monitoring distribuÃ©) et une Ã©quipe Ã  lâ€™aise avec ces concepts.<li>En somme, quand le <strong>gain attendu (autonomie, vitesse, robustesse, Ã©chelle)</strong> dÃ©passe le <strong>coÃ»t en complexitÃ©</strong>.</ul><li><p>ğŸš« <strong>Non (ou pas encore) aux microservices</strong> dans les cas suivants :</p><ul><li><strong>Projet trop petit ou jeune</strong> : si vous pouvez dÃ©velopper lâ€™ensemble de votre application en quelques mois avec 2-3 devs, un microservice ne va que ralentir la livraison. Partez monolithique, vous verrez plus tard si Ã§a devient trop gros.<li><strong>Ã‰quipe rÃ©duite/inexpÃ©rimentÃ©e en devops</strong> : pas dâ€™expertise conteneurs/Cloud, pas dâ€™Ã©quipe dÃ©diÃ©e Ã  lâ€™infrastructureâ€¦ Mieux vaut ne pas se compliquer la vie tout de suite. Comme on dit, <em>â€œil ne faut pas plusieurs chefs pour faire bouillir la marmiteâ€</em> â€“ une petite brigade de dÃ©veloppeurs fonctionne mieux autour dâ€™un seul chaudron (le monolithe).<li><strong>Domaines trÃ¨s interconnectÃ©s</strong> : si vos fonctionnalitÃ©s sont toutes fortement liÃ©es, les sÃ©parer en services entraÃ®nera beaucoup dâ€™appels rÃ©seau entre eux (le syndrome du <a href="https://medium.com/@dmosyan/doing-microservices-completely-wrong-distributed-monoliths-cede5c44d8a7">distributed monolith</a>). Vous nâ€™y gagnerez rien, si ce nâ€™est dâ€™Ã©changer un couplage interne contre un couplage rÃ©seau tout aussi contraignant.<li><strong>Contraintes de performance temps rÃ©el strictes</strong> : une application <em>low-latency</em> (ex : transactions boursiÃ¨res automatisÃ©es ultra-rapides, calcul scientifique synchronisÃ©) peut difficilement tolÃ©rer la latence ajoutÃ©e des microservices. Un monolithe optimisÃ© en C# (ou en Rust natif ğŸ˜‰) sera plus efficace.<li><strong>Budget serrÃ©</strong> : si chaque dollar compte, sachez que la complexitÃ© microservices peut impliquer plus de dÃ©penses (machines, temps de dÃ©veloppeur, consultants spÃ©cialisÃ©sâ€¦). Assurez-vous que votre responsable budgÃ©taire soit dâ€™accord avant de multiplier les dÃ©ploiements comme des lapins.<li>En bref, si <strong>les bÃ©nÃ©fices ne sont pas clairs et immÃ©diats</strong>, ou si votre contexte nâ€™est pas prÃªt, il est parfaitement raisonnable de <strong>rester sur un monolithe</strong> ou dâ€™adopter une approche intermÃ©diaire (par ex. un monolithe modulaire, bien dÃ©coupÃ© en couches ou en <em>modules internes</em> â€“ parfois appelÃ© â€œmodulitheâ€ ou â€œmonolithique modulableâ€). On peut trÃ¨s bien concevoir son code <em>comme</em> des microservices (avec de bonnes sÃ©parations logiques), tout en dÃ©ployant une seule application. Câ€™est souvent un excellent compromis pour dÃ©marrer.</ul></ul><p>En guise de clÃ´ture, rappelons-nous que <strong>lâ€™architecture sert les objectifs du logiciel, pas lâ€™inverse</strong>. Ne choisissez pas microservices ou monolithe pour suivre la mode, mais en fonction de ce qui apporte le plus de valeur Ã  <em>votre</em> produit et <em>vos</em> utilisateurs. La prochaine fois quâ€™on vous dira <em>â€œIl faut absolument des microservices, câ€™est plus <strong>scalable</strong> et <strong>hype</strong>â€œ</em>, vous pourrez rÃ©torquer : <em>â€œPeut-Ãªtre, mais encore faut-il que ce soit justifiÃ© â€“ parlons concret ! â€œ</em>.</p><p>Au fond, monolithes et microservices cohabitent dans la grande boÃ®te Ã  outils de lâ€™architecte. Le vrai talent est de sortir le bon outil au bon moment. Ce nâ€™est pas parce quâ€™on a vu des fermes industrielles avec des robots Ã  traire quâ€™il faut transformer sa petite Ã©table en usine Ã  microservices. Et Ã  lâ€™inverse, pour bÃ¢tir une cathÃ©drale logicielle frÃ©quentÃ©e par des millions de personnes, un seul bloc monolithique pourrait devenir un carcan rigide â€“ un Ã©chafaudage microservices offre alors plus de souplesse.</p><p><strong>En dÃ©finitive, soyez pragmatique</strong> : commencez simple, ayez conscience des <em>trade-offs</em>, et Ã©voluez lâ€™architecture quand les <strong>signaux</strong> le demandent (goulots dâ€™Ã©tranglement, blocage organisationnel, etc.). Si vous suivez les Ã©tapes et conseils ci-dessus, vous devriez Ã©viter aussi bien le <em>â€œmicroservice washingâ€</em> inconsidÃ©rÃ© que le <em>â€œmonolith forever par inertieâ€</em>.</p><p>Et surtout, nâ€™oubliez pas de savourer le voyage : que vous construisiez un majestueux monolithe ou une myriade de microservices, lâ€™essentiel est dâ€™<strong>apprendre en sâ€™amusant</strong>. AprÃ¨s tout, on Ã©crit du code pour rÃ©soudre des problÃ¨mes <em>et</em> pour le plaisir intellectuel. Alors faites les bons choix au bon moment, et laissez lâ€™architecture servir votre projet, pas lâ€™inverse.</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/architecture/'>architecture</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> Cet article est sous licence <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> par l'auteur.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Partager</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Faut-il%20vraiment%20adopter%20une%20architecture%20microservices%20-%20CodeWithFrenchy&url=https%3A%2F%2Fcodewithfrenchy.github.io%2F%2Fposts%2Fquand-utiliser-architecture-microservices%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.linkedin.com/sharing/share-offsite/?url=https%3A%2F%2Fcodewithfrenchy.github.io%2F%2Fposts%2Fquand-utiliser-architecture-microservices%2F" data-toggle="tooltip" data-placement="top" title="Linkedin" target="_blank" rel="noopener" aria-label="Linkedin"> <i class="fa-fw fab fa-linkedin"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Faut-il%20vraiment%20adopter%20une%20architecture%20microservices%20-%20CodeWithFrenchy&u=https%3A%2F%2Fcodewithfrenchy.github.io%2F%2Fposts%2Fquand-utiliser-architecture-microservices%2F" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copier le lien" data-title-succeed="Lien copiÃ© avec succÃ¨s!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">RÃ©cemment mis Ã  jour</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/plan-formation-dotnet/">Plan de formation - .NET Framework vers .NET moderne</a><li><a href="/posts/essais-architecture-automatises-dotnet/">Essais automatisÃ©s dâ€™architecture dans un projet .NET</a><li><a href="/posts/performances-jsonserializeroptions-singleton/">AmÃ©lioration des performances en utilisant JsonSerializerOptions en singleton</a><li><a href="/posts/source-generator-dotnet/">Les GÃ©nÃ©rateurs de source</a><li><a href="/posts/guid-versus-id/">GUID vs ID auto-incrÃ©mentÃ© - dilemme et solutions en environnement .NET distribuÃ©</a></ul></div><div id="access-tags"><div class="panel-heading">Tags tendance</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/dotnet/">dotnet</a> <a class="post-tag" href="/tags/essais/">essais</a> <a class="post-tag" href="/tags/conference/">conference</a> <a class="post-tag" href="/tags/source-generator/">source-generator</a> <a class="post-tag" href="/tags/aspnet-core/">aspnet-core</a> <a class="post-tag" href="/tags/fluentassertions/">fluentassertions</a> <a class="post-tag" href="/tags/fluentvalidation/">fluentvalidation</a> <a class="post-tag" href="/tags/k6/">k6</a> <a class="post-tag" href="/tags/mapperly/">mapperly</a> <a class="post-tag" href="/tags/testcontainers/">testcontainers</a></div></div></div><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">Contenu</div><nav id="toc"></nav></div><script src="https://cdn.jsdelivr.net/npm/tocbot@4.20.1/dist/tocbot.min.js"></script></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4 mt-5"><div id="related-posts" class="mb-2 mb-sm-4"><h3 class="pt-2 mb-4 ml-1" data-toc-skip>Autres lectures</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/utilisation-design-patterns/"><div class="card-body"> <em class="small" data-ts="1758549600" data-df="DD/MM/YYYY" > 22/09/2025 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Les design patternsÂ - les bons Legos pour vos applications .NET</h3><div class="text-muted small"><p> IntroductionÂ : Ne rÃ©inventez pas la roue, assemblez les Legos En conception logicielle, un design pattern (ou patron de conception) est une solution Ã©prouvÃ©e Ã  un problÃ¨me de conception rÃ©current....</p></div></div></a></div><div class="card"> <a href="/posts/concevoir-maintenir-application-performante-dotnet/"><div class="card-body"> <em class="small" data-ts="1761001200" data-df="DD/MM/YYYY" > 20/10/2025 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Concevoir et maintenir des applications microservices performantes en .NET</h3><div class="text-muted small"><p> La performance logicielle ne doit pas Ãªtre une rÃ©flexion aprÃ¨s coup : elle se conÃ§oit dÃ¨s le dÃ©part et se cultive tout au long de la vie du systÃ¨me. Dans cet article, nous explorons comment sâ€™outil...</p></div></div></a></div><div class="card"> <a href="/posts/essais-architecture-automatises-dotnet/"><div class="card-body"> <em class="small" data-ts="1762210800" data-df="DD/MM/YYYY" > 03/11/2025 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Essais automatisÃ©s dâ€™architecture dans un projet .NET</h3><div class="text-muted small"><p> Introduction Dans les projets .NET complexes, par exemple appliquant le Domain-Driven Design (DDD) ou une Clean Architecture stricte, il devient crucial de sâ€™assurer que la structure du code respe...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/vertical-slice-architecture/" class="btn btn-outline-primary" prompt="Plus ancien"><p>Architecture Vertical Slice dans lâ€™Ã©cosystÃ¨me .NET</p></a> <a href="/posts/utilisation-design-patterns/" class="btn btn-outline-primary" prompt="Plus rÃ©cent"><p>Les design patternsÂ - les bons Legos pour vos applications .NET</p></a></div></div></div></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Tags tendance</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/dotnet/">dotnet</a> <a class="post-tag" href="/tags/essais/">essais</a> <a class="post-tag" href="/tags/conference/">conference</a> <a class="post-tag" href="/tags/source-generator/">source-generator</a> <a class="post-tag" href="/tags/aspnet-core/">aspnet-core</a> <a class="post-tag" href="/tags/fluentassertions/">fluentassertions</a> <a class="post-tag" href="/tags/fluentvalidation/">fluentvalidation</a> <a class="post-tag" href="/tags/k6/">k6</a> <a class="post-tag" href="/tags/mapperly/">mapperly</a> <a class="post-tag" href="/tags/testcontainers/">testcontainers</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><footer><div class="container pl-lg-4 pr-lg-4"><div class="d-flex justify-content-between align-items-center text-muted ml-md-3 mr-md-3"><div class="footer-left"><p class="mb-0"> Â© 2026 <a href="https://twitter.com/alexis35115">Alexis Garon-Michaud</a>. <span data-toggle="tooltip" data-placement="top" title="Sauf mention contraire, les articles de ce site sont publiÃ©s sous licence sous la licence Creative Commons Attribution 4.0 International (CC BY 4.0) par l'auteur.">Certains droits rÃ©servÃ©s.</span></p></div><div class="footer-right"><p class="mb-0">PropulsÃ© par <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> avec le thÃ¨me <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a></p></div></div></div></footer><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oups! Aucun rÃ©sultat trouvÃ©.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lazysizes@5.3.2/lazysizes.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/fr.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/unregister.js"></script>
