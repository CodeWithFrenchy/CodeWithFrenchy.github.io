<!DOCTYPE html><html lang="fr-FR" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="theme-color" media="(prefers-color-scheme: light)" content="#f7f7f7"><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1e"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="viewport" content="width=device-width, user-scalable=no initial-scale=1, shrink-to-fit=no, viewport-fit=cover" ><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="Architecture Vertical Slice dans l’écosystème .NET" /><meta property="og:locale" content="fr_FR" /><meta name="description" content="L’architecture Vertical Slice (ou architecture en tranches verticales) est une approche de conception logicielle qui consiste à organiser le code par fonctionnalités verticales plutôt que par couches techniques. Autrement dit, chaque fonctionnalité de l’application est implémentée de bout en bout dans une tranche (un slice) comprenant tous les aspects nécessaires : interface utilisateur, logique métier et accès aux données. Chaque tranche verticale est autonome et correspond à un cas d’utilisation distinct, ce qui favorise un développement modulaire centré sur les fonctionnalités. En .NET, cette approche s’accompagne souvent du patron CQRS (Command Query Responsibility Segregation) : on sépare les opérations de lecture (Query) de celles d’écriture (Command) et on les traite différemment. La bibliothèque MediatR est fréquemment utilisée pour mettre en œuvre ce style – elle agit comme un médiateur qui envoie chaque commande ou requête vers son gestionnaire (handler) dédié, permettant de découpler l’émetteur de la requête de son traitement." /><meta property="og:description" content="L’architecture Vertical Slice (ou architecture en tranches verticales) est une approche de conception logicielle qui consiste à organiser le code par fonctionnalités verticales plutôt que par couches techniques. Autrement dit, chaque fonctionnalité de l’application est implémentée de bout en bout dans une tranche (un slice) comprenant tous les aspects nécessaires : interface utilisateur, logique métier et accès aux données. Chaque tranche verticale est autonome et correspond à un cas d’utilisation distinct, ce qui favorise un développement modulaire centré sur les fonctionnalités. En .NET, cette approche s’accompagne souvent du patron CQRS (Command Query Responsibility Segregation) : on sépare les opérations de lecture (Query) de celles d’écriture (Command) et on les traite différemment. La bibliothèque MediatR est fréquemment utilisée pour mettre en œuvre ce style – elle agit comme un médiateur qui envoie chaque commande ou requête vers son gestionnaire (handler) dédié, permettant de découpler l’émetteur de la requête de son traitement." /><link rel="canonical" href="https://codewithfrenchy.github.io//posts/vertical-slice-architecture/" /><meta property="og:url" content="https://codewithfrenchy.github.io//posts/vertical-slice-architecture/" /><meta property="og:site_name" content="CodeWithFrenchy" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2025-06-29T20:00:00-04:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Architecture Vertical Slice dans l’écosystème .NET" /><meta name="twitter:site" content="@alexis35115" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2025-06-29T20:00:00-04:00","datePublished":"2025-06-29T20:00:00-04:00","description":"L’architecture Vertical Slice (ou architecture en tranches verticales) est une approche de conception logicielle qui consiste à organiser le code par fonctionnalités verticales plutôt que par couches techniques. Autrement dit, chaque fonctionnalité de l’application est implémentée de bout en bout dans une tranche (un slice) comprenant tous les aspects nécessaires : interface utilisateur, logique métier et accès aux données. Chaque tranche verticale est autonome et correspond à un cas d’utilisation distinct, ce qui favorise un développement modulaire centré sur les fonctionnalités. En .NET, cette approche s’accompagne souvent du patron CQRS (Command Query Responsibility Segregation) : on sépare les opérations de lecture (Query) de celles d’écriture (Command) et on les traite différemment. La bibliothèque MediatR est fréquemment utilisée pour mettre en œuvre ce style – elle agit comme un médiateur qui envoie chaque commande ou requête vers son gestionnaire (handler) dédié, permettant de découpler l’émetteur de la requête de son traitement.","headline":"Architecture Vertical Slice dans l’écosystème .NET","mainEntityOfPage":{"@type":"WebPage","@id":"https://codewithfrenchy.github.io//posts/vertical-slice-architecture/"},"url":"https://codewithfrenchy.github.io//posts/vertical-slice-architecture/"}</script><title>Architecture Vertical Slice dans l’écosystème .NET | CodeWithFrenchy</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="CodeWithFrenchy"><meta name="application-name" content="CodeWithFrenchy"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tocbot@4.20.1/dist/tocbot.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener('change', () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.notify(); } /* flipMode() */ } /* ModeToggle */ const modeToggle = new ModeToggle(); </script><body data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" class="mx-auto"> <img src="https://avatars.githubusercontent.com/u/53872142?s=400&u=53187283fe05254234a3890e2b44134f96e3a833&v=4" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title"> <a href="/">CodeWithFrenchy</a></div><div class="site-subtitle font-italic">Architecte logiciel, audacieux et fermier</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>ACCUEIL</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATÉGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>À PROPOS DE</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/alexis35115" aria-label="github" target="_blank" rel="noopener noreferrer"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/alexis35115" aria-label="twitter" target="_blank" rel="noopener noreferrer"> <i class="fab fa-twitter"></i> </a> <a href="https://www.linkedin.com/in/alexis-garon-michaud-a59643219/" aria-label="linkedin" target="_blank" rel="noopener noreferrer"> <i class="fab fa-linkedin"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <span id="breadcrumb"> <span> <a href="/"> Accueil </a> </span> <span>Architecture Vertical Slice dans l’écosystème .NET</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Recherche..."> </span> <span id="search-cancel" >Annuler</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>Architecture Vertical Slice dans l’écosystème .NET</h1><div class="post-meta text-muted"> <span> Posté <em class="" data-ts="1751241600" data-df="DD/MM/YYYY" data-toggle="tooltip" data-placement="bottom"> 29/06/2025 </em> </span><div class="d-flex justify-content-between"> <span> Par <em> <a href="https://twitter.com/alexis35115">Alexis Garon-Michaud</a> </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="5540 mots"> <em>30 min</em> à lire</span></div></div></div><div class="post-content"><p>L’<strong>architecture Vertical Slice</strong> (ou <em>architecture en tranches verticales</em>) est une approche de conception logicielle qui consiste à organiser le code par fonctionnalités verticales plutôt que par couches techniques. Autrement dit, chaque fonctionnalité de l’application est implémentée <strong>de bout en bout</strong> dans une tranche (un <em>slice</em>) comprenant tous les aspects nécessaires : interface utilisateur, logique métier et accès aux données. Chaque tranche verticale est autonome et correspond à un cas d’utilisation distinct, ce qui favorise un développement modulaire centré sur les fonctionnalités. En .NET, cette approche s’accompagne souvent du patron <strong>CQRS</strong> (<em>Command Query Responsibility Segregation</em>) : on sépare les opérations de lecture (<em>Query</em>) de celles d’écriture (<em>Command</em>) et on les traite différemment. La bibliothèque <strong>MediatR</strong> est fréquemment utilisée pour mettre en œuvre ce style – elle agit comme un médiateur qui envoie chaque commande ou requête vers son gestionnaire (handler) dédié, permettant de découpler l’émetteur de la requête de son traitement.</p><h2 id="avantages-de-larchitecture-vertical-slice"><span class="mr-2">Avantages de l’architecture Vertical Slice</span><a href="#avantages-de-larchitecture-vertical-slice" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li><strong>Lisibilité et cohésion par fonctionnalité :</strong> Le code de chaque fonctionnalité est regroupé au même endroit, ce qui le rend plus <strong>facile à comprendre et à maintenir</strong> qu’une base de code où les éléments d’une même fonctionnalité sont dispersés entre plusieurs couches. Cette forte cohésion interne à la tranche améliore la lisibilité : on peut se concentrer sur un <strong>use case</strong> à la fois sans être noyé dans la complexité globale.<li><strong>Découplage des fonctionnalités :</strong> Chaque tranche est <strong>indépendante des autres</strong>, ce qui réduit le couplage du système. Modifier ou ajouter une fonctionnalité impacte peu (voire pas du tout) les autres modules, minimisant les effets de bord. On obtient ainsi un système plus robuste face aux changements, chaque slice pouvant évoluer isolément.<li><strong>Facilité de test :</strong> Puisque la logique de chaque use case est isolée, on peut tester une tranche verticalement sans dépendre du reste de l’application. Par exemple, il est simple d’écrire des tests unitaires pour un <em>handler</em> donné en simulant ses dépendances (bases de données, services externes, etc.), ce qui améliore la <strong>testabilité</strong> globale.<li><strong>Développement parallèle accéléré :</strong> Les équipes peuvent travailler <strong>simultanément sur différentes fonctionnalités</strong> sans se marcher sur les pieds, étant donné que chaque slice est autonome. Ceci réduit également les risques de conflits de merge et facilite l’intégration du code produit par plusieurs développeurs en parallèle. En grande équipe, segmenter le travail par vertical slices permet d’accélérer le développement en divisant le système en sous-problèmes indépendants.<li><strong>Ajout de fonctionnalités simplifié :</strong> L’architecture Vertical Slice tend à rendre l’application <strong>extensible par addition plutôt que par modification</strong>. L’ajout d’une nouvelle fonctionnalité se traduit par la création d’une nouvelle tranche (nouvelle requête, nouveau handler, etc.) <strong>sans modifier du code existant</strong>, ce qui limite le risque de régression. Cette propriété s’aligne bien avec le principe <em>Open/Closed</em> – le code en place est fermé aux modifications intempestives, tandis que le système est ouvert à de nouvelles extensions fonctionnelles.<li><strong>Flexibilité d’implémentation :</strong> Chaque tranche peut adopter l’approche technique la plus adaptée à son cas sans impacter le reste du projet. Par exemple, une fonctionnalité très simple pourra se contenter d’un traitement procédural direct (<em>transaction script</em>), tandis qu’une autre plus complexe pourrait utiliser des patterns de domaine riche – le choix peut se faire au niveau de la slice elle-même. De même, chaque tranche pourrait interagir avec des ressources externes différemment (base de données SQL, appel d’un service tiers, etc.) sans casser une “architecture globale” figée. Cette souplesse permet de <strong>personnaliser la solution par fonctionnalité</strong> et d’éviter les abstractions ou couches supplémentaires inutiles au sein d’une slice donnée.</ul><h2 id="inconvénients-et-limites-de-larchitecture-vertical-slice"><span class="mr-2">Inconvénients et limites de l’architecture Vertical Slice</span><a href="#inconvénients-et-limites-de-larchitecture-vertical-slice" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li><strong>Duplication de code (anti-DRY) :</strong> À force d’isoler chaque fonctionnalité, on risque de <strong>répéter du code commun</strong> dans plusieurs slices. Par exemple, des composants d’infrastructure ou des routines similaires peuvent se retrouver dupliqués dans chaque module fonctionnel. Cette redondance va à l’encontre du principe <strong>DRY</strong> (<em>Don’t Repeat Yourself</em>) et peut alourdir la maintenance : une correction de bug ou un changement commun doit être répercuté à plusieurs endroits. En adoptant Vertical Slice, on accepte implicitement une certaine duplication en échange d’une meilleure isolation, mais il faut surveiller que cela ne devienne pas ingérable (d’où le commentaire humoristique <strong>« Adieu DRY ! »</strong> souvent évoqué sur le sujet).<li><strong>Fragmentation et vision d’ensemble réduite :</strong> Un risque de cette approche est de morceler l’application en de nombreux petits <strong>silos</strong> de code. Si la modularité est poussée à l’extrême sans garde-fou, on peut <strong>perdre la vue d’ensemble du système</strong>. Chaque équipe ou développeur pouvant structurer “sa” tranche à sa manière, l’architecture globale peut manquer de cohérence. En l’absence de conventions communes, le code peut diverger d’une tranche à l’autre, rendant la maintenance transversale plus difficile. En outre, il devient délicat de comprendre le flux applicatif global puisque la logique est éclatée en morceaux indépendants. Il est donc crucial de définir des standards (structuration interne des slices, conventions de nommage, etc.) pour conserver une certaine homogénéité.<li><strong>Complexité de gestion des interactions :</strong> L’architecture Vertical Slice <strong>fonctionne mieux lorsque les fonctionnalités sont bien découplées</strong>. Si, en pratique, vos cas d’utilisation ont de fortes interactions ou partagent des processus communs, la gestion peut devenir compliquée. Par exemple, une transaction métier impliquant plusieurs slices distinctes s’avère difficile à orchestrer proprement avec ce modèle. On devra alors multiplier les contournements (appels de slice A vers slice B, utilisation de librairies tierces pour orchestrer du workflow, etc.), ce qui peut complexifier le code et le rendre inmaintenable. En d’autres termes, Vertical Slice n’est <strong>pas pensée pour des fonctionnalités étroitement liées ou fortement interdépendantes</strong>, et forcer ce modèle dans de tels cas peut conduire à une usine à gaz.<li><strong>Performances et logique transversale :</strong> Dans la même veine, si une opération utilisateur nécessite de coordonner plusieurs tranches verticales, l’application peut souffrir d’une certaine <strong>surcouche</strong>. Par exemple, devoir appeler successivement plusieurs handlers MediatR pour réaliser une action complexe peut introduire du surcoût (sérialisation/désérialisation de messages, I/O multiples, etc.). Des scénarios transactionnels touchant plusieurs slices seront difficiles à optimiser. Certes, dans la plupart des applications ce surcoût restera négligeable, mais sur un système à très hautes performances ou très complexe, c’est un point à considérer. L’architecture Vertical Slice est surtout plébiscitée pour <strong>des projets modulaires plutôt que pour de grosses transactions multi-domaines</strong> – lorsqu’on tente de l’appliquer à des contextes qu’elle gère mal (transactions distribuées, règles globales), on se heurte à ses limites.</ul><p>En résumé, Vertical Slice améliore la <strong>lisibilité locale</strong> et la <strong>séparation des préoccupations par fonctionnalité</strong>, au prix potentiel de duplications et d’une <strong>fragmentation</strong> du codebase. Ces inconvénients ne sont pas rédhibitoires, mais requièrent une vigilance et possiblement la mise en place de patterns complémentaires (par exemple un service commun pour factoriser du code partagé si nécessaire, ou un cadre d’architecture global minimal pour guider les devs).</p><h2 id="quand-utiliser-larchitecture-vertical-slice-"><span class="mr-2">Quand utiliser l’architecture Vertical Slice ?</span><a href="#quand-utiliser-larchitecture-vertical-slice-" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Comme tout choix architectural, l’approche Vertical Slice est plus ou moins adaptée selon le contexte. Voici des <strong>situations où son usage est recommandé</strong>, et d’autres où il l’est <strong>moins</strong> :</p><h3 id="scénarios-recommandés"><span class="mr-2">Scénarios recommandés</span><a href="#scénarios-recommandés" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li><strong>Applications modulaires ou microservices :</strong> Si votre application peut être découpée en <strong>modules indépendants</strong> (par exemple par domaine métier ou <em>bounded context</em>), l’architecture Vertical Slice s’aligne naturellement. Chaque module ou microservice peut correspondre à un ensemble de slices cohérents. On parle d’ailleurs souvent de <em>modular monolith</em> pour désigner un monolithe structuré en tranches verticales, qui offre une maintenabilité et une compréhension aisée du code. Dans ces architectures modulaires, chaque slice (ou ensemble de slices) représente un composant du système, facilement isolable pour le développement, le déploiement ou les tests.<li><strong>APIs REST simples ou projets de petite envergure :</strong> Pour une <strong>petite application, un MVP ou un service avec des cas d’utilisation simples</strong>, adopter d’emblée une architecture hexagonale ou Clean complète peut être surdimensionné. Dans ces cas, l’approche Vertical Slice apporte de la simplicité. On évite de créer pléthore de couches et d’abstractions alors que ce n’est pas nécessaire pour un petit projet. En d’autres termes, si vos besoins sont limités et bien circonscrits, « bricoler quelque chose rapidement » en séparant par fonctionnalités est tout à fait raisonnable, et formaliser une couche de domaine complète serait une perte de temps et d’énergie. Vous irez plus vite tout en gardant une bonne organisation par <em>features</em>.<li><strong>Développement de nouvelles fonctionnalités isolées :</strong> Même au sein d’un projet existant, vous pouvez utiliser Vertical Slice pour des <strong>modules très spécifiques ou autonomes</strong>. Par exemple, l’ajout d’une petite API indépendante dans un grand système peut se faire sous forme de slice verticale sans impacter l’architecture globale. De manière générale, si une fonctionnalité n’a quasiment <strong>pas de dépendance sur le reste du système</strong>, la développer comme une unité verticale permet de la livrer rapidement et de façon propre.<li><strong>Équipes multiples sur des domaines différents :</strong> Si vous avez plusieurs équipes ou développeurs qui travaillent en parallèle sur des <strong>sous-domaines différents</strong>, leur attribuer des vertical slices différentes peut réduire la collision de leurs travaux. Chaque équipe peut évoluer dans “son” périmètre avec moins de risques de modifier du code utilisé par les autres. Dans un contexte Agile, cela facilite la livraison continue de <em>features</em> indépendantes. (Il faut toutefois, comme mentionné, veiller à garder une cohérence globale via des <em>guidelines</em> communes.)</ul><h3 id="scénarios-moins-adaptés"><span class="mr-2">Scénarios moins adaptés</span><a href="#scénarios-moins-adaptés" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li><strong>Grand monolithe avec logique métier partagée :</strong> Si votre application forme un <strong>monolithe très complexe avec de nombreuses règles métier transverses</strong>, une architecture strictement Vertical Slice risque de montrer ses limites. Par exemple, dans un système bancaire monolithique, des règles de gestion comme “un client ne peut pas dépasser tel découvert” s’appliquent à <strong>plusieurs fonctionnalités</strong>. Les implémenter séparément dans chaque tranche conduirait à de la duplication et possiblement des incohérences. Dans ce genre de contexte, il est souvent préférable d’<strong>unifier la logique métier centrale</strong> dans un modèle commun (par exexemple, via une couche Domaine partagée, comme le propose <em>Clean Architecture</em>). L’architecture “propre” et dérivées (Hexagonale, etc.) sont le fruit de décennies d’expérience pour bâtir des solutions complexes de grande taille, que ce soit en monolithe ou en microservices. Elles apportent un cadre rigoureux pour garantir la cohérence de la logique métier à travers tout le système. À l’inverse, une approche Vertical Slice pure serait hasardeuse ici, car <strong>chaque slice devrait réimplémenter ou appeler ces règles communes</strong>, augmentant les risques d’erreur.<li><strong>Fonctionnalités fortement couplées entre elles :</strong> Si vos cas d’utilisation <strong>interagissent étroitement</strong>, qu’ils doivent se coordonner ou partager beaucoup de données, une séparation stricte par slices peut être artificielle. Par exemple, une opération complexe pourrait nécessiter l’enchaînement de plusieurs <em>slices</em> (ce qui revient à simuler une transaction répartie). Ce genre d’opération est pénible à réaliser proprement sans couche de service ou orchestrateur commun. Une architecture classique en couches permettrait ici de centraliser cette orchestration dans un service métier, là où Vertical Slice ne fournit pas de réponse évidente. En bref, plus vos fonctionnalités sont interdépendantes, moins l’architecture en tranches verticales est indiquée.<li><strong>Besoins de réutilisation du code métier :</strong> Dans certains projets, on cherche à construire une <strong>bibliothèque ou un noyau de composants réutilisables</strong> (par exemple, un moteur de calcul utilisé par plusieurs applications différentes). Dans ce cas, isoler complètement chaque feature n’est pas souhaitable : on veut au contraire factoriser le cœur commun. Vertical Slice, qui cloisonne le code par <em>use case</em>, n’est pas orientée vers la mutualisation du code. Si l’un de vos objectifs est de réutiliser une partie significative de la logique dans d’autres contextes ou d’exposer un modèle de domaine cohérent, une architecture du style Clean/DDD sera plus adaptée.<li><strong>Equipe débutante ou hétérogène sans guidelines :</strong> Enfin, il faut noter qu’une équipe peu expérimentée ou sans discipline pourrait <strong>dériver</strong> avec une architecture Vertical Slice. Parce qu’elle impose moins de structure prédéfinie qu’une architecture en couches, chaque développeur pourrait être tenté d’organiser « à sa sauce » sa slice. Sans concertation, le code risque de manquer d’uniformité et la maintenance deviendra difficile. Pour une équipe junior, une architecture plus classique (Clean, couches MVC, etc.) sert parfois de filet de sécurité grâce à son cadre clair. Cela ne disqualifie pas Vertical Slice, mais souligne l’importance d’un leadership technique pour guider sa mise en place dans un contexte d’équipe moins expérimentée.</ul><p>En somme, l’architecture Vertical Slice brille dans les contextes <strong>modulaires, évolutifs et indépendants</strong>, ou lorsque l’on veut <strong>aller vite sur des fonctionnalités ciblées</strong>. En revanche, dès qu’une forte mutualisation ou des invariants globaux sont nécessaires, il faut soit l’adapter (en combinant avec d’autres approches), soit envisager une architecture différente plus appropriée.</p><h2 id="comparaison-avec-le-clean-architecture"><span class="mr-2">Comparaison avec le Clean Architecture</span><a href="#comparaison-avec-le-clean-architecture" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Il est fréquent d’opposer Vertical Slice à le <strong>Clean Architecture</strong> (architecture “propre” d’après Robert C. Martin), car ces deux approches structurent le code très différemment. En réalité, elles poursuivent des objectifs communs (modularité, maintenabilité) mais via des principes distincts. Comparons-les selon quelques axes clés :</p><h3 id="principes-fondamentaux"><span class="mr-2">Principes fondamentaux</span><a href="#principes-fondamentaux" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Le Clean Architecture (ainsi que les architectures couches classiques, hexagonale, oignon, etc.) s’articule autour de la <strong>séparation des préoccupations horizontale</strong> et du respect de la <strong>dépendance inverse</strong>. Elle vise à rendre le cœur du logiciel indépendant des détails d’implémentation. Par exemple, la logique métier ne doit dépendre ni d’un framework particulier, ni de la base de données, ni de l’UI. Concrètement, on retrouve dans Clean Architecture des couches bien définies (Entités du domaine, Cas d’usage, Interfaces d’accès aux données, etc.), avec la règle que les dépendances pointent vers l’intérieur du cercle (vers le domaine). L’accent est mis sur la <strong>stabilité du modèle métier</strong> : il s’agit de protéger les règles de gestion des changements technologiques ou des caprices de l’interface.</p><p>L’architecture Vertical Slice, de son côté, est guidée par la <strong>cohérence fonctionnelle</strong>. Son principe central est de <strong>grouper le code par fonctionnalité métier</strong> de manière autonome. Chaque slice traite <strong>une et une seule fonctionnalité</strong> et embarque tout ce qu’il faut pour la réaliser. L’idée sous-jacente est d’obtenir une forte cohésion interne (tout le code lié à un cas d’utilisation est assemblé) et une faible dépendance externe (peu de liens avec d’autres parties du système). On couple “verticalement” le long d’un flux fonctionnel, plutôt qu’horizontalement par type de composant. En adoptant Vertical Slice, on accepte un certain cloisonnement par <em>feature</em>, au bénéfice d’une flexibilité locale et d’une simplicité de compréhension par cas d’usage.</p><p>En résumé, <strong>Clean Architecture met l’emphase sur le domaine et les abstractions stables</strong>, alors que <strong>Vertical Slice met l’emphase sur les features et leur isolation mutuelle</strong>. Clean cherche à éliminer le couplage <strong>technique</strong> (UI, DB, frameworks) vis-à-vis du métier, tandis que Vertical Slice cherche à éliminer le couplage <strong>fonctionnel</strong> entre les différentes parties du système.</p><h3 id="organisation-du-code-et-du-projet"><span class="mr-2">Organisation du code et du projet</span><a href="#organisation-du-code-et-du-projet" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Si on regarde l’organisation concrète d’un projet .NET dans chaque approche, la différence saute aux yeux. <strong>Clean Architecture</strong> propose typiquement de structurer la solution en <strong>couches</strong> ou couches concentriques. On peut avoir par exemple des projets ou <em>folders</em> séparés pour : le domaine (entités et interfaces), les cas d’application (<em>use cases</em> ou services applicatifs), l’interface (contrôleurs API, UI) et l’infrastructure (implémentations des dépôts, accès BD, services externes). Chaque couche a une responsabilité spécifique et des dépendances restreintes (p.ex. l’infrastructure dépend du domaine pour implémenter ses interfaces, mais l’inverse n’est pas vrai). Cette organisation par couches apporte de la clarté sur le rôle de chaque classe, mais peut introduire de la verbosité (de nombreux projets et fichiers pour une seule feature). Il faut naviguer entre plusieurs dossiers pour suivre le fil d’une fonctionnalité donnée.</p><p><strong>Vertical Slice</strong>, à l’opposé, organise le code par <strong>regroupement vertical</strong>. On va créer un dossier (ou un <em>namespace</em>) par fonctionnalité ou par module métier, et y placer tous les éléments liés : contrôleur API ou endpoint correspondant, classes de commande/requête, handler MédiatR, modèles spécifiques, etc.. Par exemple, au lieu d’avoir un dossier Controllers avec tous les contrôleurs de l’application, on aura un dossier <code class="language-plaintext highlighter-rouge">Features</code> contenant des sous-dossiers par fonctionnalité : <strong>Produit</strong>, <strong>Commande</strong>, <strong>Client</strong>, etc., et à l’intérieur de chacun, les fichiers pour créer un produit, mettre à jour un produit, etc. Chaque slice peut ainsi avoir <strong>ses propres modèles ou services internes</strong> s’il en a besoin, sans impacter les autres slices. Cette organisation par feature facilite la localisation du code – pour toucher à une fonctionnalité, on sait exactement où aller – mais rend plus difficile la réutilisation d’une classe d’une slice à l’autre (puisqu’a priori on évite de le faire). En pratique, il est courant qu’un projet Vertical Slice n’ait qu’un ou deux assemblages (ex: un projet Web et éventuellement un projet pour les contrats), là où une Clean Architecture en comporte plusieurs pour séparer les couches. Cela réduit la complexité initiale (moins de projets .NET à configurer), au prix d’une séparation moins nette entre logique métier et détails techniques.</p><h3 id="couplage-et-dépendances"><span class="mr-2">Couplage et dépendances</span><a href="#couplage-et-dépendances" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>La <strong>Clean Architecture</strong> excelle à réduire le couplage entre le domaine et les détails d’implémentation. Grâce à l’inversion des dépendances, le cœur métier ne “connaît” pas la base de données, ni le framework web utilisé. Cela permet, par exemple, de changer de base de données ou de technologie d’UI sans toucher au domaine (en théorie tout au moins). Le couplage est ainsi <strong>contrôlé et dirigé</strong> : les couches haut-niveau dépendent de couches bas-niveau abstraites (interfaces), jamais l’inverse. En revanche, <strong>les fonctionnalités dans Clean Architecture sont couplées via le domaine commun</strong>. Par exemple, deux <em>use cases</em> différents vont manipuler la même classe <strong>Produit</strong> ou <strong>Commande</strong>. Cela garantit une logique uniforme, mais signifie aussi que ces <em>use cases</em> sont indirectement reliés : toute modification dans la structure d’une entité du domaine peut impacter de multiples fonctionnalités. Le couplage fonctionnel n’est pas éliminé, il est centralisé dans le domaine.</p><p>L’approche Vertical Slice, de son côté, cherche à <strong>minimiser le couplage entre fonctionnalités</strong> au profit d’une <strong>forte cohésion interne</strong> à chaque fonctionnalité. Idéalement, chaque slice a ses propres entités ou modèles et n’interagit pas directement avec les autres slices. Le couplage technique (ex: appel base de données) n’est pas nécessairement inversé comme en Clean Architecture – une tranche peut très bien appeler directement un ORM ou une requête SQL si c’est le plus simple – mais ce choix n’affecte que cette tranche précise. En réduisant la portée d’influence du code, Vertical Slice fait pencher la balance vers une multitude de petits couplages locaux plutôt qu’un grand couplage central. Le risque est bien sûr d’introduire du <strong>couplage dupliqué</strong> (plusieurs slices dépendant des mêmes concepts implémentés en parallèle), d’où l’importance de bien délimiter les frontières. On peut résumer en disant que Clean Architecture vise un <strong>faible couplage “vertical” (technique)</strong>, tandis que Vertical Slice vise un <strong>faible couplage “horizontal” (fonctionnel)</strong>. Les deux ne sont pas incompatibles, mais l’accent n’est pas mis au même endroit.</p><h3 id="scalabilité-du-code-et-de-larchitecture"><span class="mr-2">Scalabilité du code et de l’architecture</span><a href="#scalabilité-du-code-et-de-larchitecture" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Lorsqu’on parle de <strong>scalabilité</strong> ici, on entend la capacité de l’architecture à supporter la croissance de l’application (plus de fonctionnalités, plus de développeurs, plus de complexité) tout en restant maintenable.</p><p>Du côté de Clean Architecture, la structure en couches apporte une <strong>rigueur appréciable pour les projets de grande envergure</strong>. C’est une architecture éprouvée pour organiser des solutions <strong>complexes avec de nombreuses règles métier</strong> et de gros équipes. En séparant nettement le domaine, les cas d’utilisation et les détails techniques, on peut faire évoluer chacun de ces aspects indépendamment. Clean Architecture favorise la factorisation du code commun, ce qui évite l’effet boule de neige lors de changements globaux. Par exemple, si une règle métier impacte plusieurs cas d’utilisation, on la codera une fois dans le domaine (ou un service commun) plutôt que de devoir la répliquer. Ainsi, quand la complexité augmente, l’architecture en couches offre un cadre qui <strong>encaisse la montée en volume</strong> (avec cependant le compromis d’une complexité interne plus élevée et d’une courbe d’apprentissage pour les nouveaux développeurs). On note aussi que Clean Architecture améliore la <strong>maintenabilité et l’évolutivité</strong> du système sur le long terme, car les préoccupations sont bien isolées – ce qui peut justifier son investissement initial dans des projets appelés à grossir.</p><p>Du côté de Vertical Slice, la scalabilité se joue différemment. Ajouter de nouvelles fonctionnalités est très simple (comme évoqué, on ajoute du code neuf sans impacter l’existant), ce qui donne une impression de facilité pour <strong>faire croître le périmètre fonctionnel</strong>. De plus, plusieurs équipes peuvent contribuer en parallèle sur des slices différentes, ce qui <strong>scale bien humainement</strong> (moins de collisions de code). Beaucoup de projets web ou API croissent initialement plus vite avec ce modèle qu’avec une architecture hexagonale plus formelle. Cependant, plus l’application grossit, plus on accumule de slices – et les risques mentionnés de duplication ou d’incohérence peuvent augmenter exponentiellement. Sans discipline, une grosse base de code en Vertical Slices peut devenir difficile à maintenir si chaque tranche a implémenté sa version de la réalité. En outre, <strong>la gestion des fonctionnalités transverses</strong> (par ex. logging commun, transactions multi-slices, règles de validation globales) peut devenir ardue. En pratique, Vertical Slice peut tout à fait s’appliquer à de grands systèmes, mais souvent <strong>en combinaison avec d’autres patterns</strong> pour encadrer la complexité. Par exemple, on peut très bien imaginer un grand monolithe modulable où chaque module est un ensemble de vertical slices, tout en conservant un schéma de base commun et des infrastructures partagées. D’ailleurs, les architectes recommandent souvent de <strong>ne pas opposer frontalement Clean Architecture et Vertical Slice</strong>, mais d’envisager d’associer les deux dans un même projet. Par exemple, on peut structurer son code en vertical slices au sein de chaque couche d’un modèle hexagonal (features folders + interfaces de repo, etc.), ou utiliser Vertical Slice pour la partie application tandis que le domaine reste centralisé. Ces deux approches <strong>ne sont pas mutuellement exclusives</strong> et peuvent se compléter pour obtenir un système à la fois modulaire et consistant.</p><p><strong>En synthèse</strong>, Clean Architecture offre une colonne vertébrale solide pour les <strong>systèmes complexes et de long terme</strong>, tandis que Vertical Slice apporte de la <strong>légèreté et de la flexibilité pour le développement orienté fonctionnalité</strong>.</p><p>Le tableau ci-dessous résume quelques différences :</p><p>Voici une version restructurée, plus fluide et symétrique pour chaque point :</p><ul><li><strong>Principe directeur</strong> : Clean Architecture repose sur une organisation par couches avec des dépendances stables orientées vers le domaine. Vertical Slice se structure par fonctionnalités, avec une forte cohésion autour de chaque cas d’usage.<li><strong>Organisation du code</strong> : Clean Architecture répartit le code en couches séparées (domaine, application, infrastructure). Vertical Slice regroupe tout le code nécessaire à une fonctionnalité dans un même ensemble (commande, handler, modèles, etc.).<li><strong>Couplage</strong> : Clean Architecture vise un découplage fort vis-à-vis des détails techniques, mais centralise les fonctionnalités autour d’un modèle commun. Vertical Slice réduit le couplage entre fonctionnalités, en favorisant une autonomie locale, au prix potentiel d’une duplication.<li><strong>Échelle et complexité</strong> : Clean Architecture convient bien aux applications complexes ou d’envergure, avec une structure rigide mais robuste à long terme. Vertical Slice est plus adapté aux projets modulaires ou aux fonctionnalités isolées, avec un démarrage rapide mais qui demande un encadrement au fil de la croissance.</ul><p>Il n’y a pas de « gagnant » absolu : le choix dépend du contexte de votre projet. L’important est de comprendre ces différences pour appliquer le bon dosage. La section suivante illustre concrètement la structure Vertical Slice dans un projet .NET pour mieux ancrer ces concepts.</p><h2 id="exemple-de-projet-vertical-slice-en-net-c"><span class="mr-2">Exemple de projet Vertical Slice en .NET (C#)</span><a href="#exemple-de-projet-vertical-slice-en-net-c" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Pour rendre les choses plus concrètes, prenons un exemple d’application .NET utilisant l’architecture Vertical Slice. Imaginons une API pour gérer des commandes (<strong>Orders</strong>) dans un système e-commerce. Nous allons voir comment structurer le code par fonctionnalités, et comment s’articule l’utilisation de <strong>MediatR</strong>, des <strong>Commands</strong> et <strong>Queries</strong>.</p><h3 id="structure-par-fonctionnalités"><span class="mr-2">Structure par fonctionnalités</span><a href="#structure-par-fonctionnalités" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Supposons que notre API offre deux opérations principales pour les commandes : <strong>Créer une nouvelle commande</strong> (<strong>Create Order</strong>) et <strong>Obtenir les détails d’une commande</strong> (<strong>Get Order Details</strong>). En Vertical Slice, on va créer deux tranches séparées pour ces deux cas d’utilisation. La structure du projet pourrait ressembler à ceci :</p><div class="language-text highlighter-rouge"><div class="code-header"> <span data-label-text="Text"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copié!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre>📦 MonProjet.API
└── Features
    └── Orders
        ├── CreateOrder
        │   ├── CreateOrderCommand.cs       // Commande pour créer une commande
        │   └── CreateOrderHandler.cs       // Handler pour traiter la création
        └── GetOrderDetails
            ├── GetOrderDetailsQuery.cs    // Requête pour obtenir les détails
            └── GetOrderDetailsHandler.cs  // Handler pour traiter la requête
</pre></table></code></div></div><p>Dans ce schéma, tout ce qui concerne <strong>“Create Order”</strong> vit dans son propre dossier (sous <strong>Orders/CreateOrder</strong>), et pareil pour <strong>“Get Order Details”</strong>. On pourrait également avoir des sous-dossiers par agrégat ou entité principale (ici <strong>Orders</strong> regroupe les features liées aux commandes). L’idée est qu’en ouvrant le dossier d’une fonctionnalité, on retrouve <strong>toutes les pièces du puzzle</strong> pour cette fonctionnalité, plutôt que de devoir chercher dans un dossier Controllers, puis un dossier Services, puis Repository, etc.</p><h3 id="command-query-et-handler-avec-mediatr"><span class="mr-2">Command, Query et Handler avec MediatR</span><a href="#command-query-et-handler-avec-mediatr" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Voyons maintenant à quoi ressemblent les classes à l’intérieur d’une slice. Nous allons créer un <strong>Query</strong> pour la lecture des détails d’une commande, et une <strong>Command</strong> pour la création d’une commande. Nous utiliserons les interfaces de <strong>MediatR</strong> (<code class="language-plaintext highlighter-rouge">IRequest&lt;T&gt;</code> et <code class="language-plaintext highlighter-rouge">IRequestHandler&lt;TRequest, TResponse&gt;</code>) pour définir nos requêtes/commandes et leurs gestionnaires.</p><p><strong>Exemple : Lire les détails d’une commande (Query)</strong></p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copié!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre><td class="rouge-code"><pre><span class="c1">// DTO (Data Transfer Object) représentant le résultat renvoyé au client</span>
<span class="k">public</span> <span class="k">record</span> <span class="nc">OrderDto</span><span class="p">(</span><span class="kt">int</span> <span class="n">OrderId</span><span class="p">,</span> <span class="kt">string</span> <span class="n">ProductName</span><span class="p">,</span> <span class="kt">decimal</span> <span class="n">TotalAmount</span><span class="p">);</span>

<span class="c1">// Requête de lecture pour obtenir les détails d'une commande spécifique</span>
<span class="k">public</span> <span class="k">record</span> <span class="nc">GetOrderDetailsQuery</span><span class="p">(</span><span class="kt">int</span> <span class="n">OrderId</span><span class="p">)</span> <span class="p">:</span> <span class="n">IRequest</span><span class="p">&lt;</span><span class="n">OrderDto</span><span class="p">&gt;;</span>

<span class="c1">// Handler associé à la requête GetOrderDetailsQuery</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">GetOrderDetailsHandler</span> <span class="p">:</span> <span class="n">IRequestHandler</span><span class="p">&lt;</span><span class="n">GetOrderDetailsQuery</span><span class="p">,</span> <span class="n">OrderDto</span><span class="p">&gt;</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="k">readonly</span> <span class="n">IOrderRepository</span> <span class="n">_repository</span><span class="p">;</span>

    <span class="k">public</span> <span class="nf">GetOrderDetailsHandler</span><span class="p">(</span><span class="n">IOrderRepository</span> <span class="n">repository</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">_repository</span> <span class="p">=</span> <span class="n">repository</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">async</span> <span class="n">Task</span><span class="p">&lt;</span><span class="n">OrderDto</span><span class="p">&gt;</span> <span class="nf">Handle</span><span class="p">(</span><span class="n">GetOrderDetailsQuery</span> <span class="n">query</span><span class="p">,</span>
       <span class="n">CancellationToken</span> <span class="n">cancellationToken</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// Récupérer la commande depuis la base de données (ou autre source)</span>
        <span class="kt">var</span> <span class="n">order</span> <span class="p">=</span> <span class="k">await</span> <span class="n">_repository</span><span class="p">.</span><span class="nf">GetById</span><span class="p">(</span><span class="n">query</span><span class="p">.</span><span class="n">OrderId</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">order</span> <span class="k">is</span> <span class="k">null</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="k">null</span><span class="p">;</span> <span class="c1">// ou lever une exception NotFound, selon les besoins</span>
        <span class="p">}</span>

        <span class="c1">// Mapper les données de la commande vers le DTO de sortie</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">OrderDto</span><span class="p">(</span><span class="n">order</span><span class="p">.</span><span class="n">Id</span><span class="p">,</span> <span class="n">order</span><span class="p">.</span><span class="n">ProductName</span><span class="p">,</span> <span class="n">order</span><span class="p">.</span><span class="n">TotalAmount</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Dans cet extrait, <code class="language-plaintext highlighter-rouge">GetOrderDetailsQuery</code> est une simple classe (ici un <code class="language-plaintext highlighter-rouge">record</code>) qui porte les paramètres nécessaires (l’Id de la commande). Elle implémente <code class="language-plaintext highlighter-rouge">IRequest&lt;OrderDto&gt;</code> indiquant qu’elle attend une réponse de type <code class="language-plaintext highlighter-rouge">OrderDto</code>. Le <code class="language-plaintext highlighter-rouge">GetOrderDetailsHandler</code> contient la logique pour traiter la requête : typiquement, il va chercher la commande dans un dépôt (<code class="language-plaintext highlighter-rouge">IOrderRepository</code>) et convertir le résultat en DTO. Grâce à MediatR, ce handler sera automatiquement appelé lorsque nous enverrons un objet <code class="language-plaintext highlighter-rouge">GetOrderDetailsQuery</code> via le médiateur.</p><p><strong>Exemple : Créer une nouvelle commande (Command)</strong></p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copié!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre><td class="rouge-code"><pre><span class="c1">// Commande pour créer une nouvelle commande</span>
<span class="k">public</span> <span class="k">record</span> <span class="nc">CreateOrderCommand</span><span class="p">(</span><span class="kt">int</span> <span class="n">ProductId</span><span class="p">,</span> <span class="kt">int</span> <span class="n">Quantity</span><span class="p">)</span> <span class="p">:</span> <span class="n">IRequest</span><span class="p">&lt;</span><span class="n">OrderDto</span><span class="p">&gt;;</span>

<span class="c1">// Handler associé à la commande CreateOrderCommand</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">CreateOrderHandler</span> <span class="p">:</span> <span class="n">IRequestHandler</span><span class="p">&lt;</span><span class="n">CreateOrderCommand</span><span class="p">,</span> <span class="n">OrderDto</span><span class="p">&gt;</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="k">readonly</span> <span class="n">IOrderRepository</span> <span class="n">_repository</span><span class="p">;</span>  <span class="c1">// on peut imaginer qu'on utilise un dépôt ou un service de domaine</span>

    <span class="k">public</span> <span class="nf">CreateOrderHandler</span><span class="p">(</span><span class="n">IOrderRepository</span> <span class="n">repository</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">_repository</span> <span class="p">=</span> <span class="n">repository</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">async</span> <span class="n">Task</span><span class="p">&lt;</span><span class="n">OrderDto</span><span class="p">&gt;</span> <span class="nf">Handle</span><span class="p">(</span><span class="n">CreateOrderCommand</span> <span class="n">command</span><span class="p">,</span>
       <span class="n">CancellationToken</span> <span class="n">cancellationToken</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// Logique métier simplifiée: créer l'entité Order et l'enregistrer</span>
        <span class="kt">var</span> <span class="n">newOrder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Order</span> 
        <span class="p">{</span>
            <span class="n">ProductId</span> <span class="p">=</span> <span class="n">command</span><span class="p">.</span><span class="n">ProductId</span><span class="p">,</span>
            <span class="n">Quantity</span> <span class="p">=</span> <span class="n">command</span><span class="p">.</span><span class="n">Quantity</span><span class="p">,</span>
            <span class="c1">// ... (autres initialisations, calcul du total etc.)</span>
        <span class="p">};</span>

        <span class="k">await</span> <span class="n">_repository</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="n">newOrder</span><span class="p">);</span>

        <span class="c1">// Retourner un DTO représentant la commande créée</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">OrderDto</span><span class="p">(</span><span class="n">newOrder</span><span class="p">.</span><span class="n">Id</span><span class="p">,</span> <span class="n">newOrder</span><span class="p">.</span><span class="n">ProductName</span><span class="p">,</span> <span class="n">newOrder</span><span class="p">.</span><span class="n">TotalAmount</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Ici, <code class="language-plaintext highlighter-rouge">CreateOrderCommand</code> encapsule les informations nécessaires pour créer une commande (par ex. identifiant du produit, quantité). Le <code class="language-plaintext highlighter-rouge">CreateOrderHandler</code> effectue la création : dans une vraie application, il pourrait appeler des règles de domaine (vérifier le stock, calculer le montant, etc.) et utiliser le dépôt pour sauvegarder la commande en base. À la fin, il retourne un <code class="language-plaintext highlighter-rouge">OrderDto</code> avec les détails de la nouvelle commande. Remarquez que toute la logique spécifique à “créer une commande” est confinée dans ce handler – si demain une règle change (par ex. limiter la quantité maximale), on viendra l’implémenter ici sans impacter d’autres features.</p><p><strong>Intégration dans un contrôleur ou un endpoint :</strong> Grâce à MediatR, nos controllers restent très simples. Par exemple, un contrôleur Web API pour créer une commande pourrait ressembler à :</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copié!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre><td class="rouge-code"><pre><span class="p">[</span><span class="n">ApiController</span><span class="p">]</span>
<span class="p">[</span><span class="nf">Route</span><span class="p">(</span><span class="s">"api/[controller]"</span><span class="p">)]</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">OrdersController</span> <span class="p">:</span> <span class="n">ControllerBase</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="k">readonly</span> <span class="n">IMediator</span> <span class="n">_mediator</span><span class="p">;</span>

    <span class="k">public</span> <span class="nf">OrdersController</span><span class="p">(</span><span class="n">IMediator</span> <span class="n">mediator</span><span class="p">)</span>
    <span class="p">{</span> 
        <span class="n">_mediator</span> <span class="p">=</span> <span class="n">mediator</span><span class="p">;</span> 
    <span class="p">}</span>

    <span class="p">[</span><span class="n">HttpPost</span><span class="p">]</span>
    <span class="k">public</span> <span class="k">async</span> <span class="n">Task</span><span class="p">&lt;</span><span class="n">IActionResult</span><span class="p">&gt;</span> <span class="nf">CreateOrder</span><span class="p">([</span><span class="n">FromBody</span><span class="p">]</span> <span class="n">CreateOrderCommand</span> <span class="n">command</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">OrderDto</span> <span class="n">result</span> <span class="p">=</span> <span class="k">await</span> <span class="n">_mediator</span><span class="p">.</span><span class="nf">Send</span><span class="p">(</span><span class="n">command</span><span class="p">);</span>
        <span class="k">return</span> <span class="nf">CreatedAtAction</span><span class="p">(</span><span class="s">"GetOrder"</span><span class="p">,</span> <span class="k">new</span> <span class="p">{</span> <span class="n">id</span> <span class="p">=</span> <span class="n">result</span><span class="p">.</span><span class="n">OrderId</span> <span class="p">},</span> <span class="n">result</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="p">[</span><span class="nf">HttpGet</span><span class="p">(</span><span class="s">"{id}"</span><span class="p">)]</span>
    <span class="k">public</span> <span class="k">async</span> <span class="n">Task</span><span class="p">&lt;</span><span class="n">IActionResult</span><span class="p">&gt;</span> <span class="nf">GetOrder</span><span class="p">(</span><span class="kt">int</span> <span class="n">id</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">OrderDto</span> <span class="n">resultat</span> <span class="p">=</span> <span class="k">await</span> <span class="n">_mediator</span><span class="p">.</span><span class="nf">Send</span><span class="p">(</span><span class="k">new</span> <span class="nf">GetOrderDetailsQuery</span><span class="p">(</span><span class="n">id</span><span class="p">));</span>

        <span class="k">return</span> <span class="n">resultat</span> <span class="k">is</span> <span class="k">null</span> <span class="p">?</span> <span class="nf">NotFound</span><span class="p">()</span> <span class="p">:</span> <span class="nf">Ok</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>On voit que le contrôleur ne contient quasiment aucune logique : il se contente de transmettre la commande/requête au médiateur (<code class="language-plaintext highlighter-rouge">_mediator.Send(...)</code>) et de retourner la réponse appropriée (ici un code 201 Created ou 200 OK). Toute la “vraie” logique est implémentée dans nos handlers, ce qui correspond bien à l’esprit Vertical Slice : <strong>chaque requête HTTP correspond à un use case géré par un handler dédié</strong>. Cette structure rend les controllers minces et faciles à maintenir, et déplace le poids de la logique dans les slices où elle est plus facile à tester.</p><h3 id="points-à-noter-dans-cet-exemple"><span class="mr-2">Points à noter dans cet exemple</span><a href="#points-à-noter-dans-cet-exemple" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>On a un fichier par requête/commande et un par handler, mais on aurait pu regrouper la commande et son handler dans le même fichier (c’est une question de style). L’important est que la séparation est faite par cas d’utilisation et non par type d’objet.<li>Les classes <code class="language-plaintext highlighter-rouge">OrderDto</code>, <code class="language-plaintext highlighter-rouge">CreateOrderCommand</code>, <code class="language-plaintext highlighter-rouge">GetOrderDetailsQuery</code>, etc., sont <strong>spécifiques à leur slice</strong>. Aucune d’entre elles n’est utilisée en dehors de la fonctionnalité en question. Cela garantit que modifier l’une n’impactera pas d’autres parties du système par effet de bord inattendu.<li>Chaque handler pourrait avoir ses propres <strong>validations</strong> (par exemple, vérifier que <code class="language-plaintext highlighter-rouge">Quantity</code> est positive dans <code class="language-plaintext highlighter-rouge">CreateOrderHandler</code>). On pourrait utiliser des <em>Behavior</em> MediatR ou des filtres, mais souvent chaque slice gère ses validations soit inline, soit via des composants dédiés (par exemple un <code class="language-plaintext highlighter-rouge">FluentValidation</code> validator par commande). L’essentiel est que, là encore, la validation métier d’un use case vit à côté de ce use case.<li>On peut tout à fait utiliser des patterns de conception à l’intérieur d’un vertical slice. Par exemple, si la logique de création de commande devenait très complexe, on pourrait introduire une couche de <strong>domaine</strong> (entité <strong>Order</strong> avec des méthodes, service de domaine, etc.) <strong>au sein</strong> de cette slice. Vertical Slice n’interdit pas d’écrire du code propre ! Il dit juste : « ne le rends pas <strong>partagé</strong> d’office si ce n’est pas nécessaire ». Vous pouvez donc combiner Vertical Slice et principes DDD/Clean à un niveau fin, en créant une mini-architecture hexagonale interne à une tranche si le besoin s’en fait sentir.</ul><h2 id="réflexion-et-questions-ouvertes"><span class="mr-2">Réflexion et questions ouvertes</span><a href="#réflexion-et-questions-ouvertes" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Nous avons exploré ce qu’est l’architecture Vertical Slice, ses atouts et ses faiblesses, ainsi que son positionnement vis-à-vis de l’architecture Clean. Pour conclure cet article, il convient d’insister qu’il n’existe pas de solution universelle – <strong>le choix dépend de votre contexte spécifique</strong>. Voici quelques questions ouvertes pour alimenter votre réflexion et vous aider à évaluer la pertinence de Vertical Slice pour votre projet :</p><ul><li><strong>Vos fonctionnalités sont-elles réellement indépendantes ?</strong> Partagez-vous beaucoup de règles métier et de données entre différentes parties de l’application, ou bien pouvez-vous facilement isoler des <strong>slices</strong> sans créer de doublons massifs ? Si votre domaine est très connecté, une architecture par couches pourrait mieux convenir. Si au contraire vous pouvez dessiner des frontières nettes, Vertical Slice peut apporter de la clarté.<li><strong>Quelle complexité anticipez-vous à long terme ?</strong> S’il s’agit d’un petit service ou d’un module simple, Vertical Slice vous fera gagner du temps et de la souplesse. En revanche, pour un produit stratégique qui va évoluer sur des années avec de nombreuses fonctionnalités, envisagez-vous que l’absence d’un modèle central puisse devenir un frein (duplication, incohérences) ? Faut-il prévoir une combinaison d’approches pour grandir sereinement ?<li><strong>Quelle importance accordez-vous à la réutilisation et aux abstractions ?</strong> Préférez-vous du code dupliqué mais simple et lisible, ou une factorisation poussée quitte à introduire des couches d’abstraction supplémentaires ? La première approche favorise Vertical Slice, la seconde s’aligne plus avec Clean/DDD. En fonction de votre priorité (rapidité de développement vs. rationalisation du code), l’une ou l’autre approche prendra l’avantage.<li><strong>Votre équipe et votre organisation sont-elles prêtes ?</strong> Considérez le niveau d’expérience de vos développeurs et la structure de votre équipe. Sont-ils à l’aise pour évoluer sans le filet d’une architecture standard ? Vont-ils suivre des conventions communes pour ne pas que chaque slice devienne un microcosme isolé ? Avez-vous les outils pour documenter et surveiller la cohérence de l’ensemble ? L’architecture Vertical Slice demande une certaine discipline dans un contexte d’équipe pour éviter l’effet « tour de Babel » où chacun code dans son coin. À l’inverse, une équipe responsable et bien synchronisée pourra prospérer grâce à la liberté qu’elle offre.</ul><p>En répondant à ces questions, vous serez en mesure de peser le <strong>pour et le contre</strong> de l’architecture Vertical Slice dans votre cas particulier. N’hésitez pas à expérimenter à petite échelle, voire à combiner des approches (comme structurer votre code en slices tout en conservant un noyau de domaine commun pour les invariants critiques). L’important est de choisir une architecture qui <strong>sert au mieux les besoins de votre projet et de votre équipe</strong> – que ce soit Vertical Slice, Clean Architecture, une combinaison des deux, ou toute autre variante architecturale. Après tout, une architecture n’est réussie que si elle vous permet de livrer un logiciel de qualité, maintenable et évolutif, dans les délais et avec le sourire de l’équipe 😊.</p><p>👉 Pour approfondir la réflexion et découvrir un point de vue éclairant sur le sujet, je vous recommande vivement la vidéo de Milan Jovanović.</p><iframe width="740" height="473" src="https://www.youtube.com/embed/Az4Z0HJYl-U?si=5irssXM9jNAyxTVM" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen=""></iframe></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/architecture/'>architecture</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> Cet article est sous licence <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> par l'auteur.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Partager</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Architecture%20Vertical%20Slice%20dans%20l%E2%80%99%C3%A9cosyst%C3%A8me%20.NET%20-%20CodeWithFrenchy&url=https%3A%2F%2Fcodewithfrenchy.github.io%2F%2Fposts%2Fvertical-slice-architecture%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.linkedin.com/sharing/share-offsite/?url=https%3A%2F%2Fcodewithfrenchy.github.io%2F%2Fposts%2Fvertical-slice-architecture%2F" data-toggle="tooltip" data-placement="top" title="Linkedin" target="_blank" rel="noopener" aria-label="Linkedin"> <i class="fa-fw fab fa-linkedin"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Architecture%20Vertical%20Slice%20dans%20l%E2%80%99%C3%A9cosyst%C3%A8me%20.NET%20-%20CodeWithFrenchy&u=https%3A%2F%2Fcodewithfrenchy.github.io%2F%2Fposts%2Fvertical-slice-architecture%2F" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copier le lien" data-title-succeed="Lien copié avec succès!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Récemment mis à jour</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/performances-jsonserializeroptions-singleton/">Amélioration des performances en utilisant JsonSerializerOptions en singleton</a><li><a href="/posts/source-generator-dotnet/">Les Générateurs de source</a><li><a href="/posts/guid-versus-id/">GUID vs ID auto-incrémenté - dilemme et solutions en environnement .NET distribué</a><li><a href="/posts/introduction-k6/">Introduction à K6</a><li><a href="/posts/redis-change-licence/">Redis change de licence ! Quelles répercussions pour les développeurs et les entreprises ?</a></ul></div><div id="access-tags"><div class="panel-heading">Tags tendance</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/dotnet/">dotnet</a> <a class="post-tag" href="/tags/conference/">conference</a> <a class="post-tag" href="/tags/essais/">essais</a> <a class="post-tag" href="/tags/source-generator/">source-generator</a> <a class="post-tag" href="/tags/aspnet-core/">aspnet-core</a> <a class="post-tag" href="/tags/fluentassertions/">fluentassertions</a> <a class="post-tag" href="/tags/fluentvalidation/">fluentvalidation</a> <a class="post-tag" href="/tags/k6/">k6</a> <a class="post-tag" href="/tags/mapperly/">mapperly</a> <a class="post-tag" href="/tags/testcontainers/">testcontainers</a></div></div></div><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">Contenu</div><nav id="toc"></nav></div><script src="https://cdn.jsdelivr.net/npm/tocbot@4.20.1/dist/tocbot.min.js"></script></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4 mt-5"><div id="related-posts" class="mb-2 mb-sm-4"><h3 class="pt-2 mb-4 ml-1" data-toc-skip>Autres lectures</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/quand-utiliser-architecture-microservices/"><div class="card-body"> <em class="small" data-ts="1757376000" data-df="DD/MM/YYYY" > 08/09/2025 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Faut-il vraiment adopter une architecture microservices</h3><div class="text-muted small"><p> Préambule “On part en microservices ou on reste monolithique ?” C’est une des questions les plus posées et les moins bien tranchées du monde logiciel. Une question qui revient à chaque projet...</p></div></div></a></div><div class="card"> <a href="/posts/utilisation-design-patterns/"><div class="card-body"> <em class="small" data-ts="1758549600" data-df="DD/MM/YYYY" > 22/09/2025 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Les design patterns - les bons Legos pour vos applications .NET</h3><div class="text-muted small"><p> Introduction : Ne réinventez pas la roue, assemblez les Legos En conception logicielle, un design pattern (ou patron de conception) est une solution éprouvée à un problème de conception récurrent....</p></div></div></a></div><div class="card"> <a href="/posts/concevoir-maintenir-application-performante-dotnet/"><div class="card-body"> <em class="small" data-ts="1761001200" data-df="DD/MM/YYYY" > 20/10/2025 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Concevoir et maintenir des applications microservices performantes en .NET</h3><div class="text-muted small"><p> La performance logicielle ne doit pas être une réflexion après coup : elle se conçoit dès le départ et se cultive tout au long de la vie du système. Dans cet article, nous explorons comment s’outil...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/changements-licences-ecosysteme-dotnet/" class="btn btn-outline-primary" prompt="Plus ancien"><p>Changements de licences dans l’écosystème .NET – quelles implications ?</p></a> <a href="/posts/quand-utiliser-architecture-microservices/" class="btn btn-outline-primary" prompt="Plus récent"><p>Faut-il vraiment adopter une architecture microservices</p></a></div></div></div></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Tags tendance</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/dotnet/">dotnet</a> <a class="post-tag" href="/tags/conference/">conference</a> <a class="post-tag" href="/tags/essais/">essais</a> <a class="post-tag" href="/tags/source-generator/">source-generator</a> <a class="post-tag" href="/tags/aspnet-core/">aspnet-core</a> <a class="post-tag" href="/tags/fluentassertions/">fluentassertions</a> <a class="post-tag" href="/tags/fluentvalidation/">fluentvalidation</a> <a class="post-tag" href="/tags/k6/">k6</a> <a class="post-tag" href="/tags/mapperly/">mapperly</a> <a class="post-tag" href="/tags/testcontainers/">testcontainers</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><footer><div class="container pl-lg-4 pr-lg-4"><div class="d-flex justify-content-between align-items-center text-muted ml-md-3 mr-md-3"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://twitter.com/alexis35115">Alexis Garon-Michaud</a>. <span data-toggle="tooltip" data-placement="top" title="Sauf mention contraire, les articles de ce site sont publiés sous licence sous la licence Creative Commons Attribution 4.0 International (CC BY 4.0) par l'auteur.">Certains droits réservés.</span></p></div><div class="footer-right"><p class="mb-0">Propulsé par <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> avec le thème <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a></p></div></div></div></footer><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oups! Aucun résultat trouvé.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lazysizes@5.3.2/lazysizes.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/fr.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/unregister.js"></script>
