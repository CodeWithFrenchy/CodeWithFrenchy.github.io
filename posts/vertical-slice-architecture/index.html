<!DOCTYPE html><html lang="fr-FR" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="theme-color" media="(prefers-color-scheme: light)" content="#f7f7f7"><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1e"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="viewport" content="width=device-width, user-scalable=no initial-scale=1, shrink-to-fit=no, viewport-fit=cover" ><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="Architecture Vertical Slice dans lâ€™Ã©cosystÃ¨me .NET" /><meta property="og:locale" content="fr_FR" /><meta name="description" content="Lâ€™architecture Vertical Slice (ou architecture en tranches verticales) est une approche de conception logicielle qui consiste Ã  organiser le code par fonctionnalitÃ©s verticales plutÃ´t que par couches techniques. Autrement dit, chaque fonctionnalitÃ© de lâ€™application est implÃ©mentÃ©e de bout en bout dans une tranche (un slice) comprenant tous les aspects nÃ©cessaires : interface utilisateur, logique mÃ©tier et accÃ¨s aux donnÃ©es. Chaque tranche verticale est autonome et correspond Ã  un cas dâ€™utilisation distinct, ce qui favorise un dÃ©veloppement modulaire centrÃ© sur les fonctionnalitÃ©s. En .NET, cette approche sâ€™accompagne souvent du patron CQRS (Command Query Responsibility Segregation) : on sÃ©pare les opÃ©rations de lecture (Query) de celles dâ€™Ã©criture (Command) et on les traite diffÃ©remment. La bibliothÃ¨que MediatR est frÃ©quemment utilisÃ©e pour mettre en Å“uvre ce style â€“ elle agit comme un mÃ©diateur qui envoie chaque commande ou requÃªte vers son gestionnaire (handler) dÃ©diÃ©, permettant de dÃ©coupler lâ€™Ã©metteur de la requÃªte de son traitement." /><meta property="og:description" content="Lâ€™architecture Vertical Slice (ou architecture en tranches verticales) est une approche de conception logicielle qui consiste Ã  organiser le code par fonctionnalitÃ©s verticales plutÃ´t que par couches techniques. Autrement dit, chaque fonctionnalitÃ© de lâ€™application est implÃ©mentÃ©e de bout en bout dans une tranche (un slice) comprenant tous les aspects nÃ©cessaires : interface utilisateur, logique mÃ©tier et accÃ¨s aux donnÃ©es. Chaque tranche verticale est autonome et correspond Ã  un cas dâ€™utilisation distinct, ce qui favorise un dÃ©veloppement modulaire centrÃ© sur les fonctionnalitÃ©s. En .NET, cette approche sâ€™accompagne souvent du patron CQRS (Command Query Responsibility Segregation) : on sÃ©pare les opÃ©rations de lecture (Query) de celles dâ€™Ã©criture (Command) et on les traite diffÃ©remment. La bibliothÃ¨que MediatR est frÃ©quemment utilisÃ©e pour mettre en Å“uvre ce style â€“ elle agit comme un mÃ©diateur qui envoie chaque commande ou requÃªte vers son gestionnaire (handler) dÃ©diÃ©, permettant de dÃ©coupler lâ€™Ã©metteur de la requÃªte de son traitement." /><link rel="canonical" href="https://codewithfrenchy.github.io//posts/vertical-slice-architecture/" /><meta property="og:url" content="https://codewithfrenchy.github.io//posts/vertical-slice-architecture/" /><meta property="og:site_name" content="CodeWithFrenchy" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2025-06-29T20:00:00-04:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Architecture Vertical Slice dans lâ€™Ã©cosystÃ¨me .NET" /><meta name="twitter:site" content="@alexis35115" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2025-06-29T20:00:00-04:00","datePublished":"2025-06-29T20:00:00-04:00","description":"Lâ€™architecture Vertical Slice (ou architecture en tranches verticales) est une approche de conception logicielle qui consiste Ã  organiser le code par fonctionnalitÃ©s verticales plutÃ´t que par couches techniques. Autrement dit, chaque fonctionnalitÃ© de lâ€™application est implÃ©mentÃ©e de bout en bout dans une tranche (un slice) comprenant tous les aspects nÃ©cessaires : interface utilisateur, logique mÃ©tier et accÃ¨s aux donnÃ©es. Chaque tranche verticale est autonome et correspond Ã  un cas dâ€™utilisation distinct, ce qui favorise un dÃ©veloppement modulaire centrÃ© sur les fonctionnalitÃ©s. En .NET, cette approche sâ€™accompagne souvent du patron CQRS (Command Query Responsibility Segregation) : on sÃ©pare les opÃ©rations de lecture (Query) de celles dâ€™Ã©criture (Command) et on les traite diffÃ©remment. La bibliothÃ¨que MediatR est frÃ©quemment utilisÃ©e pour mettre en Å“uvre ce style â€“ elle agit comme un mÃ©diateur qui envoie chaque commande ou requÃªte vers son gestionnaire (handler) dÃ©diÃ©, permettant de dÃ©coupler lâ€™Ã©metteur de la requÃªte de son traitement.","headline":"Architecture Vertical Slice dans lâ€™Ã©cosystÃ¨me .NET","mainEntityOfPage":{"@type":"WebPage","@id":"https://codewithfrenchy.github.io//posts/vertical-slice-architecture/"},"url":"https://codewithfrenchy.github.io//posts/vertical-slice-architecture/"}</script><title>Architecture Vertical Slice dans lâ€™Ã©cosystÃ¨me .NET | CodeWithFrenchy</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="CodeWithFrenchy"><meta name="application-name" content="CodeWithFrenchy"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tocbot@4.20.1/dist/tocbot.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener('change', () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.notify(); } /* flipMode() */ } /* ModeToggle */ const modeToggle = new ModeToggle(); </script><body data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" class="mx-auto"> <img src="https://avatars.githubusercontent.com/u/53872142?s=400&u=53187283fe05254234a3890e2b44134f96e3a833&v=4" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title"> <a href="/">CodeWithFrenchy</a></div><div class="site-subtitle font-italic">Architecte logiciel, audacieux et fermier</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>ACCUEIL</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATÃ‰GORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>Ã€ PROPOS DE</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/alexis35115" aria-label="github" target="_blank" rel="noopener noreferrer"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/alexis35115" aria-label="twitter" target="_blank" rel="noopener noreferrer"> <i class="fab fa-twitter"></i> </a> <a href="https://www.linkedin.com/in/alexis-garon-michaud-a59643219/" aria-label="linkedin" target="_blank" rel="noopener noreferrer"> <i class="fab fa-linkedin"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <span id="breadcrumb"> <span> <a href="/"> Accueil </a> </span> <span>Architecture Vertical Slice dans lâ€™Ã©cosystÃ¨me .NET</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Recherche..."> </span> <span id="search-cancel" >Annuler</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>Architecture Vertical Slice dans lâ€™Ã©cosystÃ¨me .NET</h1><div class="post-meta text-muted"> <span> PostÃ© <em class="" data-ts="1751241600" data-df="DD/MM/YYYY" data-toggle="tooltip" data-placement="bottom"> 29/06/2025 </em> </span><div class="d-flex justify-content-between"> <span> Par <em> <a href="https://twitter.com/alexis35115">Alexis Garon-Michaud</a> </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="5540 mots"> <em>30 min</em> Ã  lire</span></div></div></div><div class="post-content"><p>Lâ€™<strong>architecture Vertical Slice</strong> (ou <em>architecture en tranches verticales</em>) est une approche de conception logicielle qui consiste Ã  organiser le code par fonctionnalitÃ©s verticales plutÃ´t que par couches techniques. Autrement dit, chaque fonctionnalitÃ© de lâ€™application est implÃ©mentÃ©e <strong>de bout en bout</strong> dans une tranche (un <em>slice</em>) comprenant tous les aspects nÃ©cessaires : interface utilisateur, logique mÃ©tier et accÃ¨s aux donnÃ©es. Chaque tranche verticale est autonome et correspond Ã  un cas dâ€™utilisation distinct, ce qui favorise un dÃ©veloppement modulaire centrÃ© sur les fonctionnalitÃ©s. En .NET, cette approche sâ€™accompagne souvent du patron <strong>CQRS</strong> (<em>Command Query Responsibility Segregation</em>) : on sÃ©pare les opÃ©rations de lecture (<em>Query</em>) de celles dâ€™Ã©criture (<em>Command</em>) et on les traite diffÃ©remment. La bibliothÃ¨que <strong>MediatR</strong> est frÃ©quemment utilisÃ©e pour mettre en Å“uvre ce style â€“ elle agit comme un mÃ©diateur qui envoie chaque commande ou requÃªte vers son gestionnaire (handler) dÃ©diÃ©, permettant de dÃ©coupler lâ€™Ã©metteur de la requÃªte de son traitement.</p><h2 id="avantages-de-larchitecture-vertical-slice"><span class="mr-2">Avantages de lâ€™architecture Vertical Slice</span><a href="#avantages-de-larchitecture-vertical-slice" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li><strong>LisibilitÃ© et cohÃ©sion par fonctionnalitÃ© :</strong> Le code de chaque fonctionnalitÃ© est regroupÃ© au mÃªme endroit, ce qui le rend plus <strong>facile Ã  comprendre et Ã  maintenir</strong> quâ€™une base de code oÃ¹ les Ã©lÃ©ments dâ€™une mÃªme fonctionnalitÃ© sont dispersÃ©s entre plusieurs couches. Cette forte cohÃ©sion interne Ã  la tranche amÃ©liore la lisibilitÃ© : on peut se concentrer sur un <strong>use case</strong> Ã  la fois sans Ãªtre noyÃ© dans la complexitÃ© globale.<li><strong>DÃ©couplage des fonctionnalitÃ©s :</strong> Chaque tranche est <strong>indÃ©pendante des autres</strong>, ce qui rÃ©duit le couplage du systÃ¨me. Modifier ou ajouter une fonctionnalitÃ© impacte peu (voire pas du tout) les autres modules, minimisant les effets de bord. On obtient ainsi un systÃ¨me plus robuste face aux changements, chaque slice pouvant Ã©voluer isolÃ©ment.<li><strong>FacilitÃ© de test :</strong> Puisque la logique de chaque use case est isolÃ©e, on peut tester une tranche verticalement sans dÃ©pendre du reste de lâ€™application. Par exemple, il est simple dâ€™Ã©crire des tests unitaires pour un <em>handler</em> donnÃ© en simulant ses dÃ©pendances (bases de donnÃ©es, services externes, etc.), ce qui amÃ©liore la <strong>testabilitÃ©</strong> globale.<li><strong>DÃ©veloppement parallÃ¨le accÃ©lÃ©rÃ© :</strong> Les Ã©quipes peuvent travailler <strong>simultanÃ©ment sur diffÃ©rentes fonctionnalitÃ©s</strong> sans se marcher sur les pieds, Ã©tant donnÃ© que chaque slice est autonome. Ceci rÃ©duit Ã©galement les risques de conflits de merge et facilite lâ€™intÃ©gration du code produit par plusieurs dÃ©veloppeurs en parallÃ¨le. En grande Ã©quipe, segmenter le travail par vertical slices permet dâ€™accÃ©lÃ©rer le dÃ©veloppement en divisant le systÃ¨me en sous-problÃ¨mes indÃ©pendants.<li><strong>Ajout de fonctionnalitÃ©s simplifiÃ© :</strong> Lâ€™architecture Vertical Slice tend Ã  rendre lâ€™application <strong>extensible par addition plutÃ´t que par modification</strong>. Lâ€™ajout dâ€™une nouvelle fonctionnalitÃ© se traduit par la crÃ©ation dâ€™une nouvelle tranche (nouvelle requÃªte, nouveau handler, etc.) <strong>sans modifier du code existant</strong>, ce qui limite le risque de rÃ©gression. Cette propriÃ©tÃ© sâ€™aligne bien avec le principe <em>Open/Closed</em> â€“ le code en place est fermÃ© aux modifications intempestives, tandis que le systÃ¨me est ouvert Ã  de nouvelles extensions fonctionnelles.<li><strong>FlexibilitÃ© dâ€™implÃ©mentation :</strong> Chaque tranche peut adopter lâ€™approche technique la plus adaptÃ©e Ã  son cas sans impacter le reste du projet. Par exemple, une fonctionnalitÃ© trÃ¨s simple pourra se contenter dâ€™un traitement procÃ©dural direct (<em>transaction script</em>), tandis quâ€™une autre plus complexe pourrait utiliser des patterns de domaine riche â€“ le choix peut se faire au niveau de la slice elle-mÃªme. De mÃªme, chaque tranche pourrait interagir avec des ressources externes diffÃ©remment (base de donnÃ©es SQL, appel dâ€™un service tiers, etc.) sans casser une â€œarchitecture globaleâ€ figÃ©e. Cette souplesse permet de <strong>personnaliser la solution par fonctionnalitÃ©</strong> et dâ€™Ã©viter les abstractions ou couches supplÃ©mentaires inutiles au sein dâ€™une slice donnÃ©e.</ul><h2 id="inconvÃ©nients-et-limites-de-larchitecture-vertical-slice"><span class="mr-2">InconvÃ©nients et limites de lâ€™architecture Vertical Slice</span><a href="#inconvÃ©nients-et-limites-de-larchitecture-vertical-slice" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li><strong>Duplication de code (anti-DRY)Â :</strong> Ã€ force dâ€™isoler chaque fonctionnalitÃ©, on risque de <strong>rÃ©pÃ©ter du code commun</strong> dans plusieurs slices. Par exemple, des composants dâ€™infrastructure ou des routines similaires peuvent se retrouver dupliquÃ©s dans chaque module fonctionnel. Cette redondance va Ã  lâ€™encontre du principe <strong>DRY</strong> (<em>Donâ€™t Repeat Yourself</em>) et peut alourdir la maintenance : une correction de bug ou un changement commun doit Ãªtre rÃ©percutÃ© Ã  plusieurs endroits. En adoptant Vertical Slice, on accepte implicitement une certaine duplication en Ã©change dâ€™une meilleure isolation, mais il faut surveiller que cela ne devienne pas ingÃ©rable (dâ€™oÃ¹ le commentaire humoristique <strong>Â« Adieu DRY ! Â»</strong> souvent Ã©voquÃ© sur le sujet).<li><strong>Fragmentation et vision dâ€™ensemble rÃ©duiteÂ :</strong> Un risque de cette approche est de morceler lâ€™application en de nombreux petits <strong>silos</strong> de code. Si la modularitÃ© est poussÃ©e Ã  lâ€™extrÃªme sans garde-fou, on peut <strong>perdre la vue dâ€™ensemble du systÃ¨me</strong>. Chaque Ã©quipe ou dÃ©veloppeur pouvant structurer â€œsaâ€ tranche Ã  sa maniÃ¨re, lâ€™architecture globale peut manquer de cohÃ©rence. En lâ€™absence de conventions communes, le code peut diverger dâ€™une tranche Ã  lâ€™autre, rendant la maintenance transversale plus difficile. En outre, il devient dÃ©licat de comprendre le flux applicatif global puisque la logique est Ã©clatÃ©e en morceaux indÃ©pendants. Il est donc crucial de dÃ©finir des standards (structuration interne des slices, conventions de nommage, etc.) pour conserver une certaine homogÃ©nÃ©itÃ©.<li><strong>ComplexitÃ© de gestion des interactions :</strong> Lâ€™architecture Vertical Slice <strong>fonctionne mieux lorsque les fonctionnalitÃ©s sont bien dÃ©couplÃ©es</strong>. Si, en pratique, vos cas dâ€™utilisation ont de fortes interactions ou partagent des processus communs, la gestion peut devenir compliquÃ©e. Par exemple, une transaction mÃ©tier impliquant plusieurs slices distinctes sâ€™avÃ¨re difficile Ã  orchestrer proprement avec ce modÃ¨le. On devra alors multiplier les contournements (appels de slice A vers slice B, utilisation de librairies tierces pour orchestrer du workflow, etc.), ce qui peut complexifier le code et le rendre inmaintenable. En dâ€™autres termes, Vertical Slice nâ€™est <strong>pas pensÃ©e pour des fonctionnalitÃ©s Ã©troitement liÃ©es ou fortement interdÃ©pendantes</strong>, et forcer ce modÃ¨le dans de tels cas peut conduire Ã  une usine Ã  gaz.<li><strong>Performances et logique transversaleÂ :</strong> Dans la mÃªme veine, si une opÃ©ration utilisateur nÃ©cessite de coordonner plusieurs tranches verticales, lâ€™application peut souffrir dâ€™une certaine <strong>surcouche</strong>. Par exemple, devoir appeler successivement plusieurs handlers MediatR pour rÃ©aliser une action complexe peut introduire du surcoÃ»t (sÃ©rialisation/dÃ©sÃ©rialisation de messages, I/O multiples, etc.). Des scÃ©narios transactionnels touchant plusieurs slices seront difficiles Ã  optimiser. Certes, dans la plupart des applications ce surcoÃ»t restera nÃ©gligeable, mais sur un systÃ¨me Ã  trÃ¨s hautes performances ou trÃ¨s complexe, câ€™est un point Ã  considÃ©rer. Lâ€™architecture Vertical Slice est surtout plÃ©biscitÃ©e pour <strong>des projets modulaires plutÃ´t que pour de grosses transactions multi-domaines</strong> â€“ lorsquâ€™on tente de lâ€™appliquer Ã  des contextes quâ€™elle gÃ¨re mal (transactions distribuÃ©es, rÃ¨gles globales), on se heurte Ã  ses limites.</ul><p>En rÃ©sumÃ©, Vertical Slice amÃ©liore la <strong>lisibilitÃ© locale</strong> et la <strong>sÃ©paration des prÃ©occupations par fonctionnalitÃ©</strong>, au prix potentiel de duplications et dâ€™une <strong>fragmentation</strong> du codebase. Ces inconvÃ©nients ne sont pas rÃ©dhibitoires, mais requiÃ¨rent une vigilance et possiblement la mise en place de patterns complÃ©mentaires (par exemple un service commun pour factoriser du code partagÃ© si nÃ©cessaire, ou un cadre dâ€™architecture global minimal pour guider les devs).</p><h2 id="quand-utiliser-larchitecture-vertical-slice-"><span class="mr-2">Quand utiliser lâ€™architecture Vertical Slice ?</span><a href="#quand-utiliser-larchitecture-vertical-slice-" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Comme tout choix architectural, lâ€™approche Vertical Slice est plus ou moins adaptÃ©e selon le contexte. Voici des <strong>situations oÃ¹ son usage est recommandÃ©</strong>, et dâ€™autres oÃ¹ il lâ€™est <strong>moins</strong> :</p><h3 id="scÃ©narios-recommandÃ©s"><span class="mr-2">ScÃ©narios recommandÃ©s</span><a href="#scÃ©narios-recommandÃ©s" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li><strong>Applications modulaires ou microservicesÂ :</strong> Si votre application peut Ãªtre dÃ©coupÃ©e en <strong>modules indÃ©pendants</strong> (par exemple par domaine mÃ©tier ou <em>bounded context</em>), lâ€™architecture Vertical Slice sâ€™aligne naturellement. Chaque module ou microservice peut correspondre Ã  un ensemble de slices cohÃ©rents. On parle dâ€™ailleurs souvent de <em>modular monolith</em> pour dÃ©signer un monolithe structurÃ© en tranches verticales, qui offre une maintenabilitÃ© et une comprÃ©hension aisÃ©e du code. Dans ces architectures modulaires, chaque slice (ou ensemble de slices) reprÃ©sente un composant du systÃ¨me, facilement isolable pour le dÃ©veloppement, le dÃ©ploiement ou les tests.<li><strong>APIs REST simples ou projets de petite envergureÂ :</strong> Pour une <strong>petite application, un MVP ou un service avec des cas dâ€™utilisation simples</strong>, adopter dâ€™emblÃ©e une architecture hexagonale ou Clean complÃ¨te peut Ãªtre surdimensionnÃ©. Dans ces cas, lâ€™approche Vertical Slice apporte de la simplicitÃ©. On Ã©vite de crÃ©er plÃ©thore de couches et dâ€™abstractions alors que ce nâ€™est pas nÃ©cessaire pour un petit projet. En dâ€™autres termes, si vos besoins sont limitÃ©s et bien circonscrits, Â« bricoler quelque chose rapidement Â» en sÃ©parant par fonctionnalitÃ©s est tout Ã  fait raisonnable, et formaliser une couche de domaine complÃ¨te serait une perte de temps et dâ€™Ã©nergie. Vous irez plus vite tout en gardant une bonne organisation par <em>features</em>.<li><strong>DÃ©veloppement de nouvelles fonctionnalitÃ©s isolÃ©esÂ :</strong> MÃªme au sein dâ€™un projet existant, vous pouvez utiliser Vertical Slice pour des <strong>modules trÃ¨s spÃ©cifiques ou autonomes</strong>. Par exemple, lâ€™ajout dâ€™une petite API indÃ©pendante dans un grand systÃ¨me peut se faire sous forme de slice verticale sans impacter lâ€™architecture globale. De maniÃ¨re gÃ©nÃ©rale, si une fonctionnalitÃ© nâ€™a quasiment <strong>pas de dÃ©pendance sur le reste du systÃ¨me</strong>, la dÃ©velopper comme une unitÃ© verticale permet de la livrer rapidement et de faÃ§on propre.<li><strong>Ã‰quipes multiples sur des domaines diffÃ©rentsÂ :</strong> Si vous avez plusieurs Ã©quipes ou dÃ©veloppeurs qui travaillent en parallÃ¨le sur des <strong>sous-domaines diffÃ©rents</strong>, leur attribuer des vertical slices diffÃ©rentes peut rÃ©duire la collision de leurs travaux. Chaque Ã©quipe peut Ã©voluer dans â€œsonâ€ pÃ©rimÃ¨tre avec moins de risques de modifier du code utilisÃ© par les autres. Dans un contexte Agile, cela facilite la livraison continue de <em>features</em> indÃ©pendantes. (Il faut toutefois, comme mentionnÃ©, veiller Ã  garder une cohÃ©rence globale via des <em>guidelines</em> communes.)</ul><h3 id="scÃ©narios-moins-adaptÃ©s"><span class="mr-2">ScÃ©narios moins adaptÃ©s</span><a href="#scÃ©narios-moins-adaptÃ©s" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li><strong>Grand monolithe avec logique mÃ©tier partagÃ©eÂ :</strong> Si votre application forme un <strong>monolithe trÃ¨s complexe avec de nombreuses rÃ¨gles mÃ©tier transverses</strong>, une architecture strictement Vertical Slice risque de montrer ses limites. Par exemple, dans un systÃ¨me bancaire monolithique, des rÃ¨gles de gestion comme â€œun client ne peut pas dÃ©passer tel dÃ©couvertâ€ sâ€™appliquent Ã  <strong>plusieurs fonctionnalitÃ©s</strong>. Les implÃ©menter sÃ©parÃ©ment dans chaque tranche conduirait Ã  de la duplication et possiblement des incohÃ©rences. Dans ce genre de contexte, il est souvent prÃ©fÃ©rable dâ€™<strong>unifier la logique mÃ©tier centrale</strong> dans un modÃ¨le commun (par exexemple, via une couche Domaine partagÃ©e, comme le propose <em>Clean Architecture</em>). Lâ€™architecture â€œpropreâ€ et dÃ©rivÃ©es (Hexagonale, etc.) sont le fruit de dÃ©cennies dâ€™expÃ©rience pour bÃ¢tir des solutions complexes de grande taille, que ce soit en monolithe ou en microservices. Elles apportent un cadre rigoureux pour garantir la cohÃ©rence de la logique mÃ©tier Ã  travers tout le systÃ¨me. Ã€ lâ€™inverse, une approche Vertical Slice pure serait hasardeuse ici, car <strong>chaque slice devrait rÃ©implÃ©menter ou appeler ces rÃ¨gles communes</strong>, augmentant les risques dâ€™erreur.<li><strong>FonctionnalitÃ©s fortement couplÃ©es entre ellesÂ :</strong> Si vos cas dâ€™utilisation <strong>interagissent Ã©troitement</strong>, quâ€™ils doivent se coordonner ou partager beaucoup de donnÃ©es, une sÃ©paration stricte par slices peut Ãªtre artificielle. Par exemple, une opÃ©ration complexe pourrait nÃ©cessiter lâ€™enchaÃ®nement de plusieurs <em>slices</em> (ce qui revient Ã  simuler une transaction rÃ©partie). Ce genre dâ€™opÃ©ration est pÃ©nible Ã  rÃ©aliser proprement sans couche de service ou orchestrateur commun. Une architecture classique en couches permettrait ici de centraliser cette orchestration dans un service mÃ©tier, lÃ  oÃ¹ Vertical Slice ne fournit pas de rÃ©ponse Ã©vidente. En bref, plus vos fonctionnalitÃ©s sont interdÃ©pendantes, moins lâ€™architecture en tranches verticales est indiquÃ©e.<li><strong>Besoins de rÃ©utilisation du code mÃ©tierÂ :</strong> Dans certains projets, on cherche Ã  construire une <strong>bibliothÃ¨que ou un noyau de composants rÃ©utilisables</strong> (par exemple, un moteur de calcul utilisÃ© par plusieurs applications diffÃ©rentes). Dans ce cas, isoler complÃ¨tement chaque feature nâ€™est pas souhaitable : on veut au contraire factoriser le cÅ“ur commun. Vertical Slice, qui cloisonne le code par <em>use case</em>, nâ€™est pas orientÃ©e vers la mutualisation du code. Si lâ€™un de vos objectifs est de rÃ©utiliser une partie significative de la logique dans dâ€™autres contextes ou dâ€™exposer un modÃ¨le de domaine cohÃ©rent, une architecture du style Clean/DDD sera plus adaptÃ©e.<li><strong>Equipe dÃ©butante ou hÃ©tÃ©rogÃ¨ne sans guidelinesÂ :</strong> Enfin, il faut noter quâ€™une Ã©quipe peu expÃ©rimentÃ©e ou sans discipline pourrait <strong>dÃ©river</strong> avec une architecture Vertical Slice. Parce quâ€™elle impose moins de structure prÃ©dÃ©finie quâ€™une architecture en couches, chaque dÃ©veloppeur pourrait Ãªtre tentÃ© dâ€™organiser Â« Ã  sa sauce Â» sa slice. Sans concertation, le code risque de manquer dâ€™uniformitÃ© et la maintenance deviendra difficile. Pour une Ã©quipe junior, une architecture plus classique (Clean, couches MVC, etc.) sert parfois de filet de sÃ©curitÃ© grÃ¢ce Ã  son cadre clair. Cela ne disqualifie pas Vertical Slice, mais souligne lâ€™importance dâ€™un leadership technique pour guider sa mise en place dans un contexte dâ€™Ã©quipe moins expÃ©rimentÃ©e.</ul><p>En somme, lâ€™architecture Vertical Slice brille dans les contextes <strong>modulaires, Ã©volutifs et indÃ©pendants</strong>, ou lorsque lâ€™on veut <strong>aller vite sur des fonctionnalitÃ©s ciblÃ©es</strong>. En revanche, dÃ¨s quâ€™une forte mutualisation ou des invariants globaux sont nÃ©cessaires, il faut soit lâ€™adapter (en combinant avec dâ€™autres approches), soit envisager une architecture diffÃ©rente plus appropriÃ©e.</p><h2 id="comparaison-avec-le-clean-architecture"><span class="mr-2">Comparaison avec le Clean Architecture</span><a href="#comparaison-avec-le-clean-architecture" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Il est frÃ©quent dâ€™opposer Vertical Slice Ã  le <strong>Clean Architecture</strong> (architecture â€œpropreâ€ dâ€™aprÃ¨s Robert C. Martin), car ces deux approches structurent le code trÃ¨s diffÃ©remment. En rÃ©alitÃ©, elles poursuivent des objectifs communs (modularitÃ©, maintenabilitÃ©) mais via des principes distincts. Comparons-les selon quelques axes clÃ©s :</p><h3 id="principes-fondamentaux"><span class="mr-2">Principes fondamentaux</span><a href="#principes-fondamentaux" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Le Clean Architecture (ainsi que les architectures couches classiques, hexagonale, oignon, etc.) sâ€™articule autour de la <strong>sÃ©paration des prÃ©occupations horizontale</strong> et du respect de la <strong>dÃ©pendance inverse</strong>. Elle vise Ã  rendre le cÅ“ur du logiciel indÃ©pendant des dÃ©tails dâ€™implÃ©mentation. Par exemple, la logique mÃ©tier ne doit dÃ©pendre ni dâ€™un framework particulier, ni de la base de donnÃ©es, ni de lâ€™UI. ConcrÃ¨tement, on retrouve dans Clean Architecture des couches bien dÃ©finies (EntitÃ©s du domaine, Cas dâ€™usage, Interfaces dâ€™accÃ¨s aux donnÃ©es, etc.), avec la rÃ¨gle que les dÃ©pendances pointent vers lâ€™intÃ©rieur du cercle (vers le domaine). Lâ€™accent est mis sur la <strong>stabilitÃ© du modÃ¨le mÃ©tier</strong> : il sâ€™agit de protÃ©ger les rÃ¨gles de gestion des changements technologiques ou des caprices de lâ€™interface.</p><p>Lâ€™architecture Vertical Slice, de son cÃ´tÃ©, est guidÃ©e par la <strong>cohÃ©rence fonctionnelle</strong>. Son principe central est de <strong>grouper le code par fonctionnalitÃ© mÃ©tier</strong> de maniÃ¨re autonome. Chaque slice traite <strong>une et une seule fonctionnalitÃ©</strong> et embarque tout ce quâ€™il faut pour la rÃ©aliser. Lâ€™idÃ©e sous-jacente est dâ€™obtenir une forte cohÃ©sion interne (tout le code liÃ© Ã  un cas dâ€™utilisation est assemblÃ©) et une faible dÃ©pendance externe (peu de liens avec dâ€™autres parties du systÃ¨me). On couple â€œverticalementâ€ le long dâ€™un flux fonctionnel, plutÃ´t quâ€™horizontalement par type de composant. En adoptant Vertical Slice, on accepte un certain cloisonnement par <em>feature</em>, au bÃ©nÃ©fice dâ€™une flexibilitÃ© locale et dâ€™une simplicitÃ© de comprÃ©hension par cas dâ€™usage.</p><p>En rÃ©sumÃ©, <strong>Clean Architecture met lâ€™emphase sur le domaine et les abstractions stables</strong>, alors que <strong>Vertical Slice met lâ€™emphase sur les features et leur isolation mutuelle</strong>. Clean cherche Ã  Ã©liminer le couplage <strong>technique</strong> (UI, DB, frameworks) vis-Ã -vis du mÃ©tier, tandis que Vertical Slice cherche Ã  Ã©liminer le couplage <strong>fonctionnel</strong> entre les diffÃ©rentes parties du systÃ¨me.</p><h3 id="organisation-du-code-et-du-projet"><span class="mr-2">Organisation du code et du projet</span><a href="#organisation-du-code-et-du-projet" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Si on regarde lâ€™organisation concrÃ¨te dâ€™un projet .NET dans chaque approche, la diffÃ©rence saute aux yeux. <strong>Clean Architecture</strong> propose typiquement de structurer la solution en <strong>couches</strong> ou couches concentriques. On peut avoir par exemple des projets ou <em>folders</em> sÃ©parÃ©s pour : le domaine (entitÃ©s et interfaces), les cas dâ€™application (<em>use cases</em> ou services applicatifs), lâ€™interface (contrÃ´leurs API, UI) et lâ€™infrastructure (implÃ©mentations des dÃ©pÃ´ts, accÃ¨s BD, services externes). Chaque couche a une responsabilitÃ© spÃ©cifique et des dÃ©pendances restreintes (p.ex. lâ€™infrastructure dÃ©pend du domaine pour implÃ©menter ses interfaces, mais lâ€™inverse nâ€™est pas vrai). Cette organisation par couches apporte de la clartÃ© sur le rÃ´le de chaque classe, mais peut introduire de la verbositÃ© (de nombreux projets et fichiers pour une seule feature). Il faut naviguer entre plusieurs dossiers pour suivre le fil dâ€™une fonctionnalitÃ© donnÃ©e.</p><p><strong>Vertical Slice</strong>, Ã  lâ€™opposÃ©, organise le code par <strong>regroupement vertical</strong>. On va crÃ©er un dossier (ou un <em>namespace</em>) par fonctionnalitÃ© ou par module mÃ©tier, et y placer tous les Ã©lÃ©ments liÃ©s : contrÃ´leur API ou endpoint correspondant, classes de commande/requÃªte, handler MÃ©diatR, modÃ¨les spÃ©cifiques, etc.. Par exemple, au lieu dâ€™avoir un dossier Controllers avec tous les contrÃ´leurs de lâ€™application, on aura un dossier <code class="language-plaintext highlighter-rouge">Features</code> contenant des sous-dossiers par fonctionnalitÃ© : <strong>Produit</strong>, <strong>Commande</strong>, <strong>Client</strong>, etc., et Ã  lâ€™intÃ©rieur de chacun, les fichiers pour crÃ©er un produit, mettre Ã  jour un produit, etc. Chaque slice peut ainsi avoir <strong>ses propres modÃ¨les ou services internes</strong> sâ€™il en a besoin, sans impacter les autres slices. Cette organisation par feature facilite la localisation du code â€“ pour toucher Ã  une fonctionnalitÃ©, on sait exactement oÃ¹ aller â€“ mais rend plus difficile la rÃ©utilisation dâ€™une classe dâ€™une slice Ã  lâ€™autre (puisquâ€™a priori on Ã©vite de le faire). En pratique, il est courant quâ€™un projet Vertical Slice nâ€™ait quâ€™un ou deux assemblages (ex: un projet Web et Ã©ventuellement un projet pour les contrats), lÃ  oÃ¹ une Clean Architecture en comporte plusieurs pour sÃ©parer les couches. Cela rÃ©duit la complexitÃ© initiale (moins de projets .NET Ã  configurer), au prix dâ€™une sÃ©paration moins nette entre logique mÃ©tier et dÃ©tails techniques.</p><h3 id="couplage-et-dÃ©pendances"><span class="mr-2">Couplage et dÃ©pendances</span><a href="#couplage-et-dÃ©pendances" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>La <strong>Clean Architecture</strong> excelle Ã  rÃ©duire le couplage entre le domaine et les dÃ©tails dâ€™implÃ©mentation. GrÃ¢ce Ã  lâ€™inversion des dÃ©pendances, le cÅ“ur mÃ©tier ne â€œconnaÃ®tâ€ pas la base de donnÃ©es, ni le framework web utilisÃ©. Cela permet, par exemple, de changer de base de donnÃ©es ou de technologie dâ€™UI sans toucher au domaine (en thÃ©orie tout au moins). Le couplage est ainsi <strong>contrÃ´lÃ© et dirigÃ©</strong> : les couches haut-niveau dÃ©pendent de couches bas-niveau abstraites (interfaces), jamais lâ€™inverse. En revanche, <strong>les fonctionnalitÃ©s dans Clean Architecture sont couplÃ©es via le domaine commun</strong>. Par exemple, deux <em>use cases</em> diffÃ©rents vont manipuler la mÃªme classe <strong>Produit</strong> ou <strong>Commande</strong>. Cela garantit une logique uniforme, mais signifie aussi que ces <em>use cases</em> sont indirectement reliÃ©s : toute modification dans la structure dâ€™une entitÃ© du domaine peut impacter de multiples fonctionnalitÃ©s. Le couplage fonctionnel nâ€™est pas Ã©liminÃ©, il est centralisÃ© dans le domaine.</p><p>Lâ€™approche Vertical Slice, de son cÃ´tÃ©, cherche Ã  <strong>minimiser le couplage entre fonctionnalitÃ©s</strong> au profit dâ€™une <strong>forte cohÃ©sion interne</strong> Ã  chaque fonctionnalitÃ©. IdÃ©alement, chaque slice a ses propres entitÃ©s ou modÃ¨les et nâ€™interagit pas directement avec les autres slices. Le couplage technique (ex: appel base de donnÃ©es) nâ€™est pas nÃ©cessairement inversÃ© comme en Clean Architecture â€“ une tranche peut trÃ¨s bien appeler directement un ORM ou une requÃªte SQL si câ€™est le plus simple â€“ mais ce choix nâ€™affecte que cette tranche prÃ©cise. En rÃ©duisant la portÃ©e dâ€™influence du code, Vertical Slice fait pencher la balance vers une multitude de petits couplages locaux plutÃ´t quâ€™un grand couplage central. Le risque est bien sÃ»r dâ€™introduire du <strong>couplage dupliquÃ©</strong> (plusieurs slices dÃ©pendant des mÃªmes concepts implÃ©mentÃ©s en parallÃ¨le), dâ€™oÃ¹ lâ€™importance de bien dÃ©limiter les frontiÃ¨res. On peut rÃ©sumer en disant que Clean Architecture vise un <strong>faible couplage â€œverticalâ€ (technique)</strong>, tandis que Vertical Slice vise un <strong>faible couplage â€œhorizontalâ€ (fonctionnel)</strong>. Les deux ne sont pas incompatibles, mais lâ€™accent nâ€™est pas mis au mÃªme endroit.</p><h3 id="scalabilitÃ©-du-code-et-de-larchitecture"><span class="mr-2">ScalabilitÃ© du code et de lâ€™architecture</span><a href="#scalabilitÃ©-du-code-et-de-larchitecture" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Lorsquâ€™on parle de <strong>scalabilitÃ©</strong> ici, on entend la capacitÃ© de lâ€™architecture Ã  supporter la croissance de lâ€™application (plus de fonctionnalitÃ©s, plus de dÃ©veloppeurs, plus de complexitÃ©) tout en restant maintenable.</p><p>Du cÃ´tÃ© de Clean Architecture, la structure en couches apporte une <strong>rigueur apprÃ©ciable pour les projets de grande envergure</strong>. Câ€™est une architecture Ã©prouvÃ©e pour organiser des solutions <strong>complexes avec de nombreuses rÃ¨gles mÃ©tier</strong> et de gros Ã©quipes. En sÃ©parant nettement le domaine, les cas dâ€™utilisation et les dÃ©tails techniques, on peut faire Ã©voluer chacun de ces aspects indÃ©pendamment. Clean Architecture favorise la factorisation du code commun, ce qui Ã©vite lâ€™effet boule de neige lors de changements globaux. Par exemple, si une rÃ¨gle mÃ©tier impacte plusieurs cas dâ€™utilisation, on la codera une fois dans le domaine (ou un service commun) plutÃ´t que de devoir la rÃ©pliquer. Ainsi, quand la complexitÃ© augmente, lâ€™architecture en couches offre un cadre qui <strong>encaisse la montÃ©e en volume</strong> (avec cependant le compromis dâ€™une complexitÃ© interne plus Ã©levÃ©e et dâ€™une courbe dâ€™apprentissage pour les nouveaux dÃ©veloppeurs). On note aussi que Clean Architecture amÃ©liore la <strong>maintenabilitÃ© et lâ€™Ã©volutivitÃ©</strong> du systÃ¨me sur le long terme, car les prÃ©occupations sont bien isolÃ©es â€“ ce qui peut justifier son investissement initial dans des projets appelÃ©s Ã  grossir.</p><p>Du cÃ´tÃ© de Vertical Slice, la scalabilitÃ© se joue diffÃ©remment. Ajouter de nouvelles fonctionnalitÃ©s est trÃ¨s simple (comme Ã©voquÃ©, on ajoute du code neuf sans impacter lâ€™existant), ce qui donne une impression de facilitÃ© pour <strong>faire croÃ®tre le pÃ©rimÃ¨tre fonctionnel</strong>. De plus, plusieurs Ã©quipes peuvent contribuer en parallÃ¨le sur des slices diffÃ©rentes, ce qui <strong>scale bien humainement</strong> (moins de collisions de code). Beaucoup de projets web ou API croissent initialement plus vite avec ce modÃ¨le quâ€™avec une architecture hexagonale plus formelle. Cependant, plus lâ€™application grossit, plus on accumule de slices â€“ et les risques mentionnÃ©s de duplication ou dâ€™incohÃ©rence peuvent augmenter exponentiellement. Sans discipline, une grosse base de code en Vertical Slices peut devenir difficile Ã  maintenir si chaque tranche a implÃ©mentÃ© sa version de la rÃ©alitÃ©. En outre, <strong>la gestion des fonctionnalitÃ©s transverses</strong> (par ex. logging commun, transactions multi-slices, rÃ¨gles de validation globales) peut devenir ardue. En pratique, Vertical Slice peut tout Ã  fait sâ€™appliquer Ã  de grands systÃ¨mes, mais souvent <strong>en combinaison avec dâ€™autres patterns</strong> pour encadrer la complexitÃ©. Par exemple, on peut trÃ¨s bien imaginer un grand monolithe modulable oÃ¹ chaque module est un ensemble de vertical slices, tout en conservant un schÃ©ma de base commun et des infrastructures partagÃ©es. Dâ€™ailleurs, les architectes recommandent souvent de <strong>ne pas opposer frontalement Clean Architecture et Vertical Slice</strong>, mais dâ€™envisager dâ€™associer les deux dans un mÃªme projet. Par exemple, on peut structurer son code en vertical slices au sein de chaque couche dâ€™un modÃ¨le hexagonal (features folders + interfaces de repo, etc.), ou utiliser Vertical Slice pour la partie application tandis que le domaine reste centralisÃ©. Ces deux approches <strong>ne sont pas mutuellement exclusives</strong> et peuvent se complÃ©ter pour obtenir un systÃ¨me Ã  la fois modulaire et consistant.</p><p><strong>En synthÃ¨se</strong>, Clean Architecture offre une colonne vertÃ©brale solide pour les <strong>systÃ¨mes complexes et de long terme</strong>, tandis que Vertical Slice apporte de la <strong>lÃ©gÃ¨retÃ© et de la flexibilitÃ© pour le dÃ©veloppement orientÃ© fonctionnalitÃ©</strong>.</p><p>Le tableau ci-dessous rÃ©sume quelques diffÃ©rences :</p><p>Voici une version restructurÃ©e, plus fluide et symÃ©trique pour chaque point :</p><ul><li><strong>Principe directeur</strong> : Clean Architecture repose sur une organisation par couches avec des dÃ©pendances stables orientÃ©es vers le domaine. Vertical Slice se structure par fonctionnalitÃ©s, avec une forte cohÃ©sion autour de chaque cas dâ€™usage.<li><strong>Organisation du code</strong> : Clean Architecture rÃ©partit le code en couches sÃ©parÃ©es (domaine, application, infrastructure). Vertical Slice regroupe tout le code nÃ©cessaire Ã  une fonctionnalitÃ© dans un mÃªme ensemble (commande, handler, modÃ¨les, etc.).<li><strong>Couplage</strong> : Clean Architecture vise un dÃ©couplage fort vis-Ã -vis des dÃ©tails techniques, mais centralise les fonctionnalitÃ©s autour dâ€™un modÃ¨le commun. Vertical Slice rÃ©duit le couplage entre fonctionnalitÃ©s, en favorisant une autonomie locale, au prix potentiel dâ€™une duplication.<li><strong>Ã‰chelle et complexitÃ©</strong> : Clean Architecture convient bien aux applications complexes ou dâ€™envergure, avec une structure rigide mais robuste Ã  long terme. Vertical Slice est plus adaptÃ© aux projets modulaires ou aux fonctionnalitÃ©s isolÃ©es, avec un dÃ©marrage rapide mais qui demande un encadrement au fil de la croissance.</ul><p>Il nâ€™y a pas de Â« gagnant Â» absolu : le choix dÃ©pend du contexte de votre projet. Lâ€™important est de comprendre ces diffÃ©rences pour appliquer le bon dosage. La section suivante illustre concrÃ¨tement la structure Vertical Slice dans un projet .NET pour mieux ancrer ces concepts.</p><h2 id="exemple-de-projet-vertical-slice-en-net-c"><span class="mr-2">Exemple de projet Vertical Slice en .NET (C#)</span><a href="#exemple-de-projet-vertical-slice-en-net-c" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Pour rendre les choses plus concrÃ¨tes, prenons un exemple dâ€™application .NET utilisant lâ€™architecture Vertical Slice. Imaginons une API pour gÃ©rer des commandes (<strong>Orders</strong>) dans un systÃ¨me e-commerce. Nous allons voir comment structurer le code par fonctionnalitÃ©s, et comment sâ€™articule lâ€™utilisation de <strong>MediatR</strong>, des <strong>Commands</strong> et <strong>Queries</strong>.</p><h3 id="structure-par-fonctionnalitÃ©s"><span class="mr-2">Structure par fonctionnalitÃ©s</span><a href="#structure-par-fonctionnalitÃ©s" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Supposons que notre API offre deux opÃ©rations principales pour les commandes : <strong>CrÃ©er une nouvelle commande</strong> (<strong>Create Order</strong>) et <strong>Obtenir les dÃ©tails dâ€™une commande</strong> (<strong>Get Order Details</strong>). En Vertical Slice, on va crÃ©er deux tranches sÃ©parÃ©es pour ces deux cas dâ€™utilisation. La structure du projet pourrait ressembler Ã  ceci :</p><div class="language-text highlighter-rouge"><div class="code-header"> <span data-label-text="Text"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="CopiÃ©!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre>ğŸ“¦ MonProjet.API
â””â”€â”€ Features
    â””â”€â”€ Orders
        â”œâ”€â”€ CreateOrder
        â”‚   â”œâ”€â”€ CreateOrderCommand.cs       // Commande pour crÃ©er une commande
        â”‚   â””â”€â”€ CreateOrderHandler.cs       // Handler pour traiter la crÃ©ation
        â””â”€â”€ GetOrderDetails
            â”œâ”€â”€ GetOrderDetailsQuery.cs    // RequÃªte pour obtenir les dÃ©tails
            â””â”€â”€ GetOrderDetailsHandler.cs  // Handler pour traiter la requÃªte
</pre></table></code></div></div><p>Dans ce schÃ©ma, tout ce qui concerne <strong>â€œCreate Orderâ€</strong> vit dans son propre dossier (sous <strong>Orders/CreateOrder</strong>), et pareil pour <strong>â€œGet Order Detailsâ€</strong>. On pourrait Ã©galement avoir des sous-dossiers par agrÃ©gat ou entitÃ© principale (ici <strong>Orders</strong> regroupe les features liÃ©es aux commandes). Lâ€™idÃ©e est quâ€™en ouvrant le dossier dâ€™une fonctionnalitÃ©, on retrouve <strong>toutes les piÃ¨ces du puzzle</strong> pour cette fonctionnalitÃ©, plutÃ´t que de devoir chercher dans un dossier Controllers, puis un dossier Services, puis Repository, etc.</p><h3 id="command-query-et-handler-avec-mediatr"><span class="mr-2">Command, Query et Handler avec MediatR</span><a href="#command-query-et-handler-avec-mediatr" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Voyons maintenant Ã  quoi ressemblent les classes Ã  lâ€™intÃ©rieur dâ€™une slice. Nous allons crÃ©er un <strong>Query</strong> pour la lecture des dÃ©tails dâ€™une commande, et une <strong>Command</strong> pour la crÃ©ation dâ€™une commande. Nous utiliserons les interfaces de <strong>MediatR</strong> (<code class="language-plaintext highlighter-rouge">IRequest&lt;T&gt;</code> et <code class="language-plaintext highlighter-rouge">IRequestHandler&lt;TRequest, TResponse&gt;</code>) pour dÃ©finir nos requÃªtes/commandes et leurs gestionnaires.</p><p><strong>Exemple : Lire les dÃ©tails dâ€™une commande (Query)</strong></p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="CopiÃ©!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre><td class="rouge-code"><pre><span class="c1">// DTO (Data Transfer Object) reprÃ©sentant le rÃ©sultat renvoyÃ© au client</span>
<span class="k">public</span> <span class="k">record</span> <span class="nc">OrderDto</span><span class="p">(</span><span class="kt">int</span> <span class="n">OrderId</span><span class="p">,</span> <span class="kt">string</span> <span class="n">ProductName</span><span class="p">,</span> <span class="kt">decimal</span> <span class="n">TotalAmount</span><span class="p">);</span>

<span class="c1">// RequÃªte de lecture pour obtenir les dÃ©tails d'une commande spÃ©cifique</span>
<span class="k">public</span> <span class="k">record</span> <span class="nc">GetOrderDetailsQuery</span><span class="p">(</span><span class="kt">int</span> <span class="n">OrderId</span><span class="p">)</span> <span class="p">:</span> <span class="n">IRequest</span><span class="p">&lt;</span><span class="n">OrderDto</span><span class="p">&gt;;</span>

<span class="c1">// Handler associÃ© Ã  la requÃªte GetOrderDetailsQuery</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">GetOrderDetailsHandler</span> <span class="p">:</span> <span class="n">IRequestHandler</span><span class="p">&lt;</span><span class="n">GetOrderDetailsQuery</span><span class="p">,</span> <span class="n">OrderDto</span><span class="p">&gt;</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="k">readonly</span> <span class="n">IOrderRepository</span> <span class="n">_repository</span><span class="p">;</span>

    <span class="k">public</span> <span class="nf">GetOrderDetailsHandler</span><span class="p">(</span><span class="n">IOrderRepository</span> <span class="n">repository</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">_repository</span> <span class="p">=</span> <span class="n">repository</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">async</span> <span class="n">Task</span><span class="p">&lt;</span><span class="n">OrderDto</span><span class="p">&gt;</span> <span class="nf">Handle</span><span class="p">(</span><span class="n">GetOrderDetailsQuery</span> <span class="n">query</span><span class="p">,</span>
       <span class="n">CancellationToken</span> <span class="n">cancellationToken</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// RÃ©cupÃ©rer la commande depuis la base de donnÃ©es (ou autre source)</span>
        <span class="kt">var</span> <span class="n">order</span> <span class="p">=</span> <span class="k">await</span> <span class="n">_repository</span><span class="p">.</span><span class="nf">GetById</span><span class="p">(</span><span class="n">query</span><span class="p">.</span><span class="n">OrderId</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">order</span> <span class="k">is</span> <span class="k">null</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="k">null</span><span class="p">;</span> <span class="c1">// ou lever une exception NotFound, selon les besoins</span>
        <span class="p">}</span>

        <span class="c1">// Mapper les donnÃ©es de la commande vers le DTO de sortie</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">OrderDto</span><span class="p">(</span><span class="n">order</span><span class="p">.</span><span class="n">Id</span><span class="p">,</span> <span class="n">order</span><span class="p">.</span><span class="n">ProductName</span><span class="p">,</span> <span class="n">order</span><span class="p">.</span><span class="n">TotalAmount</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Dans cet extrait, <code class="language-plaintext highlighter-rouge">GetOrderDetailsQuery</code> est une simple classe (ici un <code class="language-plaintext highlighter-rouge">record</code>) qui porte les paramÃ¨tres nÃ©cessaires (lâ€™Id de la commande). Elle implÃ©mente <code class="language-plaintext highlighter-rouge">IRequest&lt;OrderDto&gt;</code> indiquant quâ€™elle attend une rÃ©ponse de type <code class="language-plaintext highlighter-rouge">OrderDto</code>. Le <code class="language-plaintext highlighter-rouge">GetOrderDetailsHandler</code> contient la logique pour traiter la requÃªte : typiquement, il va chercher la commande dans un dÃ©pÃ´t (<code class="language-plaintext highlighter-rouge">IOrderRepository</code>) et convertir le rÃ©sultat en DTO. GrÃ¢ce Ã  MediatR, ce handler sera automatiquement appelÃ© lorsque nous enverrons un objet <code class="language-plaintext highlighter-rouge">GetOrderDetailsQuery</code> via le mÃ©diateur.</p><p><strong>Exemple : CrÃ©er une nouvelle commande (Command)</strong></p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="CopiÃ©!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre><td class="rouge-code"><pre><span class="c1">// Commande pour crÃ©er une nouvelle commande</span>
<span class="k">public</span> <span class="k">record</span> <span class="nc">CreateOrderCommand</span><span class="p">(</span><span class="kt">int</span> <span class="n">ProductId</span><span class="p">,</span> <span class="kt">int</span> <span class="n">Quantity</span><span class="p">)</span> <span class="p">:</span> <span class="n">IRequest</span><span class="p">&lt;</span><span class="n">OrderDto</span><span class="p">&gt;;</span>

<span class="c1">// Handler associÃ© Ã  la commande CreateOrderCommand</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">CreateOrderHandler</span> <span class="p">:</span> <span class="n">IRequestHandler</span><span class="p">&lt;</span><span class="n">CreateOrderCommand</span><span class="p">,</span> <span class="n">OrderDto</span><span class="p">&gt;</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="k">readonly</span> <span class="n">IOrderRepository</span> <span class="n">_repository</span><span class="p">;</span>  <span class="c1">// on peut imaginer qu'on utilise un dÃ©pÃ´t ou un service de domaine</span>

    <span class="k">public</span> <span class="nf">CreateOrderHandler</span><span class="p">(</span><span class="n">IOrderRepository</span> <span class="n">repository</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">_repository</span> <span class="p">=</span> <span class="n">repository</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">async</span> <span class="n">Task</span><span class="p">&lt;</span><span class="n">OrderDto</span><span class="p">&gt;</span> <span class="nf">Handle</span><span class="p">(</span><span class="n">CreateOrderCommand</span> <span class="n">command</span><span class="p">,</span>
       <span class="n">CancellationToken</span> <span class="n">cancellationToken</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// Logique mÃ©tier simplifiÃ©e: crÃ©er l'entitÃ© Order et l'enregistrer</span>
        <span class="kt">var</span> <span class="n">newOrder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Order</span> 
        <span class="p">{</span>
            <span class="n">ProductId</span> <span class="p">=</span> <span class="n">command</span><span class="p">.</span><span class="n">ProductId</span><span class="p">,</span>
            <span class="n">Quantity</span> <span class="p">=</span> <span class="n">command</span><span class="p">.</span><span class="n">Quantity</span><span class="p">,</span>
            <span class="c1">// ... (autres initialisations, calcul du total etc.)</span>
        <span class="p">};</span>

        <span class="k">await</span> <span class="n">_repository</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="n">newOrder</span><span class="p">);</span>

        <span class="c1">// Retourner un DTO reprÃ©sentant la commande crÃ©Ã©e</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">OrderDto</span><span class="p">(</span><span class="n">newOrder</span><span class="p">.</span><span class="n">Id</span><span class="p">,</span> <span class="n">newOrder</span><span class="p">.</span><span class="n">ProductName</span><span class="p">,</span> <span class="n">newOrder</span><span class="p">.</span><span class="n">TotalAmount</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Ici, <code class="language-plaintext highlighter-rouge">CreateOrderCommand</code> encapsule les informations nÃ©cessaires pour crÃ©er une commande (par ex. identifiant du produit, quantitÃ©). Le <code class="language-plaintext highlighter-rouge">CreateOrderHandler</code> effectue la crÃ©ation : dans une vraie application, il pourrait appeler des rÃ¨gles de domaine (vÃ©rifier le stock, calculer le montant, etc.) et utiliser le dÃ©pÃ´t pour sauvegarder la commande en base. Ã€ la fin, il retourne un <code class="language-plaintext highlighter-rouge">OrderDto</code> avec les dÃ©tails de la nouvelle commande. Remarquez que toute la logique spÃ©cifique Ã  â€œcrÃ©er une commandeâ€ est confinÃ©e dans ce handler â€“ si demain une rÃ¨gle change (par ex. limiter la quantitÃ© maximale), on viendra lâ€™implÃ©menter ici sans impacter dâ€™autres features.</p><p><strong>IntÃ©gration dans un contrÃ´leur ou un endpoint :</strong> GrÃ¢ce Ã  MediatR, nos controllers restent trÃ¨s simples. Par exemple, un contrÃ´leur Web API pour crÃ©er une commande pourrait ressembler Ã  :</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="CopiÃ©!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre><td class="rouge-code"><pre><span class="p">[</span><span class="n">ApiController</span><span class="p">]</span>
<span class="p">[</span><span class="nf">Route</span><span class="p">(</span><span class="s">"api/[controller]"</span><span class="p">)]</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">OrdersController</span> <span class="p">:</span> <span class="n">ControllerBase</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="k">readonly</span> <span class="n">IMediator</span> <span class="n">_mediator</span><span class="p">;</span>

    <span class="k">public</span> <span class="nf">OrdersController</span><span class="p">(</span><span class="n">IMediator</span> <span class="n">mediator</span><span class="p">)</span>
    <span class="p">{</span> 
        <span class="n">_mediator</span> <span class="p">=</span> <span class="n">mediator</span><span class="p">;</span> 
    <span class="p">}</span>

    <span class="p">[</span><span class="n">HttpPost</span><span class="p">]</span>
    <span class="k">public</span> <span class="k">async</span> <span class="n">Task</span><span class="p">&lt;</span><span class="n">IActionResult</span><span class="p">&gt;</span> <span class="nf">CreateOrder</span><span class="p">([</span><span class="n">FromBody</span><span class="p">]</span> <span class="n">CreateOrderCommand</span> <span class="n">command</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">OrderDto</span> <span class="n">result</span> <span class="p">=</span> <span class="k">await</span> <span class="n">_mediator</span><span class="p">.</span><span class="nf">Send</span><span class="p">(</span><span class="n">command</span><span class="p">);</span>
        <span class="k">return</span> <span class="nf">CreatedAtAction</span><span class="p">(</span><span class="s">"GetOrder"</span><span class="p">,</span> <span class="k">new</span> <span class="p">{</span> <span class="n">id</span> <span class="p">=</span> <span class="n">result</span><span class="p">.</span><span class="n">OrderId</span> <span class="p">},</span> <span class="n">result</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="p">[</span><span class="nf">HttpGet</span><span class="p">(</span><span class="s">"{id}"</span><span class="p">)]</span>
    <span class="k">public</span> <span class="k">async</span> <span class="n">Task</span><span class="p">&lt;</span><span class="n">IActionResult</span><span class="p">&gt;</span> <span class="nf">GetOrder</span><span class="p">(</span><span class="kt">int</span> <span class="n">id</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">OrderDto</span> <span class="n">resultat</span> <span class="p">=</span> <span class="k">await</span> <span class="n">_mediator</span><span class="p">.</span><span class="nf">Send</span><span class="p">(</span><span class="k">new</span> <span class="nf">GetOrderDetailsQuery</span><span class="p">(</span><span class="n">id</span><span class="p">));</span>

        <span class="k">return</span> <span class="n">resultat</span> <span class="k">is</span> <span class="k">null</span> <span class="p">?</span> <span class="nf">NotFound</span><span class="p">()</span> <span class="p">:</span> <span class="nf">Ok</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>On voit que le contrÃ´leur ne contient quasiment aucune logique : il se contente de transmettre la commande/requÃªte au mÃ©diateur (<code class="language-plaintext highlighter-rouge">_mediator.Send(...)</code>) et de retourner la rÃ©ponse appropriÃ©e (ici un code 201 Created ou 200 OK). Toute la â€œvraieâ€ logique est implÃ©mentÃ©e dans nos handlers, ce qui correspond bien Ã  lâ€™esprit Vertical Slice : <strong>chaque requÃªte HTTP correspond Ã  un use case gÃ©rÃ© par un handler dÃ©diÃ©</strong>. Cette structure rend les controllers minces et faciles Ã  maintenir, et dÃ©place le poids de la logique dans les slices oÃ¹ elle est plus facile Ã  tester.</p><h3 id="points-Ã -noter-dans-cet-exemple"><span class="mr-2">Points Ã  noter dans cet exemple</span><a href="#points-Ã -noter-dans-cet-exemple" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>On a un fichier par requÃªte/commande et un par handler, mais on aurait pu regrouper la commande et son handler dans le mÃªme fichier (câ€™est une question de style). Lâ€™important est que la sÃ©paration est faite par cas dâ€™utilisation et non par type dâ€™objet.<li>Les classes <code class="language-plaintext highlighter-rouge">OrderDto</code>, <code class="language-plaintext highlighter-rouge">CreateOrderCommand</code>, <code class="language-plaintext highlighter-rouge">GetOrderDetailsQuery</code>, etc., sont <strong>spÃ©cifiques Ã  leur slice</strong>. Aucune dâ€™entre elles nâ€™est utilisÃ©e en dehors de la fonctionnalitÃ© en question. Cela garantit que modifier lâ€™une nâ€™impactera pas dâ€™autres parties du systÃ¨me par effet de bord inattendu.<li>Chaque handler pourrait avoir ses propres <strong>validations</strong> (par exemple, vÃ©rifier que <code class="language-plaintext highlighter-rouge">Quantity</code> est positive dans <code class="language-plaintext highlighter-rouge">CreateOrderHandler</code>). On pourrait utiliser des <em>Behavior</em> MediatR ou des filtres, mais souvent chaque slice gÃ¨re ses validations soit inline, soit via des composants dÃ©diÃ©s (par exemple un <code class="language-plaintext highlighter-rouge">FluentValidation</code> validator par commande). Lâ€™essentiel est que, lÃ  encore, la validation mÃ©tier dâ€™un use case vit Ã  cÃ´tÃ© de ce use case.<li>On peut tout Ã  fait utiliser des patterns de conception Ã  lâ€™intÃ©rieur dâ€™un vertical slice. Par exemple, si la logique de crÃ©ation de commande devenait trÃ¨s complexe, on pourrait introduire une couche de <strong>domaine</strong> (entitÃ© <strong>Order</strong> avec des mÃ©thodes, service de domaine, etc.) <strong>au sein</strong> de cette slice. Vertical Slice nâ€™interdit pas dâ€™Ã©crire du code propre ! Il dit juste : Â« ne le rends pas <strong>partagÃ©</strong> dâ€™office si ce nâ€™est pas nÃ©cessaire Â». Vous pouvez donc combiner Vertical Slice et principes DDD/Clean Ã  un niveau fin, en crÃ©ant une mini-architecture hexagonale interne Ã  une tranche si le besoin sâ€™en fait sentir.</ul><h2 id="rÃ©flexion-et-questions-ouvertes"><span class="mr-2">RÃ©flexion et questions ouvertes</span><a href="#rÃ©flexion-et-questions-ouvertes" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Nous avons explorÃ© ce quâ€™est lâ€™architecture Vertical Slice, ses atouts et ses faiblesses, ainsi que son positionnement vis-Ã -vis de lâ€™architecture Clean. Pour conclure cet article, il convient dâ€™insister quâ€™il nâ€™existe pas de solution universelle â€“ <strong>le choix dÃ©pend de votre contexte spÃ©cifique</strong>. Voici quelques questions ouvertes pour alimenter votre rÃ©flexion et vous aider Ã  Ã©valuer la pertinence de Vertical Slice pour votre projetÂ :</p><ul><li><strong>Vos fonctionnalitÃ©s sont-elles rÃ©ellement indÃ©pendantes ?</strong> Partagez-vous beaucoup de rÃ¨gles mÃ©tier et de donnÃ©es entre diffÃ©rentes parties de lâ€™application, ou bien pouvez-vous facilement isoler des <strong>slices</strong> sans crÃ©er de doublons massifs ? Si votre domaine est trÃ¨s connectÃ©, une architecture par couches pourrait mieux convenir. Si au contraire vous pouvez dessiner des frontiÃ¨res nettes, Vertical Slice peut apporter de la clartÃ©.<li><strong>Quelle complexitÃ© anticipez-vous Ã  long terme ?</strong> Sâ€™il sâ€™agit dâ€™un petit service ou dâ€™un module simple, Vertical Slice vous fera gagner du temps et de la souplesse. En revanche, pour un produit stratÃ©gique qui va Ã©voluer sur des annÃ©es avec de nombreuses fonctionnalitÃ©s, envisagez-vous que lâ€™absence dâ€™un modÃ¨le central puisse devenir un frein (duplication, incohÃ©rences) ? Faut-il prÃ©voir une combinaison dâ€™approches pour grandir sereinement ?<li><strong>Quelle importance accordez-vous Ã  la rÃ©utilisation et aux abstractions ?</strong> PrÃ©fÃ©rez-vous du code dupliquÃ© mais simple et lisible, ou une factorisation poussÃ©e quitte Ã  introduire des couches dâ€™abstraction supplÃ©mentaires ? La premiÃ¨re approche favorise Vertical Slice, la seconde sâ€™aligne plus avec Clean/DDD. En fonction de votre prioritÃ© (rapiditÃ© de dÃ©veloppement vs. rationalisation du code), lâ€™une ou lâ€™autre approche prendra lâ€™avantage.<li><strong>Votre Ã©quipe et votre organisation sont-elles prÃªtes ?</strong> ConsidÃ©rez le niveau dâ€™expÃ©rience de vos dÃ©veloppeurs et la structure de votre Ã©quipe. Sont-ils Ã  lâ€™aise pour Ã©voluer sans le filet dâ€™une architecture standard ? Vont-ils suivre des conventions communes pour ne pas que chaque slice devienne un microcosme isolÃ© ? Avez-vous les outils pour documenter et surveiller la cohÃ©rence de lâ€™ensemble ? Lâ€™architecture Vertical Slice demande une certaine discipline dans un contexte dâ€™Ã©quipe pour Ã©viter lâ€™effet Â« tour de Babel Â» oÃ¹ chacun code dans son coin. Ã€ lâ€™inverse, une Ã©quipe responsable et bien synchronisÃ©e pourra prospÃ©rer grÃ¢ce Ã  la libertÃ© quâ€™elle offre.</ul><p>En rÃ©pondant Ã  ces questions, vous serez en mesure de peser le <strong>pour et le contre</strong> de lâ€™architecture Vertical Slice dans votre cas particulier. Nâ€™hÃ©sitez pas Ã  expÃ©rimenter Ã  petite Ã©chelle, voire Ã  combiner des approches (comme structurer votre code en slices tout en conservant un noyau de domaine commun pour les invariants critiques). Lâ€™important est de choisir une architecture qui <strong>sert au mieux les besoins de votre projet et de votre Ã©quipe</strong> â€“ que ce soit Vertical Slice, Clean Architecture, une combinaison des deux, ou toute autre variante architecturale. AprÃ¨s tout, une architecture nâ€™est rÃ©ussie que si elle vous permet de livrer un logiciel de qualitÃ©, maintenable et Ã©volutif, dans les dÃ©lais et avec le sourire de lâ€™Ã©quipe ğŸ˜Š.</p><p>ğŸ‘‰ Pour approfondir la rÃ©flexion et dÃ©couvrir un point de vue Ã©clairant sur le sujet, je vous recommande vivement la vidÃ©o de Milan JovanoviÄ‡.</p><iframe width="740" height="473" src="https://www.youtube.com/embed/Az4Z0HJYl-U?si=5irssXM9jNAyxTVM" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen=""></iframe></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/architecture/'>architecture</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> Cet article est sous licence <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> par l'auteur.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Partager</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Architecture%20Vertical%20Slice%20dans%20l%E2%80%99%C3%A9cosyst%C3%A8me%20.NET%20-%20CodeWithFrenchy&url=https%3A%2F%2Fcodewithfrenchy.github.io%2F%2Fposts%2Fvertical-slice-architecture%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.linkedin.com/sharing/share-offsite/?url=https%3A%2F%2Fcodewithfrenchy.github.io%2F%2Fposts%2Fvertical-slice-architecture%2F" data-toggle="tooltip" data-placement="top" title="Linkedin" target="_blank" rel="noopener" aria-label="Linkedin"> <i class="fa-fw fab fa-linkedin"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Architecture%20Vertical%20Slice%20dans%20l%E2%80%99%C3%A9cosyst%C3%A8me%20.NET%20-%20CodeWithFrenchy&u=https%3A%2F%2Fcodewithfrenchy.github.io%2F%2Fposts%2Fvertical-slice-architecture%2F" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copier le lien" data-title-succeed="Lien copiÃ© avec succÃ¨s!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">RÃ©cemment mis Ã  jour</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/plan-formation-dotnet/">Plan de formation - .NET Framework vers .NET moderne</a><li><a href="/posts/essais-architecture-automatises-dotnet/">Essais automatisÃ©s dâ€™architecture dans un projet .NET</a><li><a href="/posts/performances-jsonserializeroptions-singleton/">AmÃ©lioration des performances en utilisant JsonSerializerOptions en singleton</a><li><a href="/posts/source-generator-dotnet/">Les GÃ©nÃ©rateurs de source</a><li><a href="/posts/guid-versus-id/">GUID vs ID auto-incrÃ©mentÃ© - dilemme et solutions en environnement .NET distribuÃ©</a></ul></div><div id="access-tags"><div class="panel-heading">Tags tendance</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/dotnet/">dotnet</a> <a class="post-tag" href="/tags/essais/">essais</a> <a class="post-tag" href="/tags/conference/">conference</a> <a class="post-tag" href="/tags/source-generator/">source-generator</a> <a class="post-tag" href="/tags/aspnet-core/">aspnet-core</a> <a class="post-tag" href="/tags/fluentassertions/">fluentassertions</a> <a class="post-tag" href="/tags/fluentvalidation/">fluentvalidation</a> <a class="post-tag" href="/tags/k6/">k6</a> <a class="post-tag" href="/tags/mapperly/">mapperly</a> <a class="post-tag" href="/tags/testcontainers/">testcontainers</a></div></div></div><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">Contenu</div><nav id="toc"></nav></div><script src="https://cdn.jsdelivr.net/npm/tocbot@4.20.1/dist/tocbot.min.js"></script></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4 mt-5"><div id="related-posts" class="mb-2 mb-sm-4"><h3 class="pt-2 mb-4 ml-1" data-toc-skip>Autres lectures</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/quand-utiliser-architecture-microservices/"><div class="card-body"> <em class="small" data-ts="1757376000" data-df="DD/MM/YYYY" > 08/09/2025 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Faut-il vraiment adopter une architecture microservices</h3><div class="text-muted small"><p> PrÃ©ambule â€œOn part en microservices ou on reste monolithique ?â€ Câ€™est une des questions les plus posÃ©es et les moins bien tranchÃ©es du monde logiciel. Une question qui revient Ã  chaque projet...</p></div></div></a></div><div class="card"> <a href="/posts/utilisation-design-patterns/"><div class="card-body"> <em class="small" data-ts="1758549600" data-df="DD/MM/YYYY" > 22/09/2025 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Les design patternsÂ - les bons Legos pour vos applications .NET</h3><div class="text-muted small"><p> IntroductionÂ : Ne rÃ©inventez pas la roue, assemblez les Legos En conception logicielle, un design pattern (ou patron de conception) est une solution Ã©prouvÃ©e Ã  un problÃ¨me de conception rÃ©current....</p></div></div></a></div><div class="card"> <a href="/posts/concevoir-maintenir-application-performante-dotnet/"><div class="card-body"> <em class="small" data-ts="1761001200" data-df="DD/MM/YYYY" > 20/10/2025 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Concevoir et maintenir des applications microservices performantes en .NET</h3><div class="text-muted small"><p> La performance logicielle ne doit pas Ãªtre une rÃ©flexion aprÃ¨s coup : elle se conÃ§oit dÃ¨s le dÃ©part et se cultive tout au long de la vie du systÃ¨me. Dans cet article, nous explorons comment sâ€™outil...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/changements-licences-ecosysteme-dotnet/" class="btn btn-outline-primary" prompt="Plus ancien"><p>Changements de licences dans lâ€™Ã©cosystÃ¨me .NET â€“ quelles implications ?</p></a> <a href="/posts/quand-utiliser-architecture-microservices/" class="btn btn-outline-primary" prompt="Plus rÃ©cent"><p>Faut-il vraiment adopter une architecture microservices</p></a></div></div></div></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Tags tendance</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/dotnet/">dotnet</a> <a class="post-tag" href="/tags/essais/">essais</a> <a class="post-tag" href="/tags/conference/">conference</a> <a class="post-tag" href="/tags/source-generator/">source-generator</a> <a class="post-tag" href="/tags/aspnet-core/">aspnet-core</a> <a class="post-tag" href="/tags/fluentassertions/">fluentassertions</a> <a class="post-tag" href="/tags/fluentvalidation/">fluentvalidation</a> <a class="post-tag" href="/tags/k6/">k6</a> <a class="post-tag" href="/tags/mapperly/">mapperly</a> <a class="post-tag" href="/tags/testcontainers/">testcontainers</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><footer><div class="container pl-lg-4 pr-lg-4"><div class="d-flex justify-content-between align-items-center text-muted ml-md-3 mr-md-3"><div class="footer-left"><p class="mb-0"> Â© 2026 <a href="https://twitter.com/alexis35115">Alexis Garon-Michaud</a>. <span data-toggle="tooltip" data-placement="top" title="Sauf mention contraire, les articles de ce site sont publiÃ©s sous licence sous la licence Creative Commons Attribution 4.0 International (CC BY 4.0) par l'auteur.">Certains droits rÃ©servÃ©s.</span></p></div><div class="footer-right"><p class="mb-0">PropulsÃ© par <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> avec le thÃ¨me <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a></p></div></div></div></footer><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oups! Aucun rÃ©sultat trouvÃ©.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lazysizes@5.3.2/lazysizes.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/fr.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/unregister.js"></script>
