<!DOCTYPE html><html lang="fr-FR" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="theme-color" media="(prefers-color-scheme: light)" content="#f7f7f7"><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1e"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="viewport" content="width=device-width, user-scalable=no initial-scale=1, shrink-to-fit=no, viewport-fit=cover" ><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="Valider les courriels - pourquoi une regex ne suffit plus" /><meta property="og:locale" content="fr_FR" /><meta name="description" content="Préambule" /><meta property="og:description" content="Préambule" /><link rel="canonical" href="https://codewithfrenchy.github.io//posts/validation-courriel/" /><meta property="og:url" content="https://codewithfrenchy.github.io//posts/validation-courriel/" /><meta property="og:site_name" content="CodeWithFrenchy" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2025-06-02T19:00:00-04:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Valider les courriels - pourquoi une regex ne suffit plus" /><meta name="twitter:site" content="@alexis35115" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2025-06-02T19:00:00-04:00","datePublished":"2025-06-02T19:00:00-04:00","description":"Préambule","headline":"Valider les courriels - pourquoi une regex ne suffit plus","mainEntityOfPage":{"@type":"WebPage","@id":"https://codewithfrenchy.github.io//posts/validation-courriel/"},"url":"https://codewithfrenchy.github.io//posts/validation-courriel/"}</script><title>Valider les courriels - pourquoi une regex ne suffit plus | CodeWithFrenchy</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="CodeWithFrenchy"><meta name="application-name" content="CodeWithFrenchy"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tocbot@4.20.1/dist/tocbot.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener('change', () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.notify(); } /* flipMode() */ } /* ModeToggle */ const modeToggle = new ModeToggle(); </script><body data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" class="mx-auto"> <img src="https://avatars.githubusercontent.com/u/53872142?s=400&u=53187283fe05254234a3890e2b44134f96e3a833&v=4" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title"> <a href="/">CodeWithFrenchy</a></div><div class="site-subtitle font-italic">Architecte logiciel, audacieux et fermier</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>ACCUEIL</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATÉGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>À PROPOS DE</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/alexis35115" aria-label="github" target="_blank" rel="noopener noreferrer"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/alexis35115" aria-label="twitter" target="_blank" rel="noopener noreferrer"> <i class="fab fa-twitter"></i> </a> <a href="https://www.linkedin.com/in/alexis-garon-michaud-a59643219/" aria-label="linkedin" target="_blank" rel="noopener noreferrer"> <i class="fab fa-linkedin"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <span id="breadcrumb"> <span> <a href="/"> Accueil </a> </span> <span>Valider les courriels - pourquoi une regex ne suffit plus</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Recherche..."> </span> <span id="search-cancel" >Annuler</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>Valider les courriels - pourquoi une regex ne suffit plus</h1><div class="post-meta text-muted"> <span> Posté <em class="" data-ts="1748905200" data-df="DD/MM/YYYY" data-toggle="tooltip" data-placement="bottom"> 02/06/2025 </em> </span><div class="d-flex justify-content-between"> <span> Par <em> <a href="https://twitter.com/alexis35115">Alexis Garon-Michaud</a> </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="2303 mots"> <em>12 min</em> à lire</span></div></div></div><div class="post-content"><h2 id="préambule"><span class="mr-2">Préambule</span><a href="#préambule" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Je ne pensais pas écrire un article aujourd’hui sur la validation des courriels, mais une récente discussion m’a fait changer d’avis. Comme beaucoup, j’ai longtemps utilisé une simple expression régulière (regex) pour vérifier le format d’une adresse courriel saisie par un utilisateur. Après tout, la forme d’une adresse électronique semble facile à valider : on a tous déjà croisé la fameuse regex <code class="language-plaintext highlighter-rouge">^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+$</code> pour « valider » un courriel. <strong>Pourtant, valider une adresse email de manière fiable est bien plus complexe, et se reposer uniquement sur une regex est une mauvaise idée</strong>.</p><p>Récemment, dans sa vidéo <a href="https://www.youtube.com/watch?v=M6itpAfbvas">Regex for Email Validation? Think Again!</a>, <a href="https://codeopinion.com/derek-comartin/">Derek Comartin</a> a expliqué pourquoi cette approche n’est ni fiable ni suffisante. Cela m’a encouragé à approfondir le sujet et à partager les bonnes pratiques modernes en matière de validation des adresses courriel.</p><h2 id="les-limites-des-regex-pour-les-adresses-courriel"><span class="mr-2">Les limites des regex pour les adresses courriel</span><a href="#les-limites-des-regex-pour-les-adresses-courriel" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Valider un email par regex atteint vite ses limites.</p><p>Voici pourquoi :</p><ul><li><strong>Une regex ne couvre jamais tous les cas d’adresse valides.</strong> La norme RFC 5322 (et suivantes) autorise des variantes d’adresses bien plus larges que nos regex simplifiées. Par exemple, de nombreux caractères spéciaux sont permis dans la partie locale (avant le <code class="language-plaintext highlighter-rouge">@</code>) d’une adresse : <code class="language-plaintext highlighter-rouge">!</code>, <code class="language-plaintext highlighter-rouge">#</code>, <code class="language-plaintext highlighter-rouge">$</code>, <code class="language-plaintext highlighter-rouge">%</code>, <code class="language-plaintext highlighter-rouge">&amp;</code>, <code class="language-plaintext highlighter-rouge">'</code>, <code class="language-plaintext highlighter-rouge">_</code>, <code class="language-plaintext highlighter-rouge">/</code>, <code class="language-plaintext highlighter-rouge">=</code>, <code class="language-plaintext highlighter-rouge">?</code>, <code class="language-plaintext highlighter-rouge">^</code>, <code class="language-plaintext highlighter-rouge">`</code>, <code class="language-plaintext highlighter-rouge">{</code>, <code class="language-plaintext highlighter-rouge">|</code>, <code class="language-plaintext highlighter-rouge">}</code> ou <code class="language-plaintext highlighter-rouge">~</code> peuvent théoriquement faire partie d’un courriel. Une regex « maison » oublie souvent d’en tenir compte, ce qui peut conduire à rejeter à tort des emails valides. De même, certaines adresses spéciales (contenant des guillemets, des caractères non-ASCII, un nom de domaine littéral en IP, etc.) respectent les standards mais ne passeront pas un filtre regex trop strict.<li><strong>À l’inverse, une regex peut accepter des adresses invalides.</strong> Même une expression régulière très élaborée peut laisser passer des adresses qui ne fonctionneront pas en pratique. Un exemple classique : une regex réputée “parfaite” autorisait <code class="language-plaintext highlighter-rouge">tony@example.com.</code> (avec un point à la fin) comme adresse valide, alors qu’aucun serveur de messagerie n’acceptera un courriel se terminant par un point. Autre cas : certaines implémentations basées sur le HTML5 considèrent <code class="language-plaintext highlighter-rouge">test@test</code> (sans domaine de second niveau) comme valide côté client, alors que cette adresse n’a pas de domaine complet et n’aboutirait pas. En bref, même les meilleurs patterns peuvent avoir des failles et donner un faux sentiment de sécurité.<li><strong>Une regex ne dit rien sur l’existence réelle de l’adresse.</strong> C’est le point le plus important. Une adresse peut très bien <em>avoir la bonne forme</em> et être acceptée par toutes vos validations syntaxiques, tout en n’existant pas du tout dans la réalité (domaine inexistant ou simplement aucune boîte à ce nom). La regex, aussi sophistiquée soit-elle, ne peut pas vérifier que le serveur de mail existe et que la boîte de réception est active. En d’autres termes, une validation purement syntaxique n’assure en rien que l’email pourra effectivement recevoir vos messages.</ul><p>En plus de ces limites inhérentes aux regex, <strong>se reposer uniquement sur une validation côté client (front-end) est une pratique dangereuse</strong>. Tout contrôle JavaScript ou Angular peut être contourné par un utilisateur malintentionné. Si votre application ne valide les courriels qu’au niveau du navigateur, vous risquez d’enregistrer en base de données des adresses totalement invalides envoyées directement à votre serveur. Il est impératif de reproduire les validations critiques côté serveur, sans se fier exclusivement au contrôle du formulaire côté client.</p><h2 id="que-proposent-angular-net-et-fluentvalidation-"><span class="mr-2">Que proposent Angular, .NET et FluentValidation ?</span><a href="#que-proposent-angular-net-et-fluentvalidation-" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Face à la difficulté de définir <strong>LA</strong> regex parfaite, les principaux frameworks et bibliothèques ont adopté des approches pragmatiques – soit en utilisant des patterns larges, soit au contraire en simplifiant la validation.</p><ul><li><strong>Angular (Front-end)</strong> – Le validateur d’email intégré d’Angular utilise une expression régulière inspirée de la spécification HTML5 (WHATWG) avec quelques ajustements basés sur les RFC. Concrètement, Angular va vérifier que l’adresse respecte le format général (présence d’un <code class="language-plaintext highlighter-rouge">@</code> et d’un point, pas de point au début/à la fin de la partie locale, longueur maximale de 254 caractères, etc.). Ce choix couvre la majorité des cas courants tout en évitant des erreurs grossières. <strong>Cependant, même cette regex “améliorée” reste une solution générique</strong> : elle peut ne pas satisfaire tous les besoins métier, surtout pour des cas extrêmes ou des domaines moins standards. Angular permet d’ailleurs de la remplacer par un pattern personnalisé si nécessaire. En somme, Angular offre une première couche de validation utile côté client, mais n’élimine pas le besoin de validations supplémentaires côté serveur.<li><strong>.NET (Back-end)</strong> – Du côté .NET, l’évolution est intéressante. Historiquement, la classe d’attribut <code class="language-plaintext highlighter-rouge">EmailAddressAttribute</code> (dans <code class="language-plaintext highlighter-rouge">System.ComponentModel.DataAnnotations</code>) utilisait une énorme expression régulière pour valider les emails (dans les versions .NET Framework 4.x et antérieures). Cette regex « monstrueuse » couvrait un grand nombre de cas, mais elle alourdissait la validation et restait imparfaite. <strong>Depuis .NET Core, Microsoft a changé d’approche</strong> : l’attribut se contente désormais de vérifier que la chaîne contient un <code class="language-plaintext highlighter-rouge">@</code> qui n’est ni en première position ni en dernière position. En clair, si un texte a au moins un caractère avant et après un <code class="language-plaintext highlighter-rouge">@</code>, il passe la validation de base. Par exemple, <code class="language-plaintext highlighter-rouge">"code.maze.com"</code> sera jugé invalide (pas de <code class="language-plaintext highlighter-rouge">@</code>), <code class="language-plaintext highlighter-rouge">"code@maze"</code> invalide (le <code class="language-plaintext highlighter-rouge">@</code> est en fin de chaîne après “maze”?), et <code class="language-plaintext highlighter-rouge">"code@[email protected]"</code> valide (même si ce n’est pas une adresse fonctionnelle). Ce choix peut surprendre, mais il est <strong>volontairement minimaliste</strong>. L’objectif de .NET ici est juste d’éliminer les entrées grossièrement incorrectes, sans tenter de capturer toutes les subtilités du RFC. Microsoft assume que la <em>véritable</em> validation doit se faire autrement (via un workflow d’activation, etc.), plutôt que de maintenir une regex complexe et faillible. Résultat : on évite de fausses erreurs sur des adresses valides mais un peu atypiques, en attrapant seulement les cas évidents (absences de <code class="language-plaintext highlighter-rouge">@</code>, etc.).<li><strong>FluentValidation (Back-end, .NET)</strong> – FluentValidation, une bibliothèque populaire de validation en .NET, aligne sa stratégie sur celle de .NET Core. Son validateur intégré <code class="language-plaintext highlighter-rouge">EmailAddress()</code> réalise par défaut <strong>la même vérification simplifiée</strong> : présence d’un <code class="language-plaintext highlighter-rouge">@</code> non situé au début ni à la fin de la chaîne. Cette démarche est assumée pour coller au comportement d’ASP.NET Core et à l’attribut <code class="language-plaintext highlighter-rouge">EmailAddressAttribute</code>. Dans la documentation officielle, les auteurs expliquent que le check est <em>intentionnellement naïf</em>, car <em>“faire quelque chose d’infaillible est très difficile”</em>. Ils recommandent de valider réellement l’adresse en envoyant un email de confirmation, la validation logicielle n’ayant pour but que d’attraper les valeurs grossièrement erronées destinées à l’UI. FluentValidation offre bien la possibilité d’utiliser l’ancien mode de validation (une regex héritée de .NET 4.x) via <code class="language-plaintext highlighter-rouge">EmailAddress(EmailValidationMode.Net4xRegex)</code>, <strong>mais cette option est désormais dépréciée</strong> et génère un avertissement – signe que la validation basée sur une regex exhaustive n’est plus recommandée. En pratique, si vous utilisez FluentValidation, le conseil est donc le même : ne faites qu’une validation de format très basique, puis déléguez le reste du travail.</ul><p>En résumé, les frameworks modernes tendent à <em>assouplir</em> la validation syntaxique des emails plutôt qu’à la renforcer outre mesure. Angular propose une regex large couvrant les cas usuels, tandis que .NET/FluentValidation optent pour un contrôle minimal. <strong>L’idée sous-jacente est la suivante : plutôt que d’essayer de tout valider parfaitement avec du code statique (regex), mieux vaut attraper le 90% d’erreurs évidentes, et traiter le 10% restant via des mécanismes dynamiques</strong>.</p><h2 id="valider-lexistence-de-ladresse-sans-envoyer-de-mail"><span class="mr-2">Valider l’existence de l’adresse (sans envoyer de mail)</span><a href="#valider-lexistence-de-ladresse-sans-envoyer-de-mail" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Attraper les erreurs de format, c’est bien – mais ça ne suffit pas, on l’a vu. La vraie question est : <em>cette adresse existe-t-elle réellement ?</em> Autrefois, certains systèmes envoyaient un <strong>email de confirmation</strong> à l’adresse fournie, espérant qu’un message invalide “reviendrait à l’expéditeur” si l’adresse n’existe pas. <strong>Mauvaise idée !</strong> Envoyer un courriel juste pour vérifier qu’il arrive peut nuire à votre réputation : si vous envoyez en masse à des adresses invalides, les serveurs destinataires peuvent vous classer comme spammeur. De plus, vous risquez de froisser vos nouveaux utilisateurs en les obligeant à une confirmation pénible, ou pire, d’envoyer des emails non sollicités. Derek Comartin le mentionnait dans sa vidéo : cette approche n’est pas la meilleure non plus.</p><p>La solution moderne consiste à <strong>déléguer la validation réelle à un service externe spécialisé</strong>. Il existe aujourd’hui des services SaaS de vérification d’adresses email (NeverBounce, ZeroBounce, Mailfloss, Kickbox et bien d’autres) qui font ce travail de manière efficace <strong>sans envoyer de courriel</strong> au destinataire. Comment est-ce possible ? Ces services effectuent une série de contrôles techniques :</p><ul><li><strong>Vérification du domaine</strong> : ils examinent si le nom de domaine de l’adresse existe et possède des enregistrements MX (serveurs de mail) configurés. Pas de serveur mail = adresse forcément invalide. Ce premier filtre permet déjà d’éliminer les domaines fantaisistes ou désactivés.<li><strong>Réponse du serveur de messagerie</strong> : le service contacte le serveur de messagerie du domaine via le protocole SMTP (comme s’il allait envoyer un message) et interroge s’il peut accepter l’adresse destinataire donnée. En simulant cette <em>conversation</em> avec le serveur (un <em>ping</em> de la boîte mail), on peut savoir si l’adresse est reconnue sans envoyer réellement de mail. Si le serveur répond “boîte inexistante” (code d’erreur 550 par ex.), on sait que l’adresse est invalide. Si au contraire on obtient une réponse positive (250 OK), c’est bon signe – l’adresse <em>semble</em> valide et prête à recevoir du courrier.<li><strong>Détection avancée</strong> : ces services ajoutent souvent d’autres filtres utiles, comme l’identification des adresses <strong>jetables</strong> (fournisseurs de mails temporaires), des <strong>spam traps</strong> (adresses pièges qui ne servent qu’à piéger les spammeurs), ou des adresses ayant un historique d’abus. Par exemple, ZeroBounce signale si une adresse appartient à un domaine connu pour être toxique ou si c’est un alias “catch-all” qui accepte tous les mails sans garantir la délivrabilité. Ce sont des informations importantes pour maintenir la <em>propreté</em> de vos listes de diffusion.</ul><p>Le grand avantage de ces services est qu’ils effectuent <strong>toutes ces vérifications en temps réel via des API</strong>, généralement en quelques centaines de millisecondes, et ce <strong>de manière transparente pour l’utilisateur final</strong>. Par exemple, vous pouvez intégrer l’API de validation de NeverBounce ou ZeroBounce directement lors de l’inscription de vos utilisateurs : dès qu’ils soumettent leur adresse, une requête API vérifie en arrière-plan l’adresse et indique si elle est valide, sans que vous ayez à envoyer un seul courriel de test. Si l’adresse s’avère invalide, vous pouvez inviter l’utilisateur à la corriger, évitant ainsi d’enregistrer des contacts erronés dans votre base de données.</p><blockquote><p><strong>Exemple de service SaaS</strong> : <em>NeverBounce</em> est l’un de ces outils de validation très fiables et rapides. Il s’intègre facilement à vos applications via API et peut vérifier des listes entières d’emails en quelques minutes. Lors d’un test comparatif, NeverBounce a pu vérifier 800 adresses en 5 minutes, identifiant correctement plus de 650 emails valides. Ce type de service assure une <strong>vérification complète</strong> de vos courriels (domaine actif, serveur répondant, adresse existante) sans effort de votre part. L’investissement en vaut la chandelle si la qualité de vos emails est critique (campagnes marketing, envois transactionnels, etc.), car il en va de votre taux de délivrabilité et de votre réputation d’expéditeur.</p></blockquote><p>En utilisant un service de validation externe, <strong>le workflow de validation “idéal” d’un courriel ressemble à ceci</strong> :</p><ol><li><em>Validation syntaxique légère</em> (ex. via un contrôle Angular en front-end, puis une vérification minimale côté serveur avec .NET/FluentValidation) pour attraper les erreurs de frappe grossières immédiatement.<li><em>Validation d’existence</em> via un service externe pour vérifier que l’adresse <strong>existe et est opérationnelle</strong> (domaine OK, serveur OK, boîte OK), sans envoyer de mail de confirmation.<li><em>Prise en compte dans votre logique métier</em> : par exemple, marquer l’adresse comme “vérifiée” dans votre base de données ou votre CRM, permettre l’inscription du compte associé, etc. Si le service retourne un statut négatif (adresse inexistante, jetable ou autre), décider du traitement (demander une autre adresse, alerter l’utilisateur, refuser l’inscription, etc.).</ol><p>Ce processus à plusieurs couches assure une validation robuste tout en offrant une bonne expérience utilisateur : on ne bloque pas l’internaute sur des détails de format exotiques, mais on s’assure en coulisse que l’adresse fournie est exploitable.</p><h2 id="conclusion"><span class="mr-2">Conclusion</span><a href="#conclusion" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>La validation des adresses courriel ne doit plus se résumer à trouver <strong>LA</strong> regex miracle. Les pratiques ont évolué : entre les spécifications extensibles du format email et les enjeux de délivrabilité, il est clair qu’<strong>une simple regex côté client ne suffit plus</strong> pour garantir la validité d’une adresse. Il faut adopter une approche en plusieurs étapes, combinant <em>tolérance</em> sur le format et <em>fermeté</em> sur l’existence réelle.</p><p>En 2025, <strong>le bon workflow</strong> pour valider un courriel est :</p><ul><li>✅ <em>Vérifier légèrement le format</em> (juste assez pour éviter les entrées absurdes, sans exclure à tort des adresses valides)<li>✅ <em>Vérifier l’existence via un service externe</em> (s’assurer que le domaine et la boîte sont valides, sans vous faire passer pour un spammeur)<li>❌ <em>Ne plus s’acharner à écrire des regex compliquées</em>, ni se fier uniquement à la validation du navigateur. Une regex peut filtrer le gros des erreurs, mais pas toutes, et certainement pas la délivrabilité réelle.</ul><p>En appliquant ces principes, vous améliorerez la qualité des données collectées et réduirez les problèmes d’emails invalides (bounces, plaintes, etc.) qui peuvent nuire à votre plateforme.</p><p>Enfin, n’hésitez pas à <strong>documenter ce choix technologique dans votre registre de décisions interne</strong>. La manière dont vous validez les courriels est un <strong>choix d’architecture applicative</strong> important, qui mérite d’être tracé noir sur blanc. Comme le souligne Derek Comartin, garder un log de toutes les décisions clés d’un projet évite bien des devinettes par la suite, en fournissant le contexte du <em>pourquoi</em> chaque décision a été prise. Inscrire dans votre registre de décisions que <em>“la validation des emails se fait via une vérification syntaxique minimale + service externe X, pour telles raisons”</em> permettra aux futurs développeurs de comprendre et de respecter cette approche cohérente.</p><p><strong>En somme</strong>, valider un courriel aujourd’hui, ce n’est pas chercher la perfection avec une regex interminable, c’est mettre en place un processus intelligent : <strong>souple sur le format, strict sur l’existence, et toujours documenté</strong>. Adoptez ce workflow moderne – vos utilisateurs, votre équipe et votre serveur mail vous en remercieront.</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/outil-developpement/'>outil-developpement</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> Cet article est sous licence <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> par l'auteur.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Partager</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Valider%20les%20courriels%20-%20pourquoi%20une%20regex%20ne%20suffit%20plus%20-%20CodeWithFrenchy&url=https%3A%2F%2Fcodewithfrenchy.github.io%2F%2Fposts%2Fvalidation-courriel%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.linkedin.com/sharing/share-offsite/?url=https%3A%2F%2Fcodewithfrenchy.github.io%2F%2Fposts%2Fvalidation-courriel%2F" data-toggle="tooltip" data-placement="top" title="Linkedin" target="_blank" rel="noopener" aria-label="Linkedin"> <i class="fa-fw fab fa-linkedin"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Valider%20les%20courriels%20-%20pourquoi%20une%20regex%20ne%20suffit%20plus%20-%20CodeWithFrenchy&u=https%3A%2F%2Fcodewithfrenchy.github.io%2F%2Fposts%2Fvalidation-courriel%2F" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copier le lien" data-title-succeed="Lien copié avec succès!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Récemment mis à jour</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/plan-formation-dotnet/">Plan de formation - .NET Framework vers .NET moderne</a><li><a href="/posts/essais-architecture-automatises-dotnet/">Essais automatisés d’architecture dans un projet .NET</a><li><a href="/posts/performances-jsonserializeroptions-singleton/">Amélioration des performances en utilisant JsonSerializerOptions en singleton</a><li><a href="/posts/source-generator-dotnet/">Les Générateurs de source</a><li><a href="/posts/guid-versus-id/">GUID vs ID auto-incrémenté - dilemme et solutions en environnement .NET distribué</a></ul></div><div id="access-tags"><div class="panel-heading">Tags tendance</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/dotnet/">dotnet</a> <a class="post-tag" href="/tags/essais/">essais</a> <a class="post-tag" href="/tags/conference/">conference</a> <a class="post-tag" href="/tags/source-generator/">source-generator</a> <a class="post-tag" href="/tags/aspnet-core/">aspnet-core</a> <a class="post-tag" href="/tags/fluentassertions/">fluentassertions</a> <a class="post-tag" href="/tags/fluentvalidation/">fluentvalidation</a> <a class="post-tag" href="/tags/k6/">k6</a> <a class="post-tag" href="/tags/mapperly/">mapperly</a> <a class="post-tag" href="/tags/testcontainers/">testcontainers</a></div></div></div><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">Contenu</div><nav id="toc"></nav></div><script src="https://cdn.jsdelivr.net/npm/tocbot@4.20.1/dist/tocbot.min.js"></script></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4 mt-5"><div id="related-posts" class="mb-2 mb-sm-4"><h3 class="pt-2 mb-4 ml-1" data-toc-skip>Autres lectures</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/essais-architecture-automatises-dotnet/"><div class="card-body"> <em class="small" data-ts="1762210800" data-df="DD/MM/YYYY" > 03/11/2025 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Essais automatisés d’architecture dans un projet .NET</h3><div class="text-muted small"><p> Introduction Dans les projets .NET complexes, par exemple appliquant le Domain-Driven Design (DDD) ou une Clean Architecture stricte, il devient crucial de s’assurer que la structure du code respe...</p></div></div></a></div><div class="card"> <a href="/posts/mise-a-jour-mstest/"><div class="card-body"> <em class="small" data-ts="1719442800" data-df="DD/MM/YYYY" > 26/06/2024 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Découvrez la nouvelle version de MSTest</h3><div class="text-muted small"><p> Microsoft vient tout juste de sortir une nouvelle version de MSTest! Quoi de neuf ? MSTest.Analyzers : Plein de corrections de bugs et d’améliorations pour rendre vos analyses de code encore p...</p></div></div></a></div><div class="card"> <a href="/posts/avantages-editorconfig/"><div class="card-body"> <em class="small" data-ts="1724111880" data-df="DD/MM/YYYY" > 19/08/2024 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Les avantages d'utiliser un fichier .editorconfig en .NET</h3><div class="text-muted small"><p> Introduction Si vous travaillez sur des projets en .NET (ou même dans d’autres langages), vous avez peut-être déjà entendu parler du fichier .editorconfig. C’est un fichier qui peut rendre la vie ...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/guid-versus-id/" class="btn btn-outline-primary" prompt="Plus ancien"><p>GUID vs ID auto-incrémenté - dilemme et solutions en environnement .NET distribué</p></a> <a href="/posts/changements-licences-ecosysteme-dotnet/" class="btn btn-outline-primary" prompt="Plus récent"><p>Changements de licences dans l’écosystème .NET – quelles implications ?</p></a></div></div></div></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Tags tendance</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/dotnet/">dotnet</a> <a class="post-tag" href="/tags/essais/">essais</a> <a class="post-tag" href="/tags/conference/">conference</a> <a class="post-tag" href="/tags/source-generator/">source-generator</a> <a class="post-tag" href="/tags/aspnet-core/">aspnet-core</a> <a class="post-tag" href="/tags/fluentassertions/">fluentassertions</a> <a class="post-tag" href="/tags/fluentvalidation/">fluentvalidation</a> <a class="post-tag" href="/tags/k6/">k6</a> <a class="post-tag" href="/tags/mapperly/">mapperly</a> <a class="post-tag" href="/tags/testcontainers/">testcontainers</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><footer><div class="container pl-lg-4 pr-lg-4"><div class="d-flex justify-content-between align-items-center text-muted ml-md-3 mr-md-3"><div class="footer-left"><p class="mb-0"> © 2026 <a href="https://twitter.com/alexis35115">Alexis Garon-Michaud</a>. <span data-toggle="tooltip" data-placement="top" title="Sauf mention contraire, les articles de ce site sont publiés sous licence sous la licence Creative Commons Attribution 4.0 International (CC BY 4.0) par l'auteur.">Certains droits réservés.</span></p></div><div class="footer-right"><p class="mb-0">Propulsé par <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> avec le thème <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a></p></div></div></div></footer><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oups! Aucun résultat trouvé.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lazysizes@5.3.2/lazysizes.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/fr.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/unregister.js"></script>
