---
title: Pourquoi le versionnement d'API n'est pas toujours indispensable
date: 2025-12-29 20:00:00 -0400
categories: [architecture]
tags: []
---

> âš ï¸ Ã€ FINIR DE RÃ‰VISER!

L'idÃ©e reÃ§ue veut que toute nouvelle API doive Ãªtre _versionnÃ©e_ d'emblÃ©e, souvent en prÃ©fixant les URLs par un numÃ©ro de version (`/v1`, `/v2`, etc.). Cette pratique est censÃ©e faciliter les Ã©volutions futures sans casser les clients existants. Pourtant, **dans de nombreux cas, il nâ€™est pas nÃ©cessaire de mettre en place un versionnement par dÃ©faut**. En effet, si tous les consommateurs de l'API sont sous votre contrÃ´le, la flexibilitÃ© apportÃ©e par le versionnement peut ne pas justifier la complexitÃ© de gestion supplÃ©mentaire introduite. Nous allons examiner pourquoi le versionnement systÃ©matique nâ€™est pas toujours indispensable, quels en sont les coÃ»ts, et comment faire Ã©voluer vos APIs internes de faÃ§on pragmatique et pÃ©dagogique.

## Qu'est-ce que le versionnement d'API et pourquoi est-il recommandÃ© ?

Le **versionnement d'API** consiste Ã  faire coexister plusieurs versions dâ€™une mÃªme API afin de gÃ©rer des modifications dans les interfaces exposÃ©es. Par exemple, on peut avoir une version 1 et une version 2 d'un service REST, chacune acceptant des requÃªtes et renvoyant des rÃ©ponses dans un format possiblement diffÃ©rent. Lâ€™intÃ©rÃªt est de permettre Ã  des anciens clients de continuer Ã  fonctionner sur lâ€™API _v1_ tandis que de nouveaux clients utilisent lâ€™API _v2_, surtout si des changements _rÃ©tro-incompatibles_ (_breaking changes_) sont introduits. En microservices, oÃ¹ chaque service Ã©volue indÃ©pendamment, cette capacitÃ© Ã  exposer plusieurs versions peut sembler nÃ©cessaire pour ne pas perturber lâ€™Ã©cosystÃ¨me logiciel lors des dÃ©ploiements.

En effet, **la recommandation habituelle** pour les API publiques est dâ€™implÃ©menter un versionnement dÃ¨s le dÃ©part afin de ne pas bloquer les Ã©volutions futures. Par exemple, Google Cloud souligne quâ€™un des malentendus courants est de croire _"qu'il faut intÃ©grer le versionnement dans vos APIs dÃ¨s le dÃ©part"_. Cette approche prÃ©ventive amÃ¨ne de nombreux dÃ©veloppeurs Ã  prÃ©fixer systÃ©matiquement leurs routes d'API par `/v1` dÃ¨s la premiÃ¨re version, _"suivant des conseils lus sur internet"_.

Pourquoi cette prÃ©caution ? Prenons un scÃ©nario microservices classique : le _Service A_ fournit une API consommÃ©e par dâ€™autres services (_B_, _C_, etc.). Si _A_ doit changer son contrat (par exemple, renommer un champ, modifier le format de rÃ©ponse ou la logique mÃ©tier), les services consommateurs risquent de ne plus fonctionner correctement. **Le versionnement offre alors une solution** : on publie une nouvelle version de lâ€™API (v2) tout en gardant lâ€™ancienne (v1) accessible, ce qui **permet aux anciens et aux nouveaux clients de continuer Ã  fonctionner sans interruption**. Les clients existants peuvent migrer vers la v2 Ã  leur rythme, tandis que les nouveaux profitent directement des Ã©volutions. Cela Ã©vite des coupures brutales du service et facilite des dÃ©ploiements progressifs : _"la nouvelle version d'API peut Ãªtre dÃ©ployÃ©e Ã  cÃ´tÃ© de l'ancienne, assurant un service ininterrompu pour tous les clients"_. Dans un contexte de microservices Ã  grande Ã©chelle, le versionnement offre aussi la possibilitÃ© de tester de nouvelles fonctionnalitÃ©s sur un sous-ensemble de consommateurs (_canary release_) sans impacter tout le monde.

Enfin, le versionnement clarifie souvent la communication et la documentation : chaque version peut avoir sa documentation propre dÃ©taillant les changements, ce qui aide les dÃ©veloppeurs consommateurs Ã  sâ€™adapter aux Ã©volutions. En rÃ©sumÃ©, **versionner une API est gÃ©nÃ©ralement considÃ©rÃ© comme une bonne pratique** pour assurer la compatibilitÃ© descendante, permettre des Ã©volutions sans casse, et donner de la flexibilitÃ© aux clients quant au moment oÃ¹ ils adoptent les nouveautÃ©s.

Cependant, cette mÃ©daille a un revers : **supporter plusieurs versions simultanÃ©ment a des coÃ»ts non nÃ©gligeables**, et ces coÃ»ts sont parfois inutiles dans un environnement maÃ®trisÃ©. Voyons quels sont ces inconvÃ©nients.

## Les coÃ»ts et inconvÃ©nients du versionnement d'API

Introduire et maintenir plusieurs versions dâ€™une API entraÃ®ne de la **complexitÃ© additionnelle**. Dâ€™abord, **chaque version supplÃ©mentaire est un code Ã  maintenir en parallÃ¨le** : en cas de bug dÃ©couvert, il faut vÃ©rifier sâ€™il affecte toutes les versions et le corriger partout si nÃ©cessaire. Cela multiplie les efforts de test et de QA, car une correction ou une nouvelle fonctionnalitÃ© doit potentiellement Ãªtre reportÃ©e sur plusieurs branches de code. Comme le formule un expert : _"supporter plus dâ€™une version de quoi que ce soit est pÃ©nible. Trouver un bug dans une version oblige Ã  confirmer son absence dans les autres versions"_. Ã€ lâ€™extrÃªme, on peut se retrouver Ã  maintenir indÃ©finiment de vieilles versions pour quelques clients retardataires, avec le risque dâ€™y introduire des divergences ou des rÃ©gressions.

Ensuite, **le versionnement â€œpar dÃ©fautâ€ peut encourager des changements incompatibles plus frÃ©quents quâ€™il ne faudrait**. Sous prÃ©texte quâ€™une nouvelle version majeure va sortir, des Ã©quipes pourraient accumuler des modifications non rÃ©tro-compatibles dans la v2 â€œpuisque de toute faÃ§on les clients devront sâ€™adapterâ€. Cette mentalitÃ© peut nuire Ã  la stabilitÃ© et Ã  la confiance des consommateurs si la communication des changements nâ€™est pas irrÃ©prochable. De plus, multiplier les versions peut fragmenter votre base de consommateurs : certains resteront sur les anciennes versions pendant que dâ€™autres migrent, rendant lâ€™Ã©cosystÃ¨me global plus hÃ©tÃ©rogÃ¨ne et donc plus difficile Ã  faire Ã©voluer de maniÃ¨re cohÃ©rente.

**La documentation et le support client sâ€™alourdissent Ã©galement.** Chaque version de lâ€™API doit Ãªtre documentÃ©e, avec les diffÃ©rences, les plans de dÃ©prÃ©ciation, etc. Les Ã©quipes consommatrices doivent, elles, gÃ©rer potentiellement plusieurs versions de clients. Tout ceci reprÃ©sente un coÃ»t de communication et de coordination non nÃ©gligeable.

Enfin, comme le souligne Reda Hmeid, beaucoup des problÃ¨mes posÃ©s par le versionnement sont en rÃ©alitÃ© _auto-infligÃ©s_. Avoir plusieurs versions, câ€™est ajouter du poids mort si finalement tous les clients auraient pu utiliser une API unique Ã©volutive. Il note par exemple que _"le versionnage des interfaces nâ€™est souvent quâ€™une faÃ§on de gÃ©rer le changement Ã  lâ€™avantage du propriÃ©taire de lâ€™API, au dÃ©triment de la continuitÃ© pour le client"_. En effet, du point de vue du consommateur, ce qui compte câ€™est que **lâ€™API continue de fonctionner sans quâ€™il ait besoin de modifier son code**. Si on peut garantir cela sans changer dâ€™URL ni de contrat, le besoin dâ€™une nouvelle version distincte est discutable.

En somme, le versionnement apporte une **solution puissante pour gÃ©rer le changement**, mais **il complexifie le cycle de vie** de lâ€™API. Il sâ€™agit dâ€™un compromis: flexibilitÃ© pour le fournisseur et pour les clients les plus Ã  jour, contre lourdeur de maintenance et nÃ©cessitÃ© pour dâ€™autres clients de migrer un jour ou lâ€™autre. **Il convient donc de se demander si ce compromis est toujours justifiÃ©**. _En dÃ©finitive, demandez-vous : â€œLe bÃ©nÃ©fice de ce changement justifie-t-il le temps, lâ€™effort et lâ€™impact de supporter plusieurs versions, aussi bien pour nos consommateurs que pour nous-mÃªmes ?â€_.

Dans bien des cas, notamment **lorsque lâ€™on contrÃ´le lâ€™ensemble des consommateurs**, la rÃ©ponse est **non**. Voyons ces situations oÃ¹ lâ€™on peut raisonnablement **Ã©viter le versionnement** par dÃ©faut.

## Quand peut-on se passer de versionnement ?

### Consommateurs internes sous contrÃ´le

Si votre API est consommÃ©e uniquement en interne, par exemple par vos propres applications frontales ou dâ€™autres microservices de votre entreprise, vous avez une **maÃ®trise totale de lâ€™Ã©cosystÃ¨me**. Cela change la donne : vous pouvez coordonner les dÃ©ploiements des producteurs et consommateurs de lâ€™API pour effectuer des changements **sans avoir Ã  maintenir deux versions en parallÃ¨le** sur le long terme.

Dans un systÃ¨me distribuÃ© basÃ© sur des microservices .NET, il est courant que les diffÃ©rentes Ã©quipes (ou la mÃªme Ã©quipe) gÃ¨rent Ã  la fois l'API fournie et les clients de cette API. Cette situation permet une agilitÃ© que les API publiques nâ€™ont pas : vous pouvez dÃ©cider que _"la version de lâ€™API Ã©volue en mÃªme temps que la version du client Â»_. Autrement dit, dÃ¨s quâ€™un service fournit un nouveau contrat, les services consommateurs sont dÃ©ployÃ©s (ou modifiÃ©s) pour sâ€™aligner sur ce contrat.

Un dÃ©veloppeur tÃ©moignait sur ce point quâ€™il y a _"beaucoup de pratiques logicielles qui nâ€™ont pas de sens quand on contrÃ´le tout en interne. Si vous possÃ©dez Ã  la fois le client et le serveur, un systÃ¨me de versionnement long-terme n'est pas nÃ©cessaire Â»_. Autrement dit, **si vous maÃ®trisez lâ€™ensemble des applications clientes**, vous pouvez souvent vous passer de versionner formellement votre API : il suffit de dÃ©ployer la mise Ã  jour du client en mÃªme temps que celle du serveur. Ceci est particuliÃ¨rement vrai pour une application web SPA (Single-Page Application) ou un frontend qui est dÃ©ployÃ© par vos soins : vous pouvez dÃ©ployer le nouveau frontend simultanÃ©ment Ã  la nouvelle API, assurant que personne (aucun utilisateur) nâ€™utilise lâ€™ancienne version de lâ€™API. Dans ce cas, maintenir deux versions cÃ´te Ã  cÃ´te serait un _overkill_ inutile.

Un autre cas frÃ©quent est celui de microservices pair-Ã -pair au sein dâ€™un systÃ¨me. Par exemple, un microservice **Inventaire** expose une API consommÃ©e par un microservice **Commande**. Si lâ€™API de **Inventaire** change, lâ€™Ã©quipe en charge peut synchroniser la modification avec lâ€™Ã©quipe de **Commande** (ou câ€™est la mÃªme Ã©quipe). PlutÃ´t que de dÃ©ployer _Inventaire v2_ et de garder _Inventaire v1_ actif pendant des mois, on peut choisir de **mettre Ã  jour le service Commande pour quâ€™il utilise immÃ©diatement le nouveau contrat**. Cela nÃ©cessite de la communication et Ã©ventuellement un ordre de dÃ©ploiement prÃ©cis (dâ€™abord dÃ©ployer la nouvelle version dâ€™**Inventaire** qui supporte Ã  la fois lâ€™ancien et le nouveau format, puis dÃ©ployer **Commande**, puis Ã©ventuellement retirer la compatibilitÃ© ancienne cÃ´tÃ© **Inventaire**). Mais tout ceci peut se faire _sans jamais formaliser deux versions dâ€™API diffÃ©rentes aux yeux du client final_. Aux yeux de **Commande**, il y a toujours une seule API **Inventaire**, qui a simplement Ã©voluÃ©.

En bref, **si le nombre de consommateurs de lâ€™API est limitÃ© et connu**, et que vous pouvez les faire Ã©voluer rapidement, le versionnement nâ€™apporte pas grand-chose de plus que ce que de bonnes pratiques de dÃ©ploiement coordonnÃ© permettent dÃ©jÃ . Comme lâ€™exprime un architecte : _"Si l'API n'est consommÃ©e que par vos propres services (donc â€œpas publiqueâ€ dans le sens externe), et quâ€™en plus vous Ãªtes le seul consommateur, la valeur du versionnement est discutable Â»_. Au-delÃ  de 1 consommateur ou d'Ã©quipes diffÃ©rentes, il faut commencer Ã  rÃ©flÃ©chir, mais tant que vous restez **â€œentre vousâ€**, la **contrainte de ne pas casser le client peut Ãªtre gÃ©rÃ©e par des processus internes** plutÃ´t que par du versioning.

### Concevoir des changements non bloquants (Ã©volutivitÃ© sans version)

DÃ©cider de ne pas versionner par dÃ©faut ne signifie pas que lâ€™API ne va **jamais changer**, au contraire, elle va Ã©voluer, mais on va sâ€™efforcer de le faire **sans bris pour les consommateurs**. Il sâ€™agit donc dâ€™adopter une philosophie de conception **Ã©volutive** (_evolvable API_) oÃ¹ lâ€™on privilÃ©gie les modifications rÃ©tro-compatibles et les extensions non ruptures.

Voici quelques **stratÃ©gies de conception et dâ€™Ã©volution** qui permettent dâ€™Ã©viter un versionnement explicite tout en faisant Ã©voluer une API :

- **N'ajoutez que des Ã©lÃ©ments facultatifs** : si vous devez enrichir la rÃ©ponse avec de nouvelles donnÃ©es, ajoutez-les sans supprimer ni modifier les champs existants. Par exemple, si votre rÃ©ponse JSON contient `{ "nom": "X", "age": 30 }` et que vous voulez ajouter le sexe, renvoyez `{ "nom": "X", "age": 30, "sexe": "F" }`. Un client bien conÃ§u ignorera le champ sexe quâ€™il ne connaissait pas. _(âš ï¸ Attention toutefois : certains clients trop stricts pourraient mal tolÃ©rer des champs inconnus dans la rÃ©ponse ; assurez-vous de la tolÃ©rance de vos consommateurs)_. De mÃªme, si vous ajoutez un nouveau champ requis dans une requÃªte, rÃ©flÃ©chissez : peut-il avoir une **valeur par dÃ©faut** ? Si oui, faites-en un paramÃ¨tre optionnel avec un dÃ©faut cÃ´tÃ© serveur, ce qui Ã©vite de casser les anciens appels.
- **Rendez obligatoires les changements vraiment nÃ©cessaires, et rien de plus** : en dâ€™autres termes, _ne faites pas de changement breaking â€œpour le plaisirâ€_. Si vous envisagez de rendre un champ obligatoire lÃ  oÃ¹ il Ã©tait optionnel, demandez-vous sâ€™il est vraiment impossible de le garder optionnel. Comme le dit [Reda Hmeid](https://www.hmeid.com/blog), _"si ce nouveau champ est vraiment obligatoire pour la logique mÃ©tier, pourquoi maintenir une version de lâ€™API qui ne lâ€™exige pas ?"_. Autrement dit, dans la mesure du possible, **Ã©vitez de rendre une ancienne requÃªte invalide**. Parfois, cela signifie que certaines nouvelles rÃ¨gles mÃ©tier doivent Ãªtre gÃ©rÃ©es cÃ´tÃ© serveur sans intervention du client (par exemple, un service peut dÃ©cider quâ€™en lâ€™absence dâ€™un champ optionnel, une valeur par dÃ©faut interne sera utilisÃ©e, plutÃ´t que de rejeter lâ€™appel).
- **Conservez la prise en charge des anciennes conventions en parallÃ¨le des nouvelles, temporairement** : si vous devez _renommer_ un champ ou corriger une erreur (typo dans un nom, etc.), la rÃ¨gle d'or est : _"ne supprimez pas immÃ©diatement l'ancien"_. Vous pouvez accepter les deux orthographes du champ pendant un temps, documenter la nouvelle prÃ©fÃ©rence, puis Ã©ventuellement retirer lâ€™ancienne quand vous Ãªtes sÃ»r que plus personne ne lâ€™envoie. Par exemple, si votre requÃªte attendait `?ordre=asc` et que vous voulez passer Ã  `?triAsc=true`, votre API peut supporter les deux paramÃ¨tres (et peut-Ãªtre ignorer ordre en le dÃ©prÃ©ciant) sans renvoyer dâ€™erreur, le temps que tous les consommateurs passent au nouveau paramÃ¨tre.
- **PrÃ©fÃ©rez de nouveaux endpoints pour de nouvelles fonctionnalitÃ©s majeures** : si la modification change radicalement la structure des donnÃ©es ou le paradigme (par exemple passer d'une API REST Ã  GraphQL, ou fournir des donnÃ©es dans un format complÃ¨tement diffÃ©rent), il peut Ãªtre pertinent de **crÃ©er un nouveau service ou endpoint** sÃ©parÃ©, plutÃ´t que de transformer lâ€™existant de maniÃ¨re incompatible. Dans lâ€™esprit de [Roy Fielding](https://en.wikipedia.org/wiki/Roy_Fielding) (crÃ©ateur de REST), ce nâ€™est pas tant une _nouvelle version_ quâ€™un _nouveau service_ Ã  part entiÃ¨re lorsque le changement est fondamental. Par exemple, GitHub a introduit une API GraphQL Ã  cÃ´tÃ© de son API REST sans simplement lâ€™appeler â€œv4â€ de lâ€™API REST, câ€™est considÃ©rÃ© comme une toute autre API. Cette approche Ã©vite de surcharger la notion de version et de mÃ©langer des approches trÃ¨s diffÃ©rentes sous la mÃªme Ã©tiquette.
- **Documentez votre politique de changement** : si vous choisissez de faire Ã©voluer lâ€™API sans gestion de versions multiples, il est important de clarifier dans votre documentation que _"des changements non breaking peuvent survenir sans incrÃ©ment de version"_. Par exemple, prÃ©ciser que lâ€™API peut Ãªtre enrichie de nouveaux champs ou de nouveaux paramÃ¨tres sans prÃ©avis de version, mais que toute suppression ou modification incompatible sera annoncÃ©e et gÃ©rÃ©e de maniÃ¨re spÃ©cifique. Ainsi vos consommateurs savent Ã  quoi sâ€™attendre et ne conÃ§oivent pas leur client de faÃ§on trop rigide.

En appliquant ces principes, on peut obtenir des **APIs dites â€œÃ©volutivesâ€ (evolvable)**, câ€™est-Ã -dire capables de changer progressivement sans briser leurs consommateurs. Roy Fielding recommande par exemple lâ€™utilisation judicieuse de lâ€™**hypermedia (HATEOAS)** dans les API REST, oÃ¹ les liens entre ressources sont dÃ©couverts dynamiquement par le client. Cela rend possible de modifier lâ€™URL ou la structure des ressources derriÃ¨re les liens sans casser le contrat, puisque le client suit les liens fournis plutÃ´t que dâ€™en construire de son cÃ´tÃ©. Sans aller forcÃ©ment jusquâ€™Ã  implÃ©menter HATEOAS, on peut retenir lâ€™idÃ©e gÃ©nÃ©rale : une API bien conÃ§ue doit minimiser les _breaking changes_ afin de ne pas imposer de mise Ã  jour client. **IdÃ©alement, â€œne cassez jamais vos consommateursâ€ devient la devise**, versioning ou pas versioning.

### Exemple : microservice .NET Ã©volutif sans versionnage explicite

Pour illustrer concrÃ¨tement, prenons lâ€™exemple dâ€™un **microservice .NET** (disons un Web API ASP.NET Core) dans un systÃ¨me de e-commerce modulable. Ce service gÃ¨re les produits et expose des endpoints REST pour que dâ€™autres services (commande, panier, recherche, etc.) puissent consulter les informations produit. Supposons quâ€™Ã  lâ€™origine, lâ€™endpoint `GET /api/produits/{id}` retourne un JSON avec le nom et le prix du produit. Au fil du temps, on souhaite enrichir cette rÃ©ponse avec de nouvelles informations (par exemple, la disponibilitÃ© en stock, le poids, etc.), et modifier certains champs pour coller Ã  de nouvelles exigences mÃ©tier.

Sans versionnement, **comment procÃ©der pour ne pas casser les services consommateurs (internes)** ? On appliquerait les bonnes pratiques ci-dessus : ajouter les champs stock ou poids en plus dans la rÃ©ponse JSON, **sans retirer ni renommer les champs existants**. Un service consommateur qui nâ€™a pas Ã©tÃ© mis Ã  jour pour utiliser ces nouveaux champs continuera de fonctionner comme avant (il ignorera juste les donnÃ©es supplÃ©mentaires). Si lâ€™un des nouveaux champs devait Ãªtre requis pour toutes les commandes, on pourrait dÃ©cider qu'en absence de ce champ dans la requÃªte du client, la valeur par dÃ©faut est assumÃ©e cÃ´tÃ© produit (exemple : si on introduit un champ devise pour le prix, on peut par dÃ©faut considÃ©rer `devise="CAD"` si un ancien client ne fournit rien). Ainsi, **le microservice _Produits_ devient plus intelligent pour prÃ©server la compatibilitÃ©**.

CÃ´tÃ© implÃ©mentation .NET, on peut tirer profit de fonctionnalitÃ©s du framework : ASP.NET Core, par dÃ©faut, **ignore gracieusement les champs JSON quâ€™il ne connaÃ®t pas** lors de la dÃ©sÃ©rialisation dâ€™une requÃªte dans un objet C#. De mÃªme, on peut utiliser des paramÃ¨tres facultatifs dans les mÃ©thodes de contrÃ´leur, avec des valeurs par dÃ©faut en C#. Par exemple, `public IActionResult ObtenirProduits(guid id, string devise = "CAD")` acceptera les appels ne spÃ©cifiant pas devise et utilisera "CAD" par dÃ©faut, ce qui signifie quâ€™un ancien client  qui ne connaÃ®t pas ce paramÃ¨tre continuera Ã  obtenir un comportement cohÃ©rent. Enfin, pour un renommage de champ, ASP.NET Core permet dâ€™accepter plusieurs bindings (via des attributs `[FromQuery(Name="...")]` par exemple) pour un mÃªme paramÃ¨tre, ce qui facilite la transition.

Si vraiment un changement nâ€™est pas gÃ©rable de faÃ§on transparente (par exemple, on veut complÃ¨tement refondre le modÃ¨le de donnÃ©es produit), on peut choisir de **crÃ©er un nouvel endpoint** comme `/api/nouveaux-produits/{id}` ou `/api/produits2/{id}` _sans toucher Ã  l'ancien_. Ce nâ€™est pas trÃ¨s diffÃ©rent dâ€™une nouvelle version, sauf quâ€™on ne lâ€™annonce pas comme tel globalement ; on considÃ¨re que câ€™est une **autre ressource**. Les consommateurs intÃ©ressÃ©s migreront vers le nouvel endpoint tandis que les autres pourront, pendant un temps, continuer Ã  utiliser lâ€™ancien. La diffÃ©rence subtile est qu'on ne gÃ¨re pas Ã§a via un cadre formel de â€œversions v1/v2â€ annoncÃ© Ã  tout le monde, mais via de la documentation et de la dÃ©prÃ©ciation ciblÃ©e. Souvent, en interne, on peut se permettre de retirer lâ€™ancien endpoint assez rapidement une fois que les consommateurs ont migrÃ© (puisquâ€™on peut les identifier prÃ©cisÃ©ment). Ainsi on Ã©vite de faire vivre deux versions trop longtemps.

En rÃ©sumÃ©, dans un contexte de microservices .NET internes, **il est tout Ã  fait envisageable de faire Ã©voluer les APIs sans mettre en place de versionnement global par dÃ©faut**. Cela requiert de la discipline (notamment pour ne pas briser le contrat par inadvertance) et de la coordination, mais en Ã©change on garde un systÃ¨me plus simple : Ã  tout instant, chaque service nâ€™expose quâ€™une interface (Ã©volutive) au lieu de devoir en maintenir plusieurs en parallÃ¨le.

## Quand le versionnement devient-il indispensable ?

Tout ce qui prÃ©cÃ¨de ne signifie pas que le versionnement est Ã  proscrire en toute circonstance. **Certaines situations le rendent quasiment indispensable** :

- **API publiques ou ouvertes Ã  des tiers** : Si votre API est consommÃ©e par des applications ou dÃ©veloppeurs externes Ã  votre organisation (partenaires, clients, grand public), vous nâ€™avez pas la main sur les mises Ã  jour de ces consommateurs. Ils peuvent tarder Ã  adopter vos changements, ou ne jamais le faire sâ€™ils nâ€™ont pas le besoin ou les ressources. Dans ce cas, il est dangereux dâ€™Ã©voluer sans versionner, car vous risquez de briser des intÃ©grations en production chez autrui. Microsoft le rappelle : _"si votre API est publique et utilisÃ©e par de multiples applications clientes, vous ne pourrez typiquement pas forcer tous les clients Ã  se mettre Ã  jour immÃ©diatement... il faut dÃ©ployer de nouvelles versions dâ€™API en parallÃ¨le des anciennes pendant un certain temps"_. Câ€™est exactement le scÃ©nario pour lequel le versionnement a Ã©tÃ© popularisÃ©. Par exemple, les APIs de Twitter, Facebook, etc., ont des versions multiples gÃ©rÃ©es sur de longues pÃ©riodes pour laisser le temps aux intÃ©grateurs de migrer.
- **Applications mobiles dÃ©ployÃ©es chez les utilisateurs** : Les applications mobiles sont un cas particulier des clients externes, mÃªme si câ€™est _votre_ application mobile consommant _votre_ API, une fois lâ€™application publiÃ©e, vous ne contrÃ´lez pas quand les utilisateurs la mettront Ã  jour. Beaucoup gardent dâ€™anciennes versions de lâ€™application installÃ©es, parfois pendant des annÃ©es. Si une ancienne version de lâ€™application dialogue avec votre API, vous serez contraint soit de la **tuer** (la rendre inutilisable) en changeant lâ€™API sans support backward, soit de maintenir une compatibilitÃ©. Le versionnement dâ€™API est alors une solution pour **continuer Ã  supporter les anciennes versions de lâ€™application mobile** sans empÃªcher dâ€™avancer. Un dÃ©veloppeur partageait ainsi : _"attendez-vous Ã  ce que des utilisateurs exÃ©cutent votre application mobile pendant trÃ¨s longtemps... la longue traÃ®ne des versions mobiles est rÃ©elle, surtout sur Android, il faut la prendre en compte"_. ConcrÃ¨tement, beaucoup dâ€™Ã©diteurs dâ€™API fixent des politiques (par exemple : _"on supporte chaque version dâ€™API pendant 2 ans_ ou _"on supporte les 3 derniÃ¨res versions majeures"_). Cela permet de planifier la dÃ©precation progressive, en communiquant aux clients quâ€™ils doivent migrer avant une date butoir.
- **Cas de refonte complÃ¨te ou de rupture totale** : Parfois, malgrÃ© tous vos efforts, une Ã©volution majeure nÃ©cessite une rupture franche. Par exemple, une refonte de lâ€™architecture (passage de REST Ã  gRPC ou GraphQL), ou des changements lÃ©gaux/rÃ©glementaires qui imposent de nouvelles rÃ©ponses non compatibles avec lâ€™existant. Dans ces cas, **une nouvelle version dâ€™API sâ€™impose** â€“ ou comme dirait Fielding, une _nouvelle API_ tout court. On peut la signaler par un numÃ©ro de version (v2) dans lâ€™URL ou le `header Accept`, etc. Lâ€™important est de planifier cette transition : souvent, on introduit la v2 en parallÃ¨le de la v1, on incite progressivement les consommateurs Ã  migrer, puis on finit par Ã©teindre la v1 quand son usage tombe suffisamment (ou Ã  une Ã©chÃ©ance annoncÃ©e). Ce processus doit Ãªtre gÃ©rÃ© avec soin (communication, support, peut-Ãªtre outillage de _monitoring_ pour voir qui utilise quoi). Ce type de changement lourd est heureusement peu frÃ©quent si lâ€™on suit une philosophie dâ€™Ã©volution continue. Dâ€™ailleurs, comme mentionnÃ© prÃ©cÃ©demment, GitHub nâ€™a eu que trÃ¨s peu de versions en plus dâ€™une dÃ©cennie, la derniÃ¨re en date correspondant Ã  un changement dâ€™architecture (GraphQL) plus quâ€™Ã  de simples modifications de champs.

En rÃ©sumÃ©, **le versionnement est surtout nÃ©cessaire quand on ne peut pas contrÃ´ler lâ€™adoption du changement cÃ´tÃ© client**. Si tous vos consommateurs ne peuvent pas Ãªtre mis Ã  jour instantanÃ©ment et indÃ©pendamment (typiquement le cas grand public), alors versionner Ã©vite un choix cornÃ©lien entre stagnation et casse. Ã€ lâ€™inverse, **si vous avez la maÃ®trise des deux bouts de la chaÃ®ne**, vous pouvez souvent vous en passer, surtout en restant vigilant Ã  ne pas briser le contrat de lâ€™API.

## Conclusion : rÃ©flÃ©chissez avant de versionner par dÃ©faut

Le **versionnement dâ€™API nâ€™est pas une fin en soi**, câ€™est un outil parmi dâ€™autres pour gÃ©rer lâ€™Ã©volution des systÃ¨mes distribuÃ©s. Comme tout outil, il a ses avantages et ses inconvÃ©nients. Dans un contexte de microservices en .NET au sein dâ€™une mÃªme organisation, oÃ¹ lâ€™on a un contrÃ´le sur les clients, il est parfaitement envisageable de **sâ€™abstenir de versionner tant que ce nâ€™est pas nÃ©cessaire**, et de faire Ã©voluer son API de maniÃ¨re continue et compatibile. Cette approche peut simplifier grandement la maintenance en Ã©vitant le fardeau de plusieurs versions simultanÃ©es.

Avant de cÃ©der au rÃ©flexe de crÃ©er une v1 par dÃ©faut, posez-vous les questions suivantes : _Qui consomme mon API ? Puis-je mettre Ã  jour ces consommateurs facilement ? Ce changement va-t-il rÃ©ellement en briser certains, ou puis-je lâ€™introduire de faÃ§on transparente ? Suis-je prÃªt Ã  supporter deux versions en parallÃ¨le, et combien de temps ?_ Souvent, un effort de conception initial permet dâ€™Ã©viter la rupture : _"Faites le travail difficile dÃ¨s la phase de design, et vous obtiendrez des APIs faciles Ã  utiliser, Ã©volutives, maintenables, qui satisferont tout le monde"_.

En fin de compte, **le meilleur service Ã  rendre aux consommateurs de votre API est de la rendre aussi facile et stable que possible**. Si vous pouvez offrir de nouvelles fonctionnalitÃ©s sans imposer de migration forcÃ©e, tout le monde y gagne. Le versionnement reste un outil prÃ©cieux dans lâ€™arsenal de lâ€™architecte, mais **il nâ€™est pas obligatoire par dÃ©faut**. Utilisez-le consciemment, lorsque le contexte lâ€™exige, et non par dogmatisme. Comme le rÃ©sume [Roy Fielding](https://en.wikipedia.org/wiki/Roy_Fielding) de faÃ§on provocante : _"Quelle est la meilleure faÃ§on de versionner une API ? Ne le faites pas"_. Sans aller forcÃ©ment jusque-lÃ  pour chaque situation, son conseil rappelle quâ€™il vaut mieux **Ã©viter les changements incompatibles** que dâ€™en gÃ©rer les consÃ©quences via une n-iÃ¨me version. En dâ€™autres termes, _mieux vaut prÃ©venir que guÃ©rir_ : concevez vos APIs pour quâ€™elles Ã©voluent en douceur, et vous nâ€™aurez peut-Ãªtre jamais Ã  sortir de v2 ğŸ˜‰.
