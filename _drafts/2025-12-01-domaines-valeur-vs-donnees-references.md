---
title: Domaines de valeurs vs Donn√©es de r√©f√©rence - Comprendre la diff√©rence
date: 2025-12-01 20:00:00 -0400
categories: [architecture]
tags: []
---

Comprendre la diff√©rence entre un **domaine de valeurs** et des **donn√©es de r√©f√©rence** est essentiel lorsqu‚Äôon con√ßoit des syst√®mes distribu√©s. Ces deux notions touchent √† la gestion de la **donn√©e** et √† sa **gouvernance**, et saisir leur r√¥le respectif aide √† b√¢tir des syst√®mes plus robustes et coh√©rents.

Cet article m‚Äôa √©t√© inspir√© par une discussion au travail o√π la majorit√© des membres autour de la table n‚Äôavaient pas la m√™me d√©finition de ces deux termes. Cette divergence montre √† quel point la distinction n‚Äôest pas toujours √©vidente, m√™me parmi des professionnels exp√©riment√©s, et peut rapidement mener √† des incompr√©hensions dans la conception d‚Äôun syst√®me.

Nous allons donc explorer ensemble ce que sont un domaine de valeurs et des donn√©es de r√©f√©rence, √† quoi ils servent, comment les diff√©rencier, qui en est responsable, et enfin examiner des exemples et des strat√©gies pour limiter l‚Äôimpact de la distribution des donn√©es entre services.

## Qu‚Äôest-ce qu‚Äôun _domaine de valeurs_ ?

Un **domaine de valeurs** repr√©sente l‚Äôensemble des valeurs possibles qu‚Äôune donn√©e (ou attribut) peut prendre. En d‚Äôautres termes, c‚Äôest une liste de valeurs autoris√©es pour un champ de donn√©es donn√©. Par exemple, si l‚Äôon consid√®re un attribut `Statut de commande`, son domaine de valeurs pourrait √™tre : `EnCours`, `Exp√©di√©e`, `Livr√©e` ou `Annul√©e`. Ce concept √©quivaut √† un _vocabulaire contr√¥l√©_ ou √† une _liste de valeurs permises_ pour un attribut.

Dans un syst√®me d‚Äôinformation, les domaines de valeurs servent √† **valider et contraindre les donn√©es**. Ils garantissent l‚Äôint√©grit√© en limitant les entr√©es √† un jeu pr√©d√©fini de **valeurs acceptables**. Souvent, ces domaines de valeurs se mat√©rialisent par des _√©num√©rations_ dans le code (par exemple, un `enum` en C#) ou par des tables de correspondance en base de donn√©es. Par exemple, une application .NET pourrait d√©finir un `enum` `DeviseMonetaire` qui ne peut valoir que `CAD`, `USD`, `EUR`, etc., refl√©tant le domaine de valeurs des devises autoris√©es.

üí° Il est important de noter qu‚Äôun domaine de valeurs est une notion **conceptuelle**, c‚Äôest la d√©finition du p√©rim√®tre des valeurs possibles pour une donn√©e. La r√©alisation concr√®te de ce domaine (c‚Äôest-√†-dire la liste sp√©cifique des valeurs actuelles) est souvent g√©r√©e via les donn√©es de r√©f√©rence, surtout lorsque ces valeurs peuvent changer ou doivent √™tre partag√©es.

## Qu‚Äôest-ce que des _donn√©es de r√©f√©rence_ ?

Les **donn√©es de r√©f√©rence** (_reference data_) sont les donn√©es qui servent √† **caract√©riser ou classer d‚Äôautres donn√©es**. Autrement dit, ce sont g√©n√©ralement des listes ou tables de valeurs partag√©es, stables dans le temps, et communes √† plusieurs syst√®mes. Elles correspondent justement aux contenus des domaines de valeurs : ce sont les valeurs concr√®tes permises. Par exemple, la liste des [codes pays ISO 3166](https://www.iso.org/fr/iso-3166-country-codes.html), la liste des devises, les codes postaux, etc., sont des donn√©es de r√©f√©rence typiques.

Les donn√©es de r√©f√©rence ont plusieurs caract√©ristiques cl√©s :

- **Stabilit√© relative** : elles √©voluent rarement et de mani√®re contr√¥l√©e. Par exemple, la liste des pays du monde change tr√®s peu fr√©quemment. Cette stabilit√© signifie qu‚Äôon peut les consid√©rer comme _semi-statiques_ ou _immuables du point de vue des clients_.
- **Port√©e transverse** : elles sont souvent utilis√©es par de **nombreuses applications ou services** diff√©rents. Par exemple, plusieurs microservices peuvent avoir besoin de conna√Ætre la liste des devises ou des pays. √Ä ce titre, les donn√©es de r√©f√©rence jouent un r√¥le de _vocabulaire commun_ √† l‚Äô√©chelle de l‚Äôentreprise.
- **Autorit√© centralis√©e** : id√©alement, il existe une _source faisant autorit√©_ qui g√®re chaque donn√©e de r√©f√©rence (par exemple, un service ou module central, ou m√™me un organisme externe dans le cas des normes internationales). Ainsi, on √©vite que chaque service d√©finisse sa propre version divergente d‚Äôune liste de valeurs critique.

En somme, les donn√©es de r√©f√©rence fournissent le **contenu des domaines de valeurs** partag√©s. Pour reprendre l‚Äôexemple pr√©c√©dent, si le domaine de valeurs d‚Äôun attribut `Devise` est l‚Äôensemble des devises valides, la table de r√©f√©rence des devises contiendra les entr√©es r√©elles (`CAD`, `USD`, `EUR`, etc.) avec √©ventuellement des m√©tadonn√©es (libell√©, symbole, taux de change, etc.).

Selon un glossaire de l‚Äôarchitecture des donn√©es : "les donn√©es de r√©f√©rence correspondent g√©n√©ralement √† des _domaines de valeurs_, des tables de correspondance ou des ontologies". Cela souligne bien le lien √©troit entre le concept de domaine de valeurs et la mat√©rialisation en tant que donn√©es de r√©f√©rence.

## √Ä quoi servent domaines de valeurs et donn√©es de r√©f√©rence ?

**Dans le domaine applicatif (microservice individuel)**, un domaine de valeurs permet de **restreindre les donn√©es admissibles** et de refl√©ter les r√®gles m√©tier. Par exemple, un microservice de gestion des commandes peut avoir un domaine de valeurs pour le statut d‚Äôune commande ou les modes de paiement accept√©s. Cela sert √† **assurer la coh√©rence interne** du service : impossible de cr√©er une commande avec un statut inconnu ou un mode de paiement invalide, car ces attributs sont limit√©s √† un ensemble de valeurs pr√©d√©finies.

**Au niveau transversal (syst√®me global)**, les donn√©es de r√©f√©rence servent √† **harmoniser les donn√©es** et faciliter les int√©grations. √âtant partag√©es par plusieurs composants, elles fournissent un langage commun. Par exemple, si tous les services utilisent les m√™mes codes de pays ou les m√™mes codes de cat√©gories produit, il devient plus ais√© pour eux de communiquer et d‚Äô√©changer des informations sans ambigu√Øt√©. Les donn√©es de r√©f√©rence aident aussi √† **classifier** ou **qualifier** les donn√©es transactionnelles (par exemple, assigner une cat√©gorie normalis√©e √† un produit, ou indiquer la devise d‚Äôun montant).

En r√©sum√©, on utilise les domaines de valeurs et donn√©es de r√©f√©rence pour garantir **qualit√©, coh√©rence et validit√©** des donn√©es :

- Les domaines de valeurs (souvent impl√©ment√©s localement dans un service) assurent la validit√© des donn√©es en entr√©e et coh√©rence avec les r√®gles m√©tier sp√©cifiques du service.
- Les donn√©es de r√©f√©rence (souvent partag√©es) assurent que tous les services parlent le m√™me langage pour les informations communes, ce qui **am√©liore la qualit√© globale des donn√©es de l‚Äôentreprise**.

## Diff√©rences entre _domaine de valeurs_ et _donn√©es de r√©f√©rence_

Bien que ces concepts soient li√©s, on peut les diff√©rencier sur plusieurs aspects :

- **Nature conceptuelle versus concr√®te** : Un **domaine de valeurs** est le concept ou _le cadre_ des valeurs autoris√©es pour un attribut. Les **donn√©es de r√©f√©rence** en sont la manifestation concr√®te, ce sont les √©l√©ments de donn√©es eux-m√™mes qui remplissent ce domaine. Par analogie, si le domaine de valeurs est une r√®gle ("les statuts possibles sont‚Ä¶"), les donn√©es de r√©f√©rence sont la liste effective (`EnCours`, `Exp√©di√©e`, ‚Ä¶).
- **Port√©e et r√©utilisation** : Un domaine de valeurs peut √™tre **local √† un service** ou contexte m√©tier. Par exemple, le microservice _Commande_ d√©finit en interne les statuts de commande qu‚Äôil g√®re, ces valeurs lui sont propres. En revanche, les donn√©es de r√©f√©rence ont souvent une port√©e **transversale ou organisationnelle**. Elles sont **partag√©es par plusieurs applications ou services** au sein du syst√®me informatique. Par exemple, la liste des pays est partag√©e entre les services `Client` (pour les adresses), `Commande` (pour les adresses de livraison), `Paiement` (pour les transactions internationales), etc.
- **Responsabilit√© (ownership)** : Le **domaine de valeurs** d‚Äôun attribut appartenant √† un microservice est g√©n√©ralement sous la responsabilit√© de ce microservice-m√™me (ou de l‚Äô√©quipe m√©tier correspondante). Ce sont les _experts du domaine_ ou l‚Äô√©quipe de d√©veloppement de ce service qui d√©cident, par exemple, quels statuts une commande peut avoir.  
  
  En revanche, les **donn√©es de r√©f√©rence** sont souvent g√©r√©es par un **entit√© propri√©taire d√©di√©e**. Cela peut √™tre :
  - un _service de r√©f√©rence_ central (par exemple, un microservice **Catalogue** qui fournit la liste des produits et cat√©gories √† tous les autres, ou un service **G√©ographie** qui fournit pays et r√©gions) ;
  - ou un syst√®me externe (par exemple, les codes ISO proviennent d‚Äôun organisme externe, mais l‚Äôentreprise doit tout de m√™me les g√©rer en interne via un r√©f√©rentiel).
  Une bonne gouvernance microservices recommande d‚Äô√©tablir une _strat√©gie solide de gestion des donn√©es de r√©f√©rence_ pour accompagner la distribution de ces donn√©es. Cela implique de savoir **qui est responsable** de la mise √† jour et de la diffusion de chaque r√©f√©rentiel de valeurs partag√©es.
- **√âvolution** : Les domaines de valeurs et les donn√©es de r√©f√©rence sont en g√©n√©ral stables, mais leurs √©volutions se g√®rent diff√©remment. Un domaine de valeurs strictement local peut √©voluer au rythme des besoins m√©tier du service (en ajoutant un nouveau statut, par exemple). Ces modifications impliquent souvent des changements de code ou de sch√©ma de base de donn√©es dans le microservice.  
Les donn√©es de r√©f√©rence, elles, √©voluent via un processus ma√Ætris√©, parfois plus **centralis√©**. Par exemple, ajouter un nouveau pays dans la liste ISO requiert de mettre √† jour le r√©f√©rentiel central, puis de propager cette information aux services consommateurs. Cela se fait de mani√®re coordonn√©e pour pr√©server la coh√©rence globale. En pratique, on cherche √† ce que les donn√©es de r√©f√©rence gardent une _qualit√© √©lev√©e et uniforme_, √† travers la ma√Ætrise de leur cycle de vie (d‚Äôo√π l‚Äôexistence de pratiques comme le _Master Data Management_ (MDM) de r√©f√©rence pour certains r√©f√©rentiels).
- **Impl√©mentation technique** : Dans une application .NET par exemple, un domaine de valeurs local peut √™tre impl√©ment√© simplement via une √©num√©ration ou une liste cod√©e en dur, car le service _sait_ quelles valeurs il g√®re. √Ä l‚Äôinverse, une donn√©e de r√©f√©rence est souvent stock√©e dans une **base de donn√©es** ou un **fichier de configuration** partag√©, voire expos√©e via une **API REST** d√©di√©e par le service qui la poss√®de. On peut retrouver la donn√©e de r√©f√©rence sous forme de table SQL, de fichier JSON/XML de configuration, etc., s√©par√©e du code m√©tier afin de pouvoir la mettre √† jour sans red√©ployer tous les services.

En synth√®se, le domaine de valeurs est un concept plus **local et conceptuel**, tandis que la donn√©e de r√©f√©rence est **globale (ou partag√©e) et concr√®te**. D‚Äôailleurs, on constate que dans la litt√©rature, on a tendance √† dire que si un attribut a un _domaine de valeurs pr√©cis_, alors cette liste de valeurs constitue justement une **donn√©e de r√©f√©rence**. La fronti√®re peut donc √™tre subtile : tout d√©pend si cette liste de valeurs reste confin√©e √† un seul contexte ou si elle devient un r√©f√©rentiel pour l‚Äôensemble du syst√®me.

## Exemples dans une architecture microservices .NET

Consid√©rons une application distribu√©e, b√¢tie sur une architecture microservices avec des services en ASP.NET Core, chacun ayant sa propre base de donn√©es (principe `Database per service` o√π chaque microservice g√®re **ses** donn√©es de fa√ßon autonome).

Voici quelques exemples concrets de domaines de valeurs et de donn√©es de r√©f√©rence dans ce contexte :

- **Service Commande** : Ce microservice g√®re les commandes clients. En interne, il d√©finit un domaine de valeurs pour l‚Äôattribut **Statut** d‚Äôune commande (par exemple, `Cr√©√©e`, `EnCours`, `Exp√©di√©e`, `Livr√©e`, `Annul√©e`). C‚Äôest un domaine de valeurs propre au service _Commande_, refl√©tant son cycle de vie m√©tier. Ces valeurs peuvent √™tre impl√©ment√©es comme un `enum` C# `OrderStatus`. Par ailleurs, le service _Commande_ peut avoir besoin de la liste des **Modes de paiement** accept√©s (carte de cr√©dit, PayPal, virement, etc.) pour valider les paiements. Si cette liste est sp√©cifique √† la logique de commande, elle pourrait √™tre g√©r√©e localement. Toutefois, si les modes de paiement sont partag√©s avec un service de _Paiement_, ils pourraient alors √™tre consid√©r√©s comme des donn√©es de r√©f√©rence partag√©es.
- **Service Produit/Catalogue** : Ce service g√®re le catalogue de produits. Il contient par exemple la liste des **Cat√©gories de produit** (√©lectronique, habillement, maison, etc.). Ces cat√©gories sont des donn√©es de r√©f√©rence classiques car _plusieurs services_ vont les utiliser : le service _Produit_ (pour attribuer une cat√©gorie √† chaque produit), le service _Recherche_ ou _Recommandation_ (pour filtrer/parcourir par cat√©gorie), voire le service _Reporting_ (pour des statistiques par cat√©gorie). La liste des cat√©gories produit serait stock√©e dans le service _Catalogue_ (par exemple dans une table Categories), ce service faisant autorit√© sur cette donn√©e. D‚Äôun point de vue des autres microservices, _Cat√©gorie_ est un attribut dont le domaine de valeurs est "la liste des cat√©gories valides", liste fournie par le service _Produit/Catalogue_ via une API ou un √©v√©nement.
- **Service Localisation** : Imaginez un microservice d√©di√© aux donn√©es g√©ographiques (pays, r√©gions, villes). Ce service h√©berge la table de r√©f√©rence des **pays** du monde, avec leur code ISO, nom, etc. Ces donn√©es de r√©f√©rence de localisation seront utilis√©es par **tous les autres services** qui manipulent des adresses ou des donn√©es locales (service `Client` pour l‚Äôadresse du client, service `Livraison` pour l‚Äôadresse de livraison, etc.). Plut√¥t que chaque service ait sa propre version de la liste des pays, ils consomment celle du service _Localisation_. Ici, le domaine de valeurs de l‚Äôattribut `Pays` pour une adresse est d√©fini par la donn√©e de r√©f√©rence centralis√©e des pays. Le service _Localisation_ est propri√©taire de ces donn√©es de r√©f√©rence et en assure la mise √† jour (par exemple lorsqu‚Äôun nouveau pays est reconnu, ou qu‚Äôun nom change).
- **Service Utilisateur** : Ce service g√®re les comptes utilisateurs. Il peut avoir des domaines de valeurs internes, par exemple pour le type de compte (`Admin`, `Client`, `Support`, ‚Ä¶) ou pour l‚Äô√©tat du compte (`Actif`, `Inactif`, `Suspendu`). Ces valeurs √©tant propres √† la logique du service _Utilisateur_, on les traite comme des domaines de valeurs locaux. En revanche, le service _Utilisateur_ pourrait r√©f√©rencer des donn√©es de r√©f√©rence externes, par exemple la liste des **questions de s√©curit√©** standardis√©es (si on consid√®re cela comme un r√©f√©rentiel commun) ou la liste des langues pour les pr√©f√©rences linguistiques (souvent g√©r√©e comme r√©f√©rence globale).

Dans chacun de ces exemples, on voit que la d√©cision de ce qui constitue un domaine de valeurs local ou une donn√©e de r√©f√©rence partag√©e d√©pend de la **n√©cessit√© de partage et de coh√©rence** √† l‚Äô√©chelle du syst√®me. Une r√®gle d‚Äôor en microservices est que chaque service est **ma√Ætre de sa propre base de donn√©es et de ses donn√©es m√©tier**, et que le partage de donn√©es se fait via des API ou des √©v√©nements, pas via une base commune. Ainsi, si plusieurs services ont besoin d‚Äôune m√™me liste de valeurs, on envisage d‚Äôen faire des donn√©es de r√©f√©rence g√©r√©es par un service et consomm√©es par les autres, plut√¥t que de dupliquer sans synchronisation.

## Limiter l‚Äôimpact des appels inter-services pour les donn√©es de r√©f√©rence

Un d√©fi courant en architecture microservices est la **consommation intensive de donn√©es d√©tenues par un autre service**. Par exemple, si le service _Commande_ doit interroger le service _Localisation_ √† chaque commande pour valider un code pays, cela peut entra√Æner une forte latence ou une d√©pendance excessive au service _Localisation_.

Plusieurs strat√©gies existent pour r√©duire cet impact tout en maintenant la coh√©rence des donn√©es :

- **Mise en cache locale** : Chaque microservice consommateur peut mettre en cache les donn√©es de r√©f√©rence dont il a besoin. Par exemple, au d√©marrage, le service _Commande_ pourrait charger la liste compl√®te des pays depuis _Localisation_ et la conserver en m√©moire (ou dans une cache distribu√©e) pour valider les adresses sans devoir appeler le service distant √† chaque fois. Cela correspond au mod√®le [Cache-Aside](https://learn.microsoft.com/en-us/azure/architecture/patterns/cache-aside), am√©liorant la performance en **r√©duisant les appels directs** et la latence. En .NET, on pourrait utiliser [MemoryCache](https://learn.microsoft.com/en-us/dotnet/api/system.runtime.caching.memorycache) ou une cache Redis distribu√©e pour stocker temporairement ces donn√©es de r√©f√©rence. L‚Äô**inconv√©nient** est qu‚Äôil faut g√©rer l‚Äôexpiration ou l‚Äôinvalidation de la cache pour ne pas utiliser des donn√©es obsol√®tes trop longtemps.
- **R√©plication par service** : Une approche plus radicale, parfois utilis√©e, est de dupliquer la donn√©e de r√©f√©rence dans chaque base locale des services concern√©s. Par exemple, les services _Client_ et _Commande_ pourraient chacun avoir une table Country synchronis√©e p√©riodiquement avec le service _Localisation_. Ainsi, les lectures se font localement, √©liminant la d√©pendance en temps r√©el. La question est alors **comment synchroniser** ces copies pour qu‚Äôelles restent √† jour. Des solutions modernes incluent le _Change Data Capture (CDC)_ : capturer les modifications dans la base du service r√©f√©rentiel et les propager vers les autres bases en temps r√©el via des √©v√©nements ou des messages. Par exemple, avec [Debezium](https://debezium.io/) + Kafka, on peut diffuser chaque changement de la table des pays vers les services abonn√©s pour une mise √† jour imm√©diate. Moins complexe, on peut aussi exposer une API permettant aux services de rafra√Æchir p√©riodiquement leur copie (par exemple, un endpoint `/countries?modifiedSince=‚Ä¶` sur _Localisation_).  
  > ‚ö†Ô∏è **Attention** : cette duplication va √† l‚Äôencontre du principe de source unique de v√©rit√©, donc il faut une gouvernance **stricte** : un service reste le **ma√Ætre** des donn√©es (par exemple, _Localisation_ est ma√Ætre des pays) et les autres ne font que conserver une copie en lecture seule. On obtient une **consistance √©ventuelle** : il peut y avoir un l√©ger d√©calage temporel apr√®s une mise √† jour, mais on accepte ce compromis pour de meilleures performances locales.
- **Approche "Reference Data Holder" (service r√©f√©rentiel central optimis√©)** : Il s‚Äôagit d‚Äôun **service sp√©cialis√©** qui fournit les donn√©es de r√©f√©rence de mani√®re tr√®s optimis√©e pour la consultation par d‚Äôautres. Par exemple, un tel service pourrait offrir une **API de t√©l√©chargement complet** du r√©f√©rentiel (afin qu‚Äôun client puisse r√©cup√©rer _toutes_ les donn√©es de r√©f√©rence d‚Äôun coup et les stocker localement) ou des requ√™tes filtr√©es, en plus des appels unitaires classiques. L‚Äôid√©e est de r√©duire le nombre d‚Äôappels r√©seau en offrant aux consommateurs la possibilit√© de r√©cup√©rer efficacement l‚Äôensemble du _domaine de valeurs_ dont ils ont besoin. Ce pattern, parfois appel√© _Reference Data Holder_, pr√©conise de **n‚Äôautoriser que des op√©rations de lecture** sur ce service (pas de cr√©ation/modification c√¥t√© clients). Le service est ainsi le point central de v√©rit√©, mais il encourage les consommateurs √† embarquer une copie locale pour usage intensif. Un exemple serait une API `/api/v1/countries` retournant la liste compl√®te des pays, que chaque service client appellerait au d√©marrage ou lors d‚Äôune mise √† jour d√©tect√©e, √©vitant ainsi des appels r√©p√©t√©s pour chaque pays individuellement.
- **Combiner cache et notifications d‚Äô√©v√©nements** : Une pratique tr√®s efficace est d‚Äôutiliser une cache locale au service consommateur tout en √©coutant les **√©v√©nements de mise √† jour** √©mis par le service r√©f√©rentiel. Par exemple, le service _Localisation_ diffuse un √©v√©nement `CountryUpdated` lorsqu‚Äôune donn√©e pays change. Le service _Client_ qui a en cache la liste des pays peut consommer cet √©v√©nement et ainsi invalider ou mettre √† jour sa cache en cons√©quence. Ainsi, la cache est toujours presque √† jour. Cette approche utilise l‚Äôarchitecture √©v√©nementielle pour allier la performance (lecture locale) et la coh√©rence (notifications de changements).

Chaque strat√©gie a ses **avantages et compromis** : la cache locale et la duplication am√©liorent les performances et la r√©silience face √† l‚Äôindisponibilit√© d‚Äôun service tiers, mais introduisent de la duplication de donn√©es et la n√©cessit√© de g√©rer la synchronicit√© des mises √† jour. √Ä l‚Äôinverse, interroger syst√©matiquement le service de r√©f√©rence garantit des donn√©es √† jour √† 100%, mais au prix d‚Äôune latence accrue et d‚Äôune d√©pendance forte (si le service de r√©f√©rence tombe, les fonctionnalit√©s d√©pendantes tombent aussi). Souvent, un √©quilibre pragmatique est recherch√© : par exemple, mettre en cache les donn√©es de r√©f√©rence les plus souvent lues en tol√©rant qu‚Äôelles soient rafra√Æchies toutes les X heures.

Il est √©galement recommand√© d‚Äô**√©viter autant que possible les appels synchrones intensifs inter-services** en repensant parfois le besoin : si un service A doit constamment conna√Ætre une info d√©tenue par B, c‚Äôest un signal qu‚Äôil faut peut-√™tre rapprocher ces donn√©es de A. En microservices, on privil√©gie le _Decoupling_ mais il faut faire attention √† ne pas cr√©er un _couplage fort par les donn√©es_ en sous-estimant l‚Äôusage intensif. L‚Äôapproche par √©v√©nements (publication/abonnement) est souvent plus adapt√©e pour propager les donn√©es de r√©f√©rence aux endroits qui en ont besoin, sans verrouiller les services dans une interaction synchrone.

## Conclusion

**Domaines de valeurs** et **donn√©es de r√©f√©rence** sont deux notions incontournables en conception de syst√®mes distribu√©s. Le domaine de valeurs d√©finit _le cadre_ des valeurs admissibles pour une information, tandis que la donn√©e de r√©f√©rence en est l‚Äôimpl√©mentation concr√®te, souvent partag√©e √† travers l‚Äôorganisation. Les deux contribuent √† am√©liorer la qualit√©, la coh√©rence et la fiabilit√© des donn√©es : l‚Äôun au niveau local (coh√©rence m√©tier interne), l‚Äôautre au niveau global (standardisation interservices).

Dans une architecture microservices .NET, bien g√©rer ces concepts signifie **clarifier qui poss√®de quelle donn√©e**, et comment les services acc√®dent aux informations dont ils ont besoin sans compromettre ni l‚Äôautonomie des services, ni la performance. Une gouvernance efficace des donn√©es de r√©f√©rence est essentielle, car les donn√©es fondamentales d‚Äôentreprise sont consomm√©es partout tout en √©tant stock√©es dans des bases locales distinctes.

En diff√©renciant correctement domaines de valeurs et donn√©es de r√©f√©rence, on peut mettre en place les bonnes pratiques : centraliser ou synchroniser ce qui doit l‚Äô√™tre, limiter les d√©pendances directes, utiliser caches et √©v√©nements pour r√©duire l‚Äôimpact des appels interservices. L‚Äôobjectif final est d‚Äôavoir un syst√®me o√π chaque microservice est **faiblement coupl√©**, mais **s√©mantiquement align√©** avec les autres via des r√©f√©rentiels communs ma√Ætris√©s. Ainsi, on obtient le meilleur des deux mondes : l‚Äôagilit√© et l‚Äôind√©pendance des microservices, sans sacrifier la coh√©rence globale des donn√©es de l‚Äôentreprise.
